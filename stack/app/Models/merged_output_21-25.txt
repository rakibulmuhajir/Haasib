
=== File: InvoiceLineItem.php ===
Path: InvoiceLineItem.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class InvoiceLineItem extends Model
{
    use HasFactory, HasUuids;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'acct.invoice_line_items';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'invoice_id',
        'product_id',
        'description',
        'quantity',
        'unit_price',
        'discount_type',
        'discount_value',
        'tax_rate',
        'tax_amount',
        'total',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'quantity' => 'decimal:4',
            'unit_price' => 'decimal:2',
            'discount_value' => 'decimal:2',
            'tax_rate' => 'decimal:4',
            'tax_amount' => 'decimal:2',
            'total' => 'decimal:2',
            'invoice_id' => 'string',
            'product_id' => 'string',
        ];
    }

    /**
     * Get the invoice that owns the line item.
     */
    public function invoice(): BelongsTo
    {
        return $this->belongsTo(Invoice::class);
    }

    /**
     * Get the product for the line item.
     */
    public function product(): BelongsTo
    {
        return $this->belongsTo(Product::class);
    }

    /**
     * Calculate the line item total.
     */
    public function calculateTotal(): void
    {
        $subtotal = $this->quantity * $this->unit_price;

        // Calculate discount
        $discountAmount = 0;
        if ($this->discount_type === 'percentage') {
            $discountAmount = $subtotal * ($this->discount_value / 100);
        } elseif ($this->discount_type === 'fixed') {
            $discountAmount = $this->discount_value;
        }

        $afterDiscount = $subtotal - $discountAmount;

        // Calculate tax
        $taxAmount = $afterDiscount * ($this->tax_rate / 100);

        $this->total = $afterDiscount + $taxAmount;
        $this->tax_amount = $taxAmount;

        $this->save();
    }

    /**
     * Get the discount amount.
     */
    public function getDiscountAmount(): float
    {
        $subtotal = $this->quantity * $this->unit_price;

        if ($this->discount_type === 'percentage') {
            return $subtotal * ($this->discount_value / 100);
        } elseif ($this->discount_type === 'fixed') {
            return $this->discount_value;
        }

        return 0;
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\InvoiceLineItemFactory::new();
    }
}

---- File Content End ----


=== File: InvoiceTemplate.php ===
Path: InvoiceTemplate.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\SoftDeletes;

class InvoiceTemplate extends Model
{
    use HasFactory, HasUuids, SoftDeletes;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'acct.invoice_templates';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'company_id',
        'name',
        'description',
        'customer_id',
        'currency',
        'template_data',
        'settings',
        'is_active',
        'created_by_user_id',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'template_data' => 'array',
            'settings' => 'array',
            'is_active' => 'boolean',
            'company_id' => 'string',
            'customer_id' => 'string',
            'created_by_user_id' => 'string',
        ];
    }

    /**
     * Get the company that owns the template.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    /**
     * Get the customer associated with the template.
     */
    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    /**
     * Get the user who created the template.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by_user_id');
    }

    /**
     * Scope a query to only include active templates.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include templates for a specific company.
     */
    public function scopeForCompany($query, string $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope a query to only include templates for a specific customer.
     */
    public function scopeForCustomer($query, ?string $customerId)
    {
        if ($customerId) {
            return $query->where('customer_id', $customerId);
        }

        return $query->whereNull('customer_id');
    }

    /**
     * Apply template to create a new invoice.
     */
    public function applyToInvoice(?Customer $customer = null, array $overrides = []): array
    {
        $templateData = $this->template_data;

        // Build invoice data from template
        $invoiceData = [
            'company_id' => $this->company_id,
            'customer_id' => $customer?->id ?? $this->customer_id,
            'currency' => $overrides['currency'] ?? $this->currency,
            'notes' => $overrides['notes'] ?? $templateData['notes'] ?? null,
            'terms' => $overrides['terms'] ?? $templateData['terms'] ?? null,
            'issue_date' => $overrides['issue_date'] ?? now()->format('Y-m-d'),
            'due_date' => $overrides['due_date'] ?? now()->addDays($templateData['payment_terms'] ?? 30)->format('Y-m-d'),
            'line_items' => $this->processLineItems($templateData['line_items'] ?? [], $overrides),
        ];

        // Apply any field-level overrides
        return array_merge($invoiceData, array_intersect_key($overrides, $invoiceData));
    }

    /**
     * Process line items for template application.
     */
    protected function processLineItems(array $templateItems, array $overrides): array
    {
        $processedItems = [];

        foreach ($templateItems as $item) {
            $processedItem = [
                'description' => $item['description'],
                'quantity' => $item['quantity'],
                'unit_price' => $item['unit_price'],
                'tax_rate' => $item['tax_rate'] ?? 0,
                'discount_amount' => $item['discount_amount'] ?? 0,
            ];

            // Apply item-level overrides if they exist
            if (isset($overrides['line_items_overrides'][$item['id']])) {
                $itemOverrides = $overrides['line_items_overrides'][$item['id']];
                $processedItem = array_merge($processedItem, $itemOverrides);
            }

            $processedItems[] = $processedItem;
        }

        // Add any additional line items from overrides
        if (isset($overrides['additional_line_items'])) {
            $processedItems = array_merge($processedItems, $overrides['additional_line_items']);
        }

        return $processedItems;
    }

    /**
     * Validate template structure and data.
     */
    public function validateTemplate(): array
    {
        $errors = [];

        // Check required fields
        if (empty($this->name)) {
            $errors[] = 'Template name is required';
        }

        if (empty($this->company_id)) {
            $errors[] = 'Company is required';
        }

        if (empty($this->currency)) {
            $errors[] = 'Currency is required';
        }

        // Validate template data structure
        $templateData = $this->template_data ?? [];

        if (empty($templateData['line_items'])) {
            $errors[] = 'Template must have at least one line item';
        } else {
            foreach ($templateData['line_items'] as $index => $item) {
                if (empty($item['description'])) {
                    $errors[] = 'Line item '.($index + 1).' description is required';
                }

                if (! isset($item['quantity']) || $item['quantity'] <= 0) {
                    $errors[] = 'Line item '.($index + 1).' quantity must be greater than 0';
                }

                if (! isset($item['unit_price']) || $item['unit_price'] < 0) {
                    $errors[] = 'Line item '.($index + 1).' unit price cannot be negative';
                }
            }
        }

        return $errors;
    }

    /**
     * Get template summary information.
     */
    public function getSummary(): array
    {
        $templateData = $this->template_data ?? [];
        $lineItems = $templateData['line_items'] ?? [];

        $subtotal = 0;
        $taxAmount = 0;

        foreach ($lineItems as $item) {
            $itemTotal = ($item['quantity'] ?? 0) * ($item['unit_price'] ?? 0);
            $itemTax = $itemTotal * (($item['tax_rate'] ?? 0) / 100);
            $subtotal += $itemTotal;
            $taxAmount += $itemTax;
        }

        return [
            'name' => $this->name,
            'description' => $this->description,
            'currency' => $this->currency,
            'customer_name' => $this->customer?->name,
            'line_items_count' => count($lineItems),
            'subtotal' => $subtotal,
            'tax_amount' => $taxAmount,
            'total_amount' => $subtotal + $taxAmount,
            'is_active' => $this->is_active,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }

    /**
     * Duplicate template with optional modifications.
     */
    public function duplicate(string $newName, array $modifications = []): self
    {
        $duplicate = $this->replicate();
        $duplicate->name = $newName;
        $duplicate->created_by_user_id = auth()->id();

        // Apply modifications
        if (! empty($modifications)) {
            $templateData = $duplicate->template_data ?? [];

            if (isset($modifications['description'])) {
                $duplicate->description = $modifications['description'];
            }

            if (isset($modifications['customer_id'])) {
                $duplicate->customer_id = $modifications['customer_id'];
            }

            if (isset($modifications['currency'])) {
                $duplicate->currency = $modifications['currency'];
            }

            if (isset($modifications['notes'])) {
                $templateData['notes'] = $modifications['notes'];
            }

            if (isset($modifications['terms'])) {
                $templateData['terms'] = $modifications['terms'];
            }

            if (isset($modifications['payment_terms'])) {
                $templateData['payment_terms'] = $modifications['payment_terms'];
            }

            if (isset($modifications['line_items'])) {
                $templateData['line_items'] = $modifications['line_items'];
            }

            $duplicate->template_data = $templateData;
        }

        $duplicate->save();

        return $duplicate;
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\Invoicing\InvoiceTemplateFactory::new();
    }
}

---- File Content End ----


=== File: JournalAudit.php ===
Path: JournalAudit.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class JournalAudit extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_audit_log';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * Indicates if the model should timestamp.
     */
    public $timestamps = false;

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'journal_entry_id',
        'event_type',
        'actor_id',
        'payload',
        'created_at',
    ];

    /**
     * The attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'payload' => 'array',
            'created_at' => 'datetime',
        ];
    }

    /**
     * Get the journal entry that owns the audit record.
     */
    public function journalEntry(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class, 'journal_entry_id');
    }

    /**
     * Get the user who performed the action (if applicable).
     */
    public function actor(): BelongsTo
    {
        return $this->belongsTo(User::class, 'actor_id');
    }

    /**
     * Scope to get audit records for a specific journal entry.
     */
    public function scopeForJournalEntry($query, string $journalEntryId)
    {
        return $query->where('journal_entry_id', $journalEntryId);
    }

    /**
     * Scope to get audit records by event type.
     */
    public function scopeByEventType($query, string $eventType)
    {
        return $query->where('event_type', $eventType);
    }

    /**
     * Scope to get audit records by actor.
     */
    public function scopeByActor($query, string $actorId)
    {
        return $query->where('actor_id', $actorId);
    }

    /**
     * Scope to get audit records in a date range.
     */
    public function scopeInDateRange($query, $startDate, $endDate)
    {
        return $query->whereBetween('created_at', [$startDate, $endDate]);
    }

    /**
     * Scope to get created events.
     */
    public function scopeCreated($query)
    {
        return $query->where('event_type', 'created');
    }

    /**
     * Scope to get updated events.
     */
    public function scopeUpdated($query)
    {
        return $query->where('event_type', 'updated');
    }

    /**
     * Scope to get posted events.
     */
    public function scopePosted($query)
    {
        return $query->where('event_type', 'posted');
    }

    /**
     * Scope to get voided events.
     */
    public function scopeVoided($query)
    {
        return $query->where('event_type', 'voided');
    }

    /**
     * Scope to get approved events.
     */
    public function scopeApproved($query)
    {
        return $query->where('event_type', 'approved');
    }

    /**
     * Scope to get reversed events.
     */
    public function scopeReversed($query)
    {
        return $query->where('event_type', 'reversed');
    }

    /**
     * Scope to get attachment events.
     */
    public function scopeAttachmentAdded($query)
    {
        return $query->where('event_type', 'attachment_added');
    }

    /**
     * Scope to get system events (no actor).
     */
    public function scopeSystem($query)
    {
        return $query->whereNull('actor_id');
    }

    /**
     * Scope to get user events (has actor).
     */
    public function scopeByUser($query)
    {
        return $query->whereNotNull('actor_id');
    }

    /**
     * Check if this is a created event.
     */
    public function isCreated(): bool
    {
        return $this->event_type === 'created';
    }

    /**
     * Check if this is an updated event.
     */
    public function isUpdated(): bool
    {
        return $this->event_type === 'updated';
    }

    /**
     * Check if this is a posted event.
     */
    public function isPosted(): bool
    {
        return $this->event_type === 'posted';
    }

    /**
     * Check if this is a voided event.
     */
    public function isVoided(): bool
    {
        return $this->event_type === 'voided';
    }

    /**
     * Check if this is an approved event.
     */
    public function isApproved(): bool
    {
        return $this->event_type === 'approved';
    }

    /**
     * Check if this is a reversed event.
     */
    public function isReversed(): bool
    {
        return $this->event_type === 'reversed';
    }

    /**
     * Check if this is an attachment added event.
     */
    public function isAttachmentAdded(): bool
    {
        return $this->event_type === 'attachment_added';
    }

    /**
     * Check if this was performed by a system process.
     */
    public function isSystemAction(): bool
    {
        return is_null($this->actor_id);
    }

    /**
     * Check if this was performed by a user.
     */
    public function isUserAction(): bool
    {
        return ! is_null($this->actor_id);
    }

    /**
     * Get the event type label.
     */
    public function getEventTypeLabelAttribute(): string
    {
        $labels = [
            'created' => 'Created',
            'updated' => 'Updated',
            'posted' => 'Posted',
            'voided' => 'Voided',
            'approved' => 'Approved',
            'reversed' => 'Reversed',
            'attachment_added' => 'Attachment Added',
        ];

        return $labels[$this->event_type] ?? $this->event_type;
    }

    /**
     * Get a human-readable description of the event.
     */
    public function getDescriptionAttribute(): string
    {
        $actorName = $this->actor ? $this->actor->name : 'System';

        return "{$this->event_type_label} by {$actorName}";
    }

    /**
     * Create a new audit record.
     */
    public static function createEvent(
        string $journalEntryId,
        string $eventType,
        array $payload = [],
        ?string $actorId = null
    ): self {
        return static::create([
            'journal_entry_id' => $journalEntryId,
            'event_type' => $eventType,
            'actor_id' => $actorId,
            'payload' => $payload,
            'created_at' => now(),
        ]);
    }

    /**
     * Create a system-generated audit record.
     */
    public static function createSystemEvent(
        string $journalEntryId,
        string $eventType,
        array $payload = []
    ): self {
        return static::createEvent($journalEntryId, $eventType, $payload);
    }

    /**
     * Create a user-generated audit record.
     */
    public static function createUserEvent(
        string $journalEntryId,
        string $eventType,
        string $actorId,
        array $payload = []
    ): self {
        return static::createEvent($journalEntryId, $eventType, $payload, $actorId);
    }

    /**
     * Get the previous state from the payload.
     */
    public function getPreviousStateAttribute(): ?array
    {
        return $this->payload['previous_state'] ?? null;
    }

    /**
     * Get the new state from the payload.
     */
    public function getNewStateAttribute(): ?array
    {
        return $this->payload['new_state'] ?? null;
    }

    /**
     * Get the changes from the payload.
     */
    public function getChangesAttribute(): ?array
    {
        return $this->payload['changes'] ?? null;
    }

    /**
     * Get any metadata from the payload.
     */
    public function getMetadataAttribute(): ?array
    {
        return $this->payload['metadata'] ?? null;
    }
}

---- File Content End ----


=== File: JournalBatch.php ===
Path: JournalBatch.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class JournalBatch extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_batches';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'company_id',
        'batch_number',
        'status',
        'scheduled_post_at',
        'total_entries',
        'total_debits',
        'total_credits',
        'created_by',
        'approved_by',
        'approved_at',
        'posted_by',
        'posted_at',
        'voided_by',
        'voided_at',
        'void_reason',
        'attachments',
        'metadata',
    ];

    /**
     * The attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'scheduled_post_at' => 'datetime',
            'approved_at' => 'datetime',
            'posted_at' => 'datetime',
            'voided_at' => 'datetime',
            'total_entries' => 'integer',
            'total_debits' => 'decimal:2',
            'total_credits' => 'decimal:2',
            'attachments' => 'array',
            'metadata' => 'array',
        ];
    }

    /**
     * The attributes that should be hidden for arrays.
     */
    protected $hidden = [
        'metadata',
    ];

    /**
     * Get the company that owns the batch.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class, 'company_id');
    }

    /**
     * Get the user who created the batch.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    /**
     * Get the user who approved the batch.
     */
    public function approver(): BelongsTo
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    /**
     * Get the user who posted the batch.
     */
    public function poster(): BelongsTo
    {
        return $this->belongsTo(User::class, 'posted_by');
    }

    /**
     * Get the user who voided the batch.
     */
    public function voider(): BelongsTo
    {
        return $this->belongsTo(User::class, 'voided_by');
    }

    /**
     * Get the journal entries in this batch.
     */
    public function journalEntries(): HasMany
    {
        return $this->hasMany(JournalEntry::class, 'batch_id');
    }

    /**
     * Scope to get batches for a specific company.
     */
    public function scopeForCompany($query, string $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope to get batches by status.
     */
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Scope to get draft batches.
     */
    public function scopeDraft($query)
    {
        return $query->where('status', 'draft');
    }

    /**
     * Scope to get ready batches.
     */
    public function scopeReady($query)
    {
        return $query->where('status', 'ready');
    }

    /**
     * Scope to get scheduled batches.
     */
    public function scopeScheduled($query)
    {
        return $query->where('status', 'scheduled')
            ->whereNotNull('scheduled_post_at');
    }

    /**
     * Scope to get posted batches.
     */
    public function scopePosted($query)
    {
        return $query->where('status', 'posted');
    }

    /**
     * Scope to get void batches.
     */
    public function scopeVoid($query)
    {
        return $query->where('status', 'void');
    }

    /**
     * Check if batch is in draft status.
     */
    public function isDraft(): bool
    {
        return $this->status === 'draft';
    }

    /**
     * Check if batch is ready for approval.
     */
    public function isReady(): bool
    {
        return $this->status === 'ready';
    }

    /**
     * Check if batch is scheduled for posting.
     */
    public function isScheduled(): bool
    {
        return $this->status === 'scheduled';
    }

    /**
     * Check if batch is posted.
     */
    public function isPosted(): bool
    {
        return $this->status === 'posted';
    }

    /**
     * Check if batch is void.
     */
    public function isVoid(): bool
    {
        return $this->status === 'void';
    }

    /**
     * Check if batch can be submitted for approval.
     */
    public function canBeSubmitted(): bool
    {
        return $this->isDraft() &&
               $this->journalEntries->count() > 0 &&
               $this->isBalanced();
    }

    /**
     * Check if batch can be approved.
     */
    public function canBeApproved(): bool
    {
        return $this->isReady() && $this->isBalanced();
    }

    /**
     * Check if batch can be posted.
     */
    public function canBePosted(): bool
    {
        return $this->isReady() && $this->isBalanced();
    }

    /**
     * Check if batch is balanced (total debits = total credits).
     */
    public function isBalanced(): bool
    {
        return abs($this->total_debits - $this->total_credits) < 0.01;
    }

    /**
     * Check if batch is scheduled for future posting.
     */
    public function isScheduledForFuture(): bool
    {
        return $this->scheduled_post_at && $this->scheduled_post_at->isFuture();
    }

    /**
     * Check if batch can be scheduled (is ready and has future date).
     */
    public function canBeScheduled(): bool
    {
        return $this->isReady() && $this->isBalanced();
    }

    /**
     * Get the status label.
     */
    public function getStatusLabelAttribute(): string
    {
        $labels = [
            'draft' => 'Draft',
            'ready' => 'Ready',
            'scheduled' => 'Scheduled',
            'posted' => 'Posted',
            'void' => 'Void',
        ];

        return $labels[$this->status] ?? $this->status;
    }

    /**
     * Calculate and update totals based on journal entries.
     */
    public function recalculateTotals(): void
    {
        $totals = $this->journalEntries()
            ->selectRaw('COUNT(*) as total_entries')
            ->selectRaw('SUM(total_debits) as total_debits')
            ->selectRaw('SUM(total_credits) as total_credits')
            ->first();

        $this->update([
            'total_entries' => $totals->total_entries ?? 0,
            'total_debits' => $totals->total_debits ?? 0,
            'total_credits' => $totals->total_credits ?? 0,
        ]);
    }

    /**
     * Add journal entries to this batch.
     */
    public function addJournalEntries(array $entryIds): bool
    {
        foreach ($entryIds as $entryId) {
            $entry = JournalEntry::find($entryId);
            if ($entry && $entry->company_id === $this->company_id) {
                $entry->update(['batch_id' => $this->id]);
            }
        }

        $this->recalculateTotals();

        return true;
    }

    /**
     * Remove journal entries from this batch.
     */
    public function removeJournalEntries(array $entryIds): bool
    {
        JournalEntry::whereIn('id', $entryIds)
            ->where('batch_id', $this->id)
            ->update(['batch_id' => null]);

        $this->recalculateTotals();

        return true;
    }
}

---- File Content End ----


=== File: JournalEntry.php ===
Path: JournalEntry.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class JournalEntry extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_entries';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'company_id',
        'batch_id',
        'template_id',
        'reference',
        'description',
        'date',
        'type',
        'status',
        'approval_note',
        'created_by',
        'approved_by',
        'approved_at',
        'posted_by',
        'posted_at',
        'voided_by',
        'voided_at',
        'void_reason',
        'currency',
        'exchange_rate',
        'fiscal_year_id',
        'accounting_period_id',
        'source_document_type',
        'source_document_id',
        'origin_command',
        'auto_generated',
        'reverse_of_entry_id',
        'reversal_entry_id',
        'attachments',
        'metadata',
    ];

    /**
     * The attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'date' => 'date',
            'approved_at' => 'datetime',
            'posted_at' => 'datetime',
            'voided_at' => 'datetime',
            'exchange_rate' => 'decimal:8',
            'auto_generated' => 'boolean',
            'attachments' => 'array',
            'metadata' => 'array',
        ];
    }

    /**
     * The attributes that should be hidden for arrays.
     */
    protected $hidden = [
        'metadata',
    ];

    /**
     * Get the company that owns the journal entry.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class, 'company_id');
    }

    /**
     * Get the batch that contains the journal entry.
     */
    public function batch(): BelongsTo
    {
        return $this->belongsTo(JournalBatch::class, 'batch_id');
    }

    /**
     * Get the recurring template that generated this entry.
     */
    public function template(): BelongsTo
    {
        return $this->belongsTo(RecurringJournalTemplate::class, 'template_id');
    }

    /**
     * Get the user who created the journal entry.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    /**
     * Get the user who approved the journal entry.
     */
    public function approver(): BelongsTo
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    /**
     * Get the user who posted the journal entry.
     */
    public function poster(): BelongsTo
    {
        return $this->belongsTo(User::class, 'posted_by');
    }

    /**
     * Get the user who voided the journal entry.
     */
    public function voider(): BelongsTo
    {
        return $this->belongsTo(User::class, 'voided_by');
    }

    /**
     * Get the fiscal year for this entry.
     */
    public function fiscalYear(): BelongsTo
    {
        return $this->belongsTo(FiscalYear::class, 'fiscal_year_id');
    }

    /**
     * Get the accounting period for this entry.
     */
    public function accountingPeriod(): BelongsTo
    {
        return $this->belongsTo(AccountingPeriod::class, 'accounting_period_id');
    }

    /**
     * Get the journal entry that this entry reverses.
     */
    public function reverseOf(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class, 'reverse_of_entry_id');
    }

    /**
     * Get the journal entry that reverses this entry.
     */
    public function reversal(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class, 'reversal_entry_id');
    }

    /**
     * Get the transactions for this journal entry.
     */
    public function transactions(): HasMany
    {
        return $this->hasMany(JournalTransaction::class, 'journal_entry_id')
            ->orderBy('line_number');
    }

    /**
     * Get the sources for this journal entry.
     */
    public function sources(): HasMany
    {
        return $this->hasMany(JournalEntrySource::class, 'journal_entry_id');
    }

    /**
     * Get the audit log entries for this journal entry.
     */
    public function auditLog(): HasMany
    {
        return $this->hasMany(JournalAudit::class, 'journal_entry_id')
            ->orderBy('created_at');
    }

    /**
     * Scope to get entries for a specific company.
     */
    public function scopeForCompany($query, string $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope to get entries by status.
     */
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Scope to get entries by type.
     */
    public function scopeByType($query, string $type)
    {
        return $query->where('type', $type);
    }

    /**
     * Scope to get entries in a date range.
     */
    public function scopeInDateRange($query, $startDate, $endDate)
    {
        return $query->whereBetween('date', [$startDate, $endDate]);
    }

    /**
     * Scope to get entries for a specific period.
     */
    public function scopeForPeriod($query, string $periodId)
    {
        return $query->where('accounting_period_id', $periodId);
    }

    /**
     * Scope to get manual entries (not auto-generated).
     */
    public function scopeManual($query)
    {
        return $query->where('auto_generated', false);
    }

    /**
     * Scope to get automatic entries.
     */
    public function scopeAutomatic($query)
    {
        return $query->where('auto_generated', true);
    }

    /**
     * Scope to get entries with source documents.
     */
    public function scopeWithSourceDocument($query, string $type, string $id)
    {
        return $query->where('source_document_type', $type)
            ->where('source_document_id', $id);
    }

    /**
     * Check if entry is in draft status.
     */
    public function isDraft(): bool
    {
        return $this->status === 'draft';
    }

    /**
     * Check if entry is pending approval.
     */
    public function isPendingApproval(): bool
    {
        return $this->status === 'pending_approval';
    }

    /**
     * Check if entry is approved.
     */
    public function isApproved(): bool
    {
        return $this->status === 'approved';
    }

    /**
     * Check if entry is posted.
     */
    public function isPosted(): bool
    {
        return $this->status === 'posted';
    }

    /**
     * Check if entry is void.
     */
    public function isVoid(): bool
    {
        return $this->status === 'void';
    }

    /**
     * Check if entry can be submitted for approval.
     */
    public function canBeSubmitted(): bool
    {
        return $this->isDraft() && $this->transactions->count() > 0;
    }

    /**
     * Check if entry can be approved.
     */
    public function canBeApproved(): bool
    {
        return $this->isPendingApproval() && $this->isBalanced();
    }

    /**
     * Check if entry can be posted.
     */
    public function canBePosted(): bool
    {
        return $this->isApproved() && $this->isBalanced();
    }

    /**
     * Check if entry is balanced (debits = credits).
     */
    public function isBalanced(): bool
    {
        $totals = $this->transactions()
            ->selectRaw('SUM(CASE WHEN debit_credit = \'debit\' THEN amount ELSE 0 END) as total_debits')
            ->selectRaw('SUM(CASE WHEN debit_credit = \'credit\' THEN amount ELSE 0 END) as total_credits')
            ->first();

        return abs($totals->total_debits - $totals->total_credits) < 0.01;
    }

    /**
     * Get the total debits for this entry.
     */
    public function getTotalDebitsAttribute(): float
    {
        return $this->transactions()
            ->where('debit_credit', 'debit')
            ->sum('amount');
    }

    /**
     * Get the total credits for this entry.
     */
    public function getTotalCreditsAttribute(): float
    {
        return $this->transactions()
            ->where('debit_credit', 'credit')
            ->sum('amount');
    }

    /**
     * Get the status label.
     */
    public function getStatusLabelAttribute(): string
    {
        $labels = [
            'draft' => 'Draft',
            'pending_approval' => 'Pending Approval',
            'approved' => 'Approved',
            'posted' => 'Posted',
            'void' => 'Void',
        ];

        return $labels[$this->status] ?? $this->status;
    }

    /**
     * Get the type label.
     */
    public function getTypeLabelAttribute(): string
    {
        $labels = [
            'sales' => 'Sales',
            'purchase' => 'Purchase',
            'payment' => 'Payment',
            'receipt' => 'Receipt',
            'adjustment' => 'Adjustment',
            'closing' => 'Closing',
            'opening' => 'Opening',
            'reversal' => 'Reversal',
            'automation' => 'Automation',
        ];

        return $labels[$this->type] ?? $this->type;
    }
}

---- File Content End ----

