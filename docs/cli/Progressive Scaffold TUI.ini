Progressive Scaffold TUI

*Technical Specification for Double-Entry Accounting Application*

Version 1.0 \| For Junior Developer Implementation

1\. Executive Summary

This document specifies the Progressive Scaffold approach for the TUI
(Terminal User Interface) of our double-entry accounting application.
The TUI is designed for power users who prefer keyboard-driven workflows
over the existing GUI form interface.

The Progressive Scaffold provides contextual guidance as users type
commands, reducing cognitive load while maintaining the speed advantages
of a command-line interface. Smart defaults automatically populate
values from the system (like customer currency preferences), making
common operations faster.

2\. Problem Statement

2.1 Current Challenges

Complex commands in accounting applications present several usability
challenges:

- Users must memorize exact command syntax and argument order

- Required vs optional arguments are not immediately clear

- Flag syntax (\--currency, \--due-date) is easy to forget

- No visibility into what the system expects next

- Repetitive entry of defaults (same currency, same tax rates)

2.2 Target Users

The TUI serves power users who process high volumes of transactions.
They have chosen the TUI over the GUI for speed, but still need
discoverability for less-frequent commands. They expect the system to
remember their preferences and defaults.

3\. Solution Architecture: Progressive Scaffold

3.1 Core Concept

The Progressive Scaffold displays a command skeleton below the input
line, showing the complete structure of the recognized command. As the
user types, a pointer indicates their current position, and contextual
help explains each argument.

3.2 Visual Layout

The interface consists of four distinct zones:

> ┌─────────────────────────────────────────────────────────────┐
>
> │ INPUT LINE │
>
> │ \> invoice create acme \_ │
>
> ├─────────────────────────────────────────────────────────────┤
>
> │ SKELETON ZONE │
>
> │ invoice create \<customer\> \<amount\> \[\--currency\] \[\--due\] │
>
> │ ↑ │
>
> │ amount (number) │
>
> ├─────────────────────────────────────────────────────────────┤
>
> │ FLAG CHIPS ZONE │
>
> │ \[\--currency=USD\*\] \[\--due\] \[\--reference\] \[\--tax-rate\] │
>
> ├─────────────────────────────────────────────────────────────┤
>
> │ STATUS BAR │
>
> │ Required: amount \| Optional: currency, due, reference │
>
> └─────────────────────────────────────────────────────────────┘

3.3 Component Breakdown

Input Line

The primary text input where users type commands. Standard terminal
input behavior with history (up/down arrows), cursor movement, and
editing.

Skeleton Zone

Shows the complete command structure once entity and verb are
recognized. Uses angle brackets for required arguments (\<customer\>)
and square brackets for optional flags (\[\--currency\]). The pointer
(↑) tracks current position. Below the pointer, display the argument
name and expected type.

Flag Chips Zone

Clickable or Tab-selectable chips for common flags. Chips with asterisk
(\*) indicate smart defaults are applied. Selecting a chip inserts it
into the input. Chips are context-aware and change based on command
type.

Status Bar

Shows remaining required arguments and available optional ones. Updates
in real-time as the user fills in values.

4\. Smart Defaults System

4.1 Core Principle

Smart defaults reduce repetitive typing by automatically populating
predictable values. The system fetches defaults from related entities
and user preferences, but never applies them silently---users always see
what defaults are active.

4.2 Default Sources (Priority Order)

- Entity-specific: Customer\'s preferred currency, vendor\'s default
  payment terms

- Recent history: Last used account for similar transactions

- User preferences: Default tax rate, preferred date format

- System defaults: Company\'s base currency, fiscal year settings

4.3 Implementation Pattern

> // Pseudo-code for smart default resolution
>
> async function resolveDefaults(command, context) {
>
> const defaults = {};
>
> // 1. Fetch entity-specific defaults
>
> if (context.customer) {
>
> const customer = await Customer.findById(context.customer);
>
> defaults.currency = customer.preferredCurrency;
>
> defaults.paymentTerms = customer.defaultPaymentTerms;
>
> }
>
> // 2. Fetch user\'s recent history
>
> const recentTxn = await Transaction.findRecent({
>
> userId: context.userId,
>
> type: command.verb,
>
> limit: 1
>
> });
>
> if (recentTxn && !defaults.account) {
>
> defaults.account = recentTxn.account;
>
> }
>
> // 3. User preferences
>
> const prefs = await UserPreferences.get(context.userId);
>
> defaults.taxRate = defaults.taxRate \|\| prefs.defaultTaxRate;
>
> // 4. System defaults (fallback)
>
> const system = await SystemSettings.get();
>
> defaults.currency = defaults.currency \|\| system.baseCurrency;
>
> return defaults;
>
> }

5\. Command Schema Definition

5.1 Schema Structure

Each command must have a schema that defines its structure, arguments,
and default sources. This schema drives the Progressive Scaffold
rendering.

> // Schema definition format
>
> const invoiceCreateSchema = {
>
> entity: \'invoice\',
>
> verb: \'create\',
>
> description: \'Create a new sales invoice\',
>
> arguments: \[
>
> {
>
> name: \'customer\',
>
> type: \'reference\',
>
> referenceType: \'Customer\',
>
> required: true,
>
> position: 0,
>
> hint: \'Customer name or ID\',
>
> autocomplete: true
>
> },
>
> {
>
> name: \'amount\',
>
> type: \'currency\',
>
> required: true,
>
> position: 1,
>
> hint: \'Invoice amount\',
>
> validation: { min: 0.01 }
>
> }
>
> \],
>
> flags: \[
>
> {
>
> name: \'currency\',
>
> short: \'c\',
>
> type: \'enum\',
>
> values: \[\'USD\', \'EUR\', \'GBP\', \'PKR\'\],
>
> defaultSource: \'customer.preferredCurrency\',
>
> fallback: \'system.baseCurrency\'
>
> },
>
> {
>
> name: \'due\',
>
> short: \'d\',
>
> type: \'date\',
>
> defaultSource: \'customer.paymentTerms.dueDate\',
>
> hint: \'Due date (YYYY-MM-DD or +30d)\'
>
> },
>
> {
>
> name: \'reference\',
>
> short: \'r\',
>
> type: \'string\',
>
> hint: \'PO number or external reference\'
>
> },
>
> {
>
> name: \'tax-rate\',
>
> short: \'t\',
>
> type: \'percentage\',
>
> defaultSource: \'user.preferences.defaultTaxRate\',
>
> fallback: \'system.defaultTaxRate\'
>
> }
>
> \]
>
> };

6\. Use Cases for Double-Entry Accounting

6.1 Invoice Creation

Creating sales invoices is one of the most frequent operations. The
Progressive Scaffold should make this fast while ensuring required
fields are captured.

Command Flow

> User types: invoice create
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> invoice create \_ │
>
> │ │
>
> │ invoice create \<customer\> \<amount\> \[\--currency\] \[\--due\] │
>
> │ ↑ │
>
> │ customer name or ID │
>
> │ │
>
> │ \[\--currency\] \[\--due\] \[\--reference\] \[\--tax-rate\] │
>
> │ │
>
> │ Required: customer, amount │
>
> └─────────────────────────────────────────────────────────────┘
>
> User types: invoice create acme
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> invoice create acme \_ │
>
> │ │
>
> │ invoice create \<customer\> \<amount\> \[\--currency\] \[\--due\] │
>
> │ ↑ │
>
> │ amount (number) │
>
> │ │
>
> │ \[\--currency=PKR\*\] \[\--due=+30d\*\] \[\--reference\] │
>
> │ │
>
> │ Required: amount \| Acme Corp defaults applied │
>
> └─────────────────────────────────────────────────────────────┘

Implementation Steps

1.  Parse input to detect \'invoice create\' pattern

2.  Show skeleton with pointer at \<customer\> position

3.  Enable autocomplete for customer field (search by name/ID)

4.  When customer is entered, fetch customer record async

5.  Populate flag chips with customer\'s defaults (currency, payment
    terms)

6.  Move pointer to \<amount\> position

7.  On Enter, validate all required fields and execute with defaults

Double-Entry Accounting Entries

When the invoice is created, the system generates these journal entries
automatically:

> Debit: Accounts Receivable (1200) PKR 50,000
>
> Credit: Sales Revenue (4000) PKR 50,000
>
> If tax is applied (\--tax-rate=17):
>
> Debit: Accounts Receivable (1200) PKR 58,500
>
> Credit: Sales Revenue (4000) PKR 50,000
>
> Credit: Sales Tax Payable (2300) PKR 8,500

6.2 Payment Recording

Recording payments against invoices with automatic account suggestions
based on payment method.

Command Flow

> User types: payment create
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> payment create \_ │
>
> │ │
>
> │ payment create \<invoice\> \<amount\> \[\--method\] \[\--account\] │
>
> │ ↑ │
>
> │ invoice number or ID │
>
> │ │
>
> │ \[\--method=bank\*\] \[\--account\] \[\--reference\] \[\--date\] │
>
> │ │
>
> │ Required: invoice, amount │
>
> └─────────────────────────────────────────────────────────────┘
>
> User types: payment create INV-2024-0042
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> payment create INV-2024-0042 \_ │
>
> │ │
>
> │ payment create \<invoice\> \<amount\> \[\--method\] \[\--account\] │
>
> │ ↑ │
>
> │ amount (default: 50000.00) │
>
> │ │
>
> │ \[\--method=bank\*\] \[\--account=1100\*\] \[\--reference\] │
>
> │ │
>
> │ Invoice: INV-2024-0042 \| Balance: PKR 50,000.00 │
>
> └─────────────────────────────────────────────────────────────┘

Smart Default Logic

- Amount defaults to invoice\'s remaining balance

- Payment method defaults to user\'s most-used method

- Account auto-selects based on payment method (bank transfer → Bank
  Account, cash → Cash Account)

- Date defaults to today

Implementation Steps

1.  Parse \'payment create\' pattern

2.  Enable invoice autocomplete (search by number, customer, amount)

3.  When invoice selected, fetch invoice details and balance

4.  Pre-fill amount with remaining balance (user can override)

5.  Show method chips with user\'s preferred method highlighted

6.  Auto-select account based on method selection

7.  Validate amount doesn\'t exceed balance (unless overpayment allowed)

Double-Entry Accounting Entries

> For bank payment:
>
> Debit: Bank Account (1100) PKR 50,000
>
> Credit: Accounts Receivable (1200) PKR 50,000
>
> For cash payment:
>
> Debit: Cash Account (1000) PKR 50,000
>
> Credit: Accounts Receivable (1200) PKR 50,000

6.3 Expense Recording

Recording business expenses with intelligent category and account
suggestions.

Command Flow

> User types: expense create
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> expense create \_ │
>
> │ │
>
> │ expense create \<vendor\> \<amount\> \<category\> \[\--account\] │
>
> │ ↑ │
>
> │ vendor name or ID │
>
> │ │
>
> │ \[\--account\] \[\--date\] \[\--reference\] \[\--recurring\] │
>
> │ │
>
> │ Required: vendor, amount, category │
>
> └─────────────────────────────────────────────────────────────┘
>
> User types: expense create PTCL 5000
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> expense create PTCL 5000 \_ │
>
> │ │
>
> │ expense create \<vendor\> \<amount\> \<category\> \[\--account\] │
>
> │ ↑ │
>
> │ category (suggested: utilities) │
>
> │ │
>
> │ \[\--account=5200\*\] \[\--date=today\*\] \[\--recurring\] │
>
> │ │
>
> │ PTCL \| Typical category: Utilities \| Last: 5200 │
>
> └─────────────────────────────────────────────────────────────┘

Smart Default Logic

- Category suggested based on vendor\'s historical transactions

- Account auto-selected based on category (Utilities → Utilities Expense
  5200)

- Recurring flag suggested if vendor has recurring history

- Payment account defaults based on user preference

Implementation Steps

1.  Parse \'expense create\' pattern

2.  Enable vendor autocomplete

3.  When vendor selected, query historical transactions for this vendor

4.  Suggest most-used category for this vendor

5.  Map category to appropriate expense account

6.  Check if vendor has recurring pattern, suggest \--recurring if so

Double-Entry Accounting Entries

> Paid from bank:
>
> Debit: Utilities Expense (5200) PKR 5,000
>
> Credit: Bank Account (1100) PKR 5,000
>
> Recorded as payable (not yet paid):
>
> Debit: Utilities Expense (5200) PKR 5,000
>
> Credit: Accounts Payable (2100) PKR 5,000

6.4 Manual Journal Entry

For adjustments and complex transactions that don\'t fit standard
patterns. This is the most flexible but also most complex command.

Command Flow

> User types: journal create
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> journal create \_ │
>
> │ │
>
> │ journal create \<description\> \--lines \[\--date\] \[\--ref\] │
>
> │ ↑ │
>
> │ transaction description │
>
> │ │
>
> │ \[\--date=today\*\] \[\--reference\] \[\--memo\] │
>
> │ │
>
> │ Required: description, lines (at least 2) │
>
> └─────────────────────────────────────────────────────────────┘
>
> Full command example:
>
> journal create \"Month-end depreciation\" \--lines \\
>
> \"6100:dr:5000\" \"1500:cr:5000\" \--memo \"Dec 2024 depreciation\"

Line Format

Each line follows the pattern: account:direction:amount where direction
is \'dr\' (debit) or \'cr\' (credit). The system validates that debits
equal credits before allowing submission.

Implementation Steps

1.  Parse \'journal create\' pattern

2.  Accept free-text description

3.  Enter special mode for \--lines flag (multi-value input)

4.  Validate each line format as entered

5.  Show running balance (debits vs credits) in status bar

6.  Block submission until balanced

7.  Enable account autocomplete within line entries

6.5 Bill Creation (Vendor Invoice)

Recording bills from vendors creates payables. Similar to expense but
creates a liability instead of immediate payment.

Command Flow

> User types: bill create ali-traders 25000
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> bill create ali-traders 25000 \_ │
>
> │ │
>
> │ bill create \<vendor\> \<amount\> \[\--category\] \[\--due\] │
>
> │ ↑ │
>
> │ category (suggested: inventory) │
>
> │ │
>
> │ \[\--category=inv\*\] \[\--due=+30d\*\] \[\--reference\] │
>
> │ │
>
> │ Ali Traders \| Terms: Net 30 \| Last category: Inventory │
>
> └─────────────────────────────────────────────────────────────┘

Smart Default Logic

- Due date calculated from vendor\'s payment terms

- Category suggested from vendor\'s purchase history

- Expense account mapped from category

Implementation Steps

1.  Parse \'bill create\' pattern

2.  Fetch vendor details including payment terms

3.  Calculate due date from payment terms

4.  Query vendor\'s purchase history for category suggestion

5.  Map category to appropriate expense/inventory account

Double-Entry Accounting Entries

> For inventory purchase:
>
> Debit: Inventory (1400) PKR 25,000
>
> Credit: Accounts Payable (2100) PKR 25,000
>
> For service/expense:
>
> Debit: Expense Account (5xxx) PKR 25,000
>
> Credit: Accounts Payable (2100) PKR 25,000

6.6 Account Transfer

Moving money between accounts (bank to cash, between bank accounts).

Command Flow

> User types: transfer
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> transfer \_ │
>
> │ │
>
> │ transfer \<from-account\> \<to-account\> \<amount\> │
>
> │ ↑ │
>
> │ source account │
>
> │ │
>
> │ Recent: \[1100 Bank\] \[1000 Cash\] \[1110 Savings\] │
>
> │ │
>
> │ Required: from-account, to-account, amount │
>
> └─────────────────────────────────────────────────────────────┘

Implementation Steps

1.  Parse \'transfer\' command (no verb needed, single action)

2.  Show recent/frequent accounts as quick-select chips

3.  Enable account autocomplete filtered to cash/bank accounts only

4.  Validate accounts are different

5.  Show available balance of source account

Double-Entry Accounting Entries

> Bank to Cash withdrawal:
>
> Debit: Cash Account (1000) PKR 10,000
>
> Credit: Bank Account (1100) PKR 10,000

6.7 Bank Reconciliation

Matching bank statement entries with recorded transactions.

Command Flow

> User types: reconcile 1100
>
> ┌─────────────────────────────────────────────────────────────┐
>
> │ \> reconcile 1100 \_ │
>
> │ │
>
> │ reconcile \<account\> \[\--statement-balance\] \[\--date\] │
>
> │ ↑ │
>
> │ statement ending balance │
>
> │ │
>
> │ \[\--date=today\*\] \[\--statement-balance\] │
>
> │ │
>
> │ Bank Account (1100) \| Book Balance: PKR 245,000 │
>
> └─────────────────────────────────────────────────────────────┘

Implementation Steps

1.  Parse \'reconcile\' command with account

2.  Fetch current book balance

3.  Accept statement balance for comparison

4.  Enter reconciliation mode showing uncleared transactions

5.  Allow marking transactions as cleared (space key)

6.  Show running difference until balanced

7\. Data Structures

7.1 Command Schema Registry

> // Central registry for all command schemas
>
> const CommandRegistry = {
>
> schemas: Map\<string, CommandSchema\>,
>
> register(schema: CommandSchema) {
>
> const key = \`\${schema.entity}:\${schema.verb}\`;
>
> this.schemas.set(key, schema);
>
> },
>
> lookup(entity: string, verb: string): CommandSchema \| null {
>
> return this.schemas.get(\`\${entity}:\${verb}\`) \|\| null;
>
> },
>
> getSuggestions(partial: string): CommandSchema\[\] {
>
> // Returns matching schemas for autocomplete
>
> }
>
> };

7.2 Parse State

> interface ParseState {
>
> raw: string; // Original input
>
> entity: string \| null; // \'invoice\', \'payment\', etc.
>
> verb: string \| null; // \'create\', \'update\', etc.
>
> args: ParsedArg\[\]; // Positional arguments
>
> flags: ParsedFlag\[\]; // Named flags
>
> cursor: number; // Current cursor position
>
> currentField: string; // Field name at cursor
>
> schema: CommandSchema; // Matched schema
>
> defaults: ResolvedDefaults; // Smart defaults
>
> validation: ValidationResult;
>
> }
>
> interface ParsedArg {
>
> name: string;
>
> value: string \| null;
>
> position: number;
>
> isComplete: boolean;
>
> }
>
> interface ParsedFlag {
>
> name: string;
>
> value: string \| null;
>
> isDefault: boolean; // True if value from smart default
>
> source: string; // Where default came from
>
> }

7.3 Smart Default Resolution

> interface ResolvedDefaults {
>
> values: Map\<string, DefaultValue\>;
>
> sources: Map\<string, DefaultSource\>;
>
> }
>
> interface DefaultValue {
>
> value: any;
>
> displayValue: string; // Human-readable
>
> source: DefaultSource;
>
> confidence: number; // 0-1, how confident this is correct
>
> }
>
> enum DefaultSource {
>
> ENTITY = \'entity\', // From related entity (customer, vendor)
>
> HISTORY = \'history\', // From user\'s recent transactions
>
> PREFERENCE = \'preference\', // From user preferences
>
> SYSTEM = \'system\' // System default
>
> }

8\. Implementation Guide

8.1 Component Architecture

> TUIApplication
>
> ├── InputController
>
> │ ├── KeyboardHandler
>
> │ ├── HistoryManager
>
> │ └── CursorManager
>
> ├── CommandParser
>
> │ ├── Tokenizer
>
> │ ├── SchemaMatcherState machine for parsing
>
> │ └── Validator
>
> ├── ScaffoldRenderer
>
> │ ├── SkeletonBuilder
>
> │ ├── PointerTracker
>
> │ ├── HintGenerator
>
> │ └── FlagChipRenderer
>
> ├── SmartDefaultsEngine
>
> │ ├── EntityResolver
>
> │ ├── HistoryAnalyzer
>
> │ ├── PreferenceLoader
>
> │ └── DefaultMerger
>
> ├── AutocompleteProvider
>
> │ ├── EntitySearch
>
> │ ├── AccountSearch
>
> │ └── FuzzyMatcher
>
> └── ExecutionEngine
>
> ├── CommandBuilder
>
> ├── TransactionCreator
>
> └── JournalEntryGenerator

8.2 Event Flow

1.  User presses key → InputController captures

2.  InputController updates input buffer → triggers parse

3.  CommandParser tokenizes → matches schema → validates

4.  If entity/verb matched → SmartDefaultsEngine resolves defaults
    (async)

5.  ScaffoldRenderer updates display with current state

6.  AutocompleteProvider generates suggestions for current field

7.  On Enter → ExecutionEngine validates final state → creates
    transaction

8.3 Key Implementation Notes

Async Default Resolution

Defaults must be fetched asynchronously to avoid blocking the UI. Show a
loading indicator on flag chips while defaults are being resolved. Cache
resolved defaults for the session.

Debounced Parsing

Don\'t re-parse on every keystroke. Use a 50-100ms debounce to batch
rapid typing. Immediate feedback is still provided via the input
display.

Validation Timing

Validate incrementally as user types, but only show errors when user
moves past a field or presses Enter. Premature error messages frustrate
users.

Default Override Behavior

When user explicitly types a value for a defaulted field, clear the
\'isDefault\' flag. If user deletes their value, restore the default.
Track user intent separately from value.

9\. Testing Strategy

9.1 Unit Tests

- CommandParser: Test each command schema parses correctly

- SmartDefaultsEngine: Test default resolution priority

- ScaffoldRenderer: Test skeleton generation for each command type

- Validator: Test all validation rules for each field type

9.2 Integration Tests

- End-to-end command execution with defaults

- Journal entry generation (verify debits = credits)

- Default fetch from database entities

9.3 User Testing Scenarios

- New user: Can they create an invoice without documentation?

- Power user: Is the scaffold helpful or in the way?

- Edge cases: Partial input, cancellation, errors

10\. Success Metrics

Track these metrics to validate the implementation:

- Command completion rate: % of started commands that execute
  successfully

- Time to complete: Average time from first keystroke to execution

- Default acceptance rate: % of smart defaults accepted without override

- Error rate: % of commands that fail validation

- Help/documentation access: Reduction indicates improved
  discoverability

Appendix A: Account Code Reference

| **Code** | **Account Name**         | **Type**     |
|----------|--------------------------|--------------|
| 1000     | Cash                     | Asset        |
| 1100     | Bank Account             | Asset        |
| 1200     | Accounts Receivable      | Asset        |
| 1400     | Inventory                | Asset        |
| 1500     | Accumulated Depreciation | Contra Asset |
| 2100     | Accounts Payable         | Liability    |
| 2300     | Sales Tax Payable        | Liability    |
| 4000     | Sales Revenue            | Revenue      |
| 5200     | Utilities Expense        | Expense      |
| 6100     | Depreciation Expense     | Expense      |

Appendix B: Keyboard Shortcuts

| **Key**    | **Action**                                     |
|------------|------------------------------------------------|
| Tab        | Cycle through flag chips / Accept autocomplete |
| Shift+Tab  | Cycle backwards through flag chips             |
| Enter      | Execute command / Accept selected autocomplete |
| Escape     | Clear input / Exit autocomplete                |
| Up/Down    | Command history / Navigate autocomplete        |
| Ctrl+Space | Force autocomplete popup                       |
| Ctrl+D     | Clear all defaults, use explicit values only   |
