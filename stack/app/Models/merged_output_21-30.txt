
=== File: InvoiceLineItem.php ===
Path: InvoiceLineItem.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class InvoiceLineItem extends Model
{
    use HasFactory, HasUuids;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'acct.invoice_line_items';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'invoice_id',
        'product_id',
        'description',
        'quantity',
        'unit_price',
        'discount_type',
        'discount_value',
        'tax_rate',
        'tax_amount',
        'total',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'quantity' => 'decimal:4',
            'unit_price' => 'decimal:2',
            'discount_value' => 'decimal:2',
            'tax_rate' => 'decimal:4',
            'tax_amount' => 'decimal:2',
            'total' => 'decimal:2',
            'invoice_id' => 'string',
            'product_id' => 'string',
        ];
    }

    /**
     * Get the invoice that owns the line item.
     */
    public function invoice(): BelongsTo
    {
        return $this->belongsTo(Invoice::class);
    }

    /**
     * Get the product for the line item.
     */
    public function product(): BelongsTo
    {
        return $this->belongsTo(Product::class);
    }

    /**
     * Calculate the line item total.
     */
    public function calculateTotal(): void
    {
        $subtotal = $this->quantity * $this->unit_price;

        // Calculate discount
        $discountAmount = 0;
        if ($this->discount_type === 'percentage') {
            $discountAmount = $subtotal * ($this->discount_value / 100);
        } elseif ($this->discount_type === 'fixed') {
            $discountAmount = $this->discount_value;
        }

        $afterDiscount = $subtotal - $discountAmount;

        // Calculate tax
        $taxAmount = $afterDiscount * ($this->tax_rate / 100);

        $this->total = $afterDiscount + $taxAmount;
        $this->tax_amount = $taxAmount;

        $this->save();
    }

    /**
     * Get the discount amount.
     */
    public function getDiscountAmount(): float
    {
        $subtotal = $this->quantity * $this->unit_price;

        if ($this->discount_type === 'percentage') {
            return $subtotal * ($this->discount_value / 100);
        } elseif ($this->discount_type === 'fixed') {
            return $this->discount_value;
        }

        return 0;
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\InvoiceLineItemFactory::new();
    }
}

---- File Content End ----


=== File: InvoiceTemplate.php ===
Path: InvoiceTemplate.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\SoftDeletes;

class InvoiceTemplate extends Model
{
    use HasFactory, HasUuids, SoftDeletes;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'acct.invoice_templates';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'company_id',
        'name',
        'description',
        'customer_id',
        'currency',
        'template_data',
        'settings',
        'is_active',
        'created_by_user_id',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'template_data' => 'array',
            'settings' => 'array',
            'is_active' => 'boolean',
            'company_id' => 'string',
            'customer_id' => 'string',
            'created_by_user_id' => 'string',
        ];
    }

    /**
     * Get the company that owns the template.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    /**
     * Get the customer associated with the template.
     */
    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    /**
     * Get the user who created the template.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by_user_id');
    }

    /**
     * Scope a query to only include active templates.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include templates for a specific company.
     */
    public function scopeForCompany($query, string $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope a query to only include templates for a specific customer.
     */
    public function scopeForCustomer($query, ?string $customerId)
    {
        if ($customerId) {
            return $query->where('customer_id', $customerId);
        }

        return $query->whereNull('customer_id');
    }

    /**
     * Apply template to create a new invoice.
     */
    public function applyToInvoice(?Customer $customer = null, array $overrides = []): array
    {
        $templateData = $this->template_data;

        // Build invoice data from template
        $invoiceData = [
            'company_id' => $this->company_id,
            'customer_id' => $customer?->id ?? $this->customer_id,
            'currency' => $overrides['currency'] ?? $this->currency,
            'notes' => $overrides['notes'] ?? $templateData['notes'] ?? null,
            'terms' => $overrides['terms'] ?? $templateData['terms'] ?? null,
            'issue_date' => $overrides['issue_date'] ?? now()->format('Y-m-d'),
            'due_date' => $overrides['due_date'] ?? now()->addDays($templateData['payment_terms'] ?? 30)->format('Y-m-d'),
            'line_items' => $this->processLineItems($templateData['line_items'] ?? [], $overrides),
        ];

        // Apply any field-level overrides
        return array_merge($invoiceData, array_intersect_key($overrides, $invoiceData));
    }

    /**
     * Process line items for template application.
     */
    protected function processLineItems(array $templateItems, array $overrides): array
    {
        $processedItems = [];

        foreach ($templateItems as $item) {
            $processedItem = [
                'description' => $item['description'],
                'quantity' => $item['quantity'],
                'unit_price' => $item['unit_price'],
                'tax_rate' => $item['tax_rate'] ?? 0,
                'discount_amount' => $item['discount_amount'] ?? 0,
            ];

            // Apply item-level overrides if they exist
            if (isset($overrides['line_items_overrides'][$item['id']])) {
                $itemOverrides = $overrides['line_items_overrides'][$item['id']];
                $processedItem = array_merge($processedItem, $itemOverrides);
            }

            $processedItems[] = $processedItem;
        }

        // Add any additional line items from overrides
        if (isset($overrides['additional_line_items'])) {
            $processedItems = array_merge($processedItems, $overrides['additional_line_items']);
        }

        return $processedItems;
    }

    /**
     * Validate template structure and data.
     */
    public function validateTemplate(): array
    {
        $errors = [];

        // Check required fields
        if (empty($this->name)) {
            $errors[] = 'Template name is required';
        }

        if (empty($this->company_id)) {
            $errors[] = 'Company is required';
        }

        if (empty($this->currency)) {
            $errors[] = 'Currency is required';
        }

        // Validate template data structure
        $templateData = $this->template_data ?? [];

        if (empty($templateData['line_items'])) {
            $errors[] = 'Template must have at least one line item';
        } else {
            foreach ($templateData['line_items'] as $index => $item) {
                if (empty($item['description'])) {
                    $errors[] = 'Line item '.($index + 1).' description is required';
                }

                if (! isset($item['quantity']) || $item['quantity'] <= 0) {
                    $errors[] = 'Line item '.($index + 1).' quantity must be greater than 0';
                }

                if (! isset($item['unit_price']) || $item['unit_price'] < 0) {
                    $errors[] = 'Line item '.($index + 1).' unit price cannot be negative';
                }
            }
        }

        return $errors;
    }

    /**
     * Get template summary information.
     */
    public function getSummary(): array
    {
        $templateData = $this->template_data ?? [];
        $lineItems = $templateData['line_items'] ?? [];

        $subtotal = 0;
        $taxAmount = 0;

        foreach ($lineItems as $item) {
            $itemTotal = ($item['quantity'] ?? 0) * ($item['unit_price'] ?? 0);
            $itemTax = $itemTotal * (($item['tax_rate'] ?? 0) / 100);
            $subtotal += $itemTotal;
            $taxAmount += $itemTax;
        }

        return [
            'name' => $this->name,
            'description' => $this->description,
            'currency' => $this->currency,
            'customer_name' => $this->customer?->name,
            'line_items_count' => count($lineItems),
            'subtotal' => $subtotal,
            'tax_amount' => $taxAmount,
            'total_amount' => $subtotal + $taxAmount,
            'is_active' => $this->is_active,
            'created_at' => $this->created_at,
            'updated_at' => $this->updated_at,
        ];
    }

    /**
     * Duplicate template with optional modifications.
     */
    public function duplicate(string $newName, array $modifications = []): self
    {
        $duplicate = $this->replicate();
        $duplicate->name = $newName;
        $duplicate->created_by_user_id = auth()->id();

        // Apply modifications
        if (! empty($modifications)) {
            $templateData = $duplicate->template_data ?? [];

            if (isset($modifications['description'])) {
                $duplicate->description = $modifications['description'];
            }

            if (isset($modifications['customer_id'])) {
                $duplicate->customer_id = $modifications['customer_id'];
            }

            if (isset($modifications['currency'])) {
                $duplicate->currency = $modifications['currency'];
            }

            if (isset($modifications['notes'])) {
                $templateData['notes'] = $modifications['notes'];
            }

            if (isset($modifications['terms'])) {
                $templateData['terms'] = $modifications['terms'];
            }

            if (isset($modifications['payment_terms'])) {
                $templateData['payment_terms'] = $modifications['payment_terms'];
            }

            if (isset($modifications['line_items'])) {
                $templateData['line_items'] = $modifications['line_items'];
            }

            $duplicate->template_data = $templateData;
        }

        $duplicate->save();

        return $duplicate;
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\Invoicing\InvoiceTemplateFactory::new();
    }
}

---- File Content End ----


=== File: JournalAudit.php ===
Path: JournalAudit.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class JournalAudit extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_audit_log';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * Indicates if the model should timestamp.
     */
    public $timestamps = false;

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'journal_entry_id',
        'event_type',
        'actor_id',
        'payload',
        'created_at',
    ];

    /**
     * The attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'payload' => 'array',
            'created_at' => 'datetime',
        ];
    }

    /**
     * Get the journal entry that owns the audit record.
     */
    public function journalEntry(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class, 'journal_entry_id');
    }

    /**
     * Get the user who performed the action (if applicable).
     */
    public function actor(): BelongsTo
    {
        return $this->belongsTo(User::class, 'actor_id');
    }

    /**
     * Scope to get audit records for a specific journal entry.
     */
    public function scopeForJournalEntry($query, string $journalEntryId)
    {
        return $query->where('journal_entry_id', $journalEntryId);
    }

    /**
     * Scope to get audit records by event type.
     */
    public function scopeByEventType($query, string $eventType)
    {
        return $query->where('event_type', $eventType);
    }

    /**
     * Scope to get audit records by actor.
     */
    public function scopeByActor($query, string $actorId)
    {
        return $query->where('actor_id', $actorId);
    }

    /**
     * Scope to get audit records in a date range.
     */
    public function scopeInDateRange($query, $startDate, $endDate)
    {
        return $query->whereBetween('created_at', [$startDate, $endDate]);
    }

    /**
     * Scope to get created events.
     */
    public function scopeCreated($query)
    {
        return $query->where('event_type', 'created');
    }

    /**
     * Scope to get updated events.
     */
    public function scopeUpdated($query)
    {
        return $query->where('event_type', 'updated');
    }

    /**
     * Scope to get posted events.
     */
    public function scopePosted($query)
    {
        return $query->where('event_type', 'posted');
    }

    /**
     * Scope to get voided events.
     */
    public function scopeVoided($query)
    {
        return $query->where('event_type', 'voided');
    }

    /**
     * Scope to get approved events.
     */
    public function scopeApproved($query)
    {
        return $query->where('event_type', 'approved');
    }

    /**
     * Scope to get reversed events.
     */
    public function scopeReversed($query)
    {
        return $query->where('event_type', 'reversed');
    }

    /**
     * Scope to get attachment events.
     */
    public function scopeAttachmentAdded($query)
    {
        return $query->where('event_type', 'attachment_added');
    }

    /**
     * Scope to get system events (no actor).
     */
    public function scopeSystem($query)
    {
        return $query->whereNull('actor_id');
    }

    /**
     * Scope to get user events (has actor).
     */
    public function scopeByUser($query)
    {
        return $query->whereNotNull('actor_id');
    }

    /**
     * Check if this is a created event.
     */
    public function isCreated(): bool
    {
        return $this->event_type === 'created';
    }

    /**
     * Check if this is an updated event.
     */
    public function isUpdated(): bool
    {
        return $this->event_type === 'updated';
    }

    /**
     * Check if this is a posted event.
     */
    public function isPosted(): bool
    {
        return $this->event_type === 'posted';
    }

    /**
     * Check if this is a voided event.
     */
    public function isVoided(): bool
    {
        return $this->event_type === 'voided';
    }

    /**
     * Check if this is an approved event.
     */
    public function isApproved(): bool
    {
        return $this->event_type === 'approved';
    }

    /**
     * Check if this is a reversed event.
     */
    public function isReversed(): bool
    {
        return $this->event_type === 'reversed';
    }

    /**
     * Check if this is an attachment added event.
     */
    public function isAttachmentAdded(): bool
    {
        return $this->event_type === 'attachment_added';
    }

    /**
     * Check if this was performed by a system process.
     */
    public function isSystemAction(): bool
    {
        return is_null($this->actor_id);
    }

    /**
     * Check if this was performed by a user.
     */
    public function isUserAction(): bool
    {
        return ! is_null($this->actor_id);
    }

    /**
     * Get the event type label.
     */
    public function getEventTypeLabelAttribute(): string
    {
        $labels = [
            'created' => 'Created',
            'updated' => 'Updated',
            'posted' => 'Posted',
            'voided' => 'Voided',
            'approved' => 'Approved',
            'reversed' => 'Reversed',
            'attachment_added' => 'Attachment Added',
        ];

        return $labels[$this->event_type] ?? $this->event_type;
    }

    /**
     * Get a human-readable description of the event.
     */
    public function getDescriptionAttribute(): string
    {
        $actorName = $this->actor ? $this->actor->name : 'System';

        return "{$this->event_type_label} by {$actorName}";
    }

    /**
     * Create a new audit record.
     */
    public static function createEvent(
        string $journalEntryId,
        string $eventType,
        array $payload = [],
        ?string $actorId = null
    ): self {
        return static::create([
            'journal_entry_id' => $journalEntryId,
            'event_type' => $eventType,
            'actor_id' => $actorId,
            'payload' => $payload,
            'created_at' => now(),
        ]);
    }

    /**
     * Create a system-generated audit record.
     */
    public static function createSystemEvent(
        string $journalEntryId,
        string $eventType,
        array $payload = []
    ): self {
        return static::createEvent($journalEntryId, $eventType, $payload);
    }

    /**
     * Create a user-generated audit record.
     */
    public static function createUserEvent(
        string $journalEntryId,
        string $eventType,
        string $actorId,
        array $payload = []
    ): self {
        return static::createEvent($journalEntryId, $eventType, $payload, $actorId);
    }

    /**
     * Get the previous state from the payload.
     */
    public function getPreviousStateAttribute(): ?array
    {
        return $this->payload['previous_state'] ?? null;
    }

    /**
     * Get the new state from the payload.
     */
    public function getNewStateAttribute(): ?array
    {
        return $this->payload['new_state'] ?? null;
    }

    /**
     * Get the changes from the payload.
     */
    public function getChangesAttribute(): ?array
    {
        return $this->payload['changes'] ?? null;
    }

    /**
     * Get any metadata from the payload.
     */
    public function getMetadataAttribute(): ?array
    {
        return $this->payload['metadata'] ?? null;
    }
}

---- File Content End ----


=== File: JournalBatch.php ===
Path: JournalBatch.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class JournalBatch extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_batches';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'company_id',
        'batch_number',
        'status',
        'scheduled_post_at',
        'total_entries',
        'total_debits',
        'total_credits',
        'created_by',
        'approved_by',
        'approved_at',
        'posted_by',
        'posted_at',
        'voided_by',
        'voided_at',
        'void_reason',
        'attachments',
        'metadata',
    ];

    /**
     * The attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'scheduled_post_at' => 'datetime',
            'approved_at' => 'datetime',
            'posted_at' => 'datetime',
            'voided_at' => 'datetime',
            'total_entries' => 'integer',
            'total_debits' => 'decimal:2',
            'total_credits' => 'decimal:2',
            'attachments' => 'array',
            'metadata' => 'array',
        ];
    }

    /**
     * The attributes that should be hidden for arrays.
     */
    protected $hidden = [
        'metadata',
    ];

    /**
     * Get the company that owns the batch.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class, 'company_id');
    }

    /**
     * Get the user who created the batch.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    /**
     * Get the user who approved the batch.
     */
    public function approver(): BelongsTo
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    /**
     * Get the user who posted the batch.
     */
    public function poster(): BelongsTo
    {
        return $this->belongsTo(User::class, 'posted_by');
    }

    /**
     * Get the user who voided the batch.
     */
    public function voider(): BelongsTo
    {
        return $this->belongsTo(User::class, 'voided_by');
    }

    /**
     * Get the journal entries in this batch.
     */
    public function journalEntries(): HasMany
    {
        return $this->hasMany(JournalEntry::class, 'batch_id');
    }

    /**
     * Scope to get batches for a specific company.
     */
    public function scopeForCompany($query, string $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope to get batches by status.
     */
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Scope to get draft batches.
     */
    public function scopeDraft($query)
    {
        return $query->where('status', 'draft');
    }

    /**
     * Scope to get ready batches.
     */
    public function scopeReady($query)
    {
        return $query->where('status', 'ready');
    }

    /**
     * Scope to get scheduled batches.
     */
    public function scopeScheduled($query)
    {
        return $query->where('status', 'scheduled')
            ->whereNotNull('scheduled_post_at');
    }

    /**
     * Scope to get posted batches.
     */
    public function scopePosted($query)
    {
        return $query->where('status', 'posted');
    }

    /**
     * Scope to get void batches.
     */
    public function scopeVoid($query)
    {
        return $query->where('status', 'void');
    }

    /**
     * Check if batch is in draft status.
     */
    public function isDraft(): bool
    {
        return $this->status === 'draft';
    }

    /**
     * Check if batch is ready for approval.
     */
    public function isReady(): bool
    {
        return $this->status === 'ready';
    }

    /**
     * Check if batch is scheduled for posting.
     */
    public function isScheduled(): bool
    {
        return $this->status === 'scheduled';
    }

    /**
     * Check if batch is posted.
     */
    public function isPosted(): bool
    {
        return $this->status === 'posted';
    }

    /**
     * Check if batch is void.
     */
    public function isVoid(): bool
    {
        return $this->status === 'void';
    }

    /**
     * Check if batch can be submitted for approval.
     */
    public function canBeSubmitted(): bool
    {
        return $this->isDraft() &&
               $this->journalEntries->count() > 0 &&
               $this->isBalanced();
    }

    /**
     * Check if batch can be approved.
     */
    public function canBeApproved(): bool
    {
        return $this->isReady() && $this->isBalanced();
    }

    /**
     * Check if batch can be posted.
     */
    public function canBePosted(): bool
    {
        return $this->isReady() && $this->isBalanced();
    }

    /**
     * Check if batch is balanced (total debits = total credits).
     */
    public function isBalanced(): bool
    {
        return abs($this->total_debits - $this->total_credits) < 0.01;
    }

    /**
     * Check if batch is scheduled for future posting.
     */
    public function isScheduledForFuture(): bool
    {
        return $this->scheduled_post_at && $this->scheduled_post_at->isFuture();
    }

    /**
     * Check if batch can be scheduled (is ready and has future date).
     */
    public function canBeScheduled(): bool
    {
        return $this->isReady() && $this->isBalanced();
    }

    /**
     * Get the status label.
     */
    public function getStatusLabelAttribute(): string
    {
        $labels = [
            'draft' => 'Draft',
            'ready' => 'Ready',
            'scheduled' => 'Scheduled',
            'posted' => 'Posted',
            'void' => 'Void',
        ];

        return $labels[$this->status] ?? $this->status;
    }

    /**
     * Calculate and update totals based on journal entries.
     */
    public function recalculateTotals(): void
    {
        $totals = $this->journalEntries()
            ->selectRaw('COUNT(*) as total_entries')
            ->selectRaw('SUM(total_debits) as total_debits')
            ->selectRaw('SUM(total_credits) as total_credits')
            ->first();

        $this->update([
            'total_entries' => $totals->total_entries ?? 0,
            'total_debits' => $totals->total_debits ?? 0,
            'total_credits' => $totals->total_credits ?? 0,
        ]);
    }

    /**
     * Add journal entries to this batch.
     */
    public function addJournalEntries(array $entryIds): bool
    {
        foreach ($entryIds as $entryId) {
            $entry = JournalEntry::find($entryId);
            if ($entry && $entry->company_id === $this->company_id) {
                $entry->update(['batch_id' => $this->id]);
            }
        }

        $this->recalculateTotals();

        return true;
    }

    /**
     * Remove journal entries from this batch.
     */
    public function removeJournalEntries(array $entryIds): bool
    {
        JournalEntry::whereIn('id', $entryIds)
            ->where('batch_id', $this->id)
            ->update(['batch_id' => null]);

        $this->recalculateTotals();

        return true;
    }
}

---- File Content End ----


=== File: JournalEntry.php ===
Path: JournalEntry.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class JournalEntry extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_entries';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'company_id',
        'batch_id',
        'template_id',
        'reference',
        'description',
        'date',
        'type',
        'status',
        'approval_note',
        'created_by',
        'approved_by',
        'approved_at',
        'posted_by',
        'posted_at',
        'voided_by',
        'voided_at',
        'void_reason',
        'currency',
        'exchange_rate',
        'fiscal_year_id',
        'accounting_period_id',
        'source_document_type',
        'source_document_id',
        'origin_command',
        'auto_generated',
        'reverse_of_entry_id',
        'reversal_entry_id',
        'attachments',
        'metadata',
    ];

    /**
     * The attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'date' => 'date',
            'approved_at' => 'datetime',
            'posted_at' => 'datetime',
            'voided_at' => 'datetime',
            'exchange_rate' => 'decimal:8',
            'auto_generated' => 'boolean',
            'attachments' => 'array',
            'metadata' => 'array',
        ];
    }

    /**
     * The attributes that should be hidden for arrays.
     */
    protected $hidden = [
        'metadata',
    ];

    /**
     * Get the company that owns the journal entry.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class, 'company_id');
    }

    /**
     * Get the batch that contains the journal entry.
     */
    public function batch(): BelongsTo
    {
        return $this->belongsTo(JournalBatch::class, 'batch_id');
    }

    /**
     * Get the recurring template that generated this entry.
     */
    public function template(): BelongsTo
    {
        return $this->belongsTo(RecurringJournalTemplate::class, 'template_id');
    }

    /**
     * Get the user who created the journal entry.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by');
    }

    /**
     * Get the user who approved the journal entry.
     */
    public function approver(): BelongsTo
    {
        return $this->belongsTo(User::class, 'approved_by');
    }

    /**
     * Get the user who posted the journal entry.
     */
    public function poster(): BelongsTo
    {
        return $this->belongsTo(User::class, 'posted_by');
    }

    /**
     * Get the user who voided the journal entry.
     */
    public function voider(): BelongsTo
    {
        return $this->belongsTo(User::class, 'voided_by');
    }

    /**
     * Get the fiscal year for this entry.
     */
    public function fiscalYear(): BelongsTo
    {
        return $this->belongsTo(FiscalYear::class, 'fiscal_year_id');
    }

    /**
     * Get the accounting period for this entry.
     */
    public function accountingPeriod(): BelongsTo
    {
        return $this->belongsTo(AccountingPeriod::class, 'accounting_period_id');
    }

    /**
     * Get the journal entry that this entry reverses.
     */
    public function reverseOf(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class, 'reverse_of_entry_id');
    }

    /**
     * Get the journal entry that reverses this entry.
     */
    public function reversal(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class, 'reversal_entry_id');
    }

    /**
     * Get the transactions for this journal entry.
     */
    public function transactions(): HasMany
    {
        return $this->hasMany(JournalTransaction::class, 'journal_entry_id')
            ->orderBy('line_number');
    }

    /**
     * Get the sources for this journal entry.
     */
    public function sources(): HasMany
    {
        return $this->hasMany(JournalEntrySource::class, 'journal_entry_id');
    }

    /**
     * Get the audit log entries for this journal entry.
     */
    public function auditLog(): HasMany
    {
        return $this->hasMany(JournalAudit::class, 'journal_entry_id')
            ->orderBy('created_at');
    }

    /**
     * Scope to get entries for a specific company.
     */
    public function scopeForCompany($query, string $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope to get entries by status.
     */
    public function scopeByStatus($query, string $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Scope to get entries by type.
     */
    public function scopeByType($query, string $type)
    {
        return $query->where('type', $type);
    }

    /**
     * Scope to get entries in a date range.
     */
    public function scopeInDateRange($query, $startDate, $endDate)
    {
        return $query->whereBetween('date', [$startDate, $endDate]);
    }

    /**
     * Scope to get entries for a specific period.
     */
    public function scopeForPeriod($query, string $periodId)
    {
        return $query->where('accounting_period_id', $periodId);
    }

    /**
     * Scope to get manual entries (not auto-generated).
     */
    public function scopeManual($query)
    {
        return $query->where('auto_generated', false);
    }

    /**
     * Scope to get automatic entries.
     */
    public function scopeAutomatic($query)
    {
        return $query->where('auto_generated', true);
    }

    /**
     * Scope to get entries with source documents.
     */
    public function scopeWithSourceDocument($query, string $type, string $id)
    {
        return $query->where('source_document_type', $type)
            ->where('source_document_id', $id);
    }

    /**
     * Check if entry is in draft status.
     */
    public function isDraft(): bool
    {
        return $this->status === 'draft';
    }

    /**
     * Check if entry is pending approval.
     */
    public function isPendingApproval(): bool
    {
        return $this->status === 'pending_approval';
    }

    /**
     * Check if entry is approved.
     */
    public function isApproved(): bool
    {
        return $this->status === 'approved';
    }

    /**
     * Check if entry is posted.
     */
    public function isPosted(): bool
    {
        return $this->status === 'posted';
    }

    /**
     * Check if entry is void.
     */
    public function isVoid(): bool
    {
        return $this->status === 'void';
    }

    /**
     * Check if entry can be submitted for approval.
     */
    public function canBeSubmitted(): bool
    {
        return $this->isDraft() && $this->transactions->count() > 0;
    }

    /**
     * Check if entry can be approved.
     */
    public function canBeApproved(): bool
    {
        return $this->isPendingApproval() && $this->isBalanced();
    }

    /**
     * Check if entry can be posted.
     */
    public function canBePosted(): bool
    {
        return $this->isApproved() && $this->isBalanced();
    }

    /**
     * Check if entry is balanced (debits = credits).
     */
    public function isBalanced(): bool
    {
        $totals = $this->transactions()
            ->selectRaw('SUM(CASE WHEN debit_credit = \'debit\' THEN amount ELSE 0 END) as total_debits')
            ->selectRaw('SUM(CASE WHEN debit_credit = \'credit\' THEN amount ELSE 0 END) as total_credits')
            ->first();

        return abs($totals->total_debits - $totals->total_credits) < 0.01;
    }

    /**
     * Get the total debits for this entry.
     */
    public function getTotalDebitsAttribute(): float
    {
        return $this->transactions()
            ->where('debit_credit', 'debit')
            ->sum('amount');
    }

    /**
     * Get the total credits for this entry.
     */
    public function getTotalCreditsAttribute(): float
    {
        return $this->transactions()
            ->where('debit_credit', 'credit')
            ->sum('amount');
    }

    /**
     * Get the status label.
     */
    public function getStatusLabelAttribute(): string
    {
        $labels = [
            'draft' => 'Draft',
            'pending_approval' => 'Pending Approval',
            'approved' => 'Approved',
            'posted' => 'Posted',
            'void' => 'Void',
        ];

        return $labels[$this->status] ?? $this->status;
    }

    /**
     * Get the type label.
     */
    public function getTypeLabelAttribute(): string
    {
        $labels = [
            'sales' => 'Sales',
            'purchase' => 'Purchase',
            'payment' => 'Payment',
            'receipt' => 'Receipt',
            'adjustment' => 'Adjustment',
            'closing' => 'Closing',
            'opening' => 'Opening',
            'reversal' => 'Reversal',
            'automation' => 'Automation',
        ];

        return $labels[$this->type] ?? $this->type;
    }
}

---- File Content End ----


=== File: JournalEntrySource.php ===
Path: JournalEntrySource.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class JournalEntrySource extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_entry_sources';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * Indicates if the model should timestamp.
     */
    public $timestamps = false;

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'journal_entry_id',
        'journal_transaction_id',
        'source_type',
        'source_id',
        'source_reference',
        'link_type',
        'created_at',
    ];

    /**
     * The attributes that should be cast.
     */
    protected function casts(): array
    {
        return [
            'created_at' => 'datetime',
        ];
    }

    /**
     * Get the journal entry that owns the source.
     */
    public function journalEntry(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class, 'journal_entry_id');
    }

    /**
     * Get the journal transaction that owns the source (if applicable).
     */
    public function journalTransaction(): BelongsTo
    {
        return $this->belongsTo(JournalTransaction::class, 'journal_transaction_id');
    }

    /**
     * Scope to get sources for a specific journal entry.
     */
    public function scopeForJournalEntry($query, string $journalEntryId)
    {
        return $query->where('journal_entry_id', $journalEntryId);
    }

    /**
     * Scope to get sources for a specific transaction.
     */
    public function scopeForTransaction($query, string $transactionId)
    {
        return $query->where('journal_transaction_id', $transactionId);
    }

    /**
     * Scope to get sources by source type.
     */
    public function scopeBySourceType($query, string $sourceType)
    {
        return $query->where('source_type', $sourceType);
    }

    /**
     * Scope to get sources by source ID.
     */
    public function scopeBySourceId($query, string $sourceId)
    {
        return $query->where('source_id', $sourceId);
    }

    /**
     * Scope to get sources by link type.
     */
    public function scopeByLinkType($query, string $linkType)
    {
        return $query->where('link_type', $linkType);
    }

    /**
     * Scope to get origin sources.
     */
    public function scopeOrigin($query)
    {
        return $query->where('link_type', 'origin');
    }

    /**
     * Scope to get supporting sources.
     */
    public function scopeSupporting($query)
    {
        return $query->where('link_type', 'supporting');
    }

    /**
     * Scope to get reversal sources.
     */
    public function scopeReversal($query)
    {
        return $query->where('link_type', 'reversal');
    }

    /**
     * Scope to search by source reference.
     */
    public function scopeByReference($query, string $reference)
    {
        return $query->where('source_reference', 'like', "%{$reference}%");
    }

    /**
     * Check if this is an origin source.
     */
    public function isOrigin(): bool
    {
        return $this->link_type === 'origin';
    }

    /**
     * Check if this is a supporting source.
     */
    public function isSupporting(): bool
    {
        return $this->link_type === 'supporting';
    }

    /**
     * Check if this is a reversal source.
     */
    public function isReversal(): bool
    {
        return $this->link_type === 'reversal';
    }

    /**
     * Check if this source is linked to a specific transaction.
     */
    public function isLinkedToTransaction(): bool
    {
        return ! is_null($this->journal_transaction_id);
    }

    /**
     * Get the link type label.
     */
    public function getLinkTypeLabelAttribute(): string
    {
        $labels = [
            'origin' => 'Origin',
            'supporting' => 'Supporting',
            'reversal' => 'Reversal',
        ];

        return $labels[$this->link_type] ?? $this->link_type;
    }

    /**
     * Get the source type label.
     */
    public function getSourceTypeLabelAttribute(): string
    {
        $labels = [
            'Invoice' => 'Invoice',
            'Payment' => 'Payment',
            'Bill' => 'Bill',
            'PaymentAllocation' => 'Payment Allocation',
            'JournalEntry' => 'Journal Entry',
            'Manual' => 'Manual Entry',
            'RecurringTemplate' => 'Recurring Template',
        ];

        return $labels[$this->source_type] ?? $this->source_type;
    }

    /**
     * Create a new source record.
     */
    public static function createSource(
        string $journalEntryId,
        string $sourceType,
        string $sourceId,
        string $linkType = 'origin',
        ?string $journalTransactionId = null,
        ?string $sourceReference = null
    ): self {
        return static::create([
            'journal_entry_id' => $journalEntryId,
            'journal_transaction_id' => $journalTransactionId,
            'source_type' => $sourceType,
            'source_id' => $sourceId,
            'source_reference' => $sourceReference,
            'link_type' => $linkType,
            'created_at' => now(),
        ]);
    }

    /**
     * Get a readable description of the source.
     */
    public function getDescriptionAttribute(): string
    {
        $reference = $this->source_reference ?: $this->source_id;

        return "{$this->source_type}: {$reference} ({$this->link_type_label})";
    }
}

---- File Content End ----


=== File: JournalTransaction.php ===
Path: JournalTransaction.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class JournalTransaction extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'acct.journal_transactions';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'id';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'journal_entry_id',
        'line_number',
        'account_id',
        'account_code',
        'account_name',
        'debit_credit',
        'amount',
        'description',
        'reconcile_id',
        'tax_code_id',
        'tax_amount',
        'currency',
        'exchange_rate',
        'metadata',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'amount' => 'decimal:2',
            'tax_amount' => 'decimal:2',
            'exchange_rate' => 'decimal:8',
            'line_number' => 'integer',
            'metadata' => 'array',
        ];
    }

    /**
     * Get the journal entry that owns the transaction.
     */
    public function journalEntry(): BelongsTo
    {
        return $this->belongsTo(JournalEntry::class);
    }

    /**
     * Get the account for the transaction.
     */
    public function account(): BelongsTo
    {
        return $this->belongsTo(Account::class, 'account_id');
    }

    /**
     * Get the sources for this transaction.
     */
    public function sources(): HasMany
    {
        return $this->hasMany(JournalEntrySource::class, 'journal_transaction_id');
    }

    /**
     * Scope to get transactions for a specific journal entry.
     */
    public function scopeForJournalEntry($query, string $journalEntryId)
    {
        return $query->where('journal_entry_id', $journalEntryId);
    }

    /**
     * Scope to get transactions by account.
     */
    public function scopeForAccount($query, string $accountId)
    {
        return $query->where('account_id', $accountId);
    }

    /**
     * Scope a query to only include debit transactions.
     */
    public function scopeDebits($query)
    {
        return $query->where('debit_credit', 'debit');
    }

    /**
     * Scope a query to only include credit transactions.
     */
    public function scopeCredits($query)
    {
        return $query->where('debit_credit', 'credit');
    }

    /**
     * Check if this is a debit transaction.
     */
    public function isDebit(): bool
    {
        return $this->debit_credit === 'debit';
    }

    /**
     * Check if this is a credit transaction.
     */
    public function isCredit(): bool
    {
        return $this->debit_credit === 'credit';
    }

    /**
     * Get the amount (same for debit/credit).
     */
    public function getAmount(): float
    {
        return $this->amount;
    }

    /**
     * Get the signed amount (positive for debits, negative for credits for asset accounts).
     */
    public function getSignedAmount(): float
    {
        if ($this->account && $this->account->normal_balance === 'debit') {
            return $this->isDebit() ? $this->amount : -$this->amount;
        } else {
            return $this->isCredit() ? $this->amount : -$this->amount;
        }
    }
}

---- File Content End ----


=== File: Module.php ===
Path: Module.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Module extends Model
{
    use HasFactory, HasUuids;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'auth.modules';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'key',
        'name',
        'display_name',
        'description',
        'version',
        'category',
        'icon',
        'is_core',
        'is_active',
        'dependencies',
        'permissions',
        'settings_schema',
        'migration_path',
        'route_path',
        'provider_class',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'is_core' => 'boolean',
            'is_active' => 'boolean',
            'dependencies' => 'array',
            'permissions' => 'array',
            'settings_schema' => 'array',
        ];
    }

    /**
     * Get the companies that have this module enabled.
     */
    public function companies(): BelongsToMany
    {
        return $this->belongsToMany(Company::class, 'auth.company_modules')
            ->withPivot('is_active', 'enabled_at', 'enabled_by_user_id', 'disabled_at', 'disabled_by_user_id', 'settings')
            ->withTimestamps();
    }

    public function isActive(): bool
    {
        return (bool) $this->is_active;
    }

    public function getSettingSchema(): array
    {
        return $this->settings_schema ?? [];
    }

    /**
     * Get the company module pivots.
     */
    public function companyModules(): HasMany
    {
        return $this->hasMany(CompanyModule::class);
    }

    public function getEnabledCompaniesCount(): int
    {
        return $this->companyModules()
            ->where('is_active', true)
            ->count();
    }

    public function isEnabledForCompany(string $companyId): bool
    {
        return $this->companyModules()
            ->where('company_id', $companyId)
            ->where('is_active', true)
            ->exists();
    }

    /**
     * Scope a query to only include active modules.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope a query to only include core modules.
     */
    public function scopeCore($query)
    {
        return $query->where('is_core', true);
    }

    /**
     * Scope a query to only include modules in a specific category.
     */
    public function scopeInCategory($query, string $category)
    {
        return $query->where('category', $category);
    }

    /**
     * Check if the module is a core module.
     */
    public function isCoreModule(): bool
    {
        return $this->is_core;
    }

    /**
     * Check if the module has a specific dependency.
     */
    public function hasDependency(string $dependency): bool
    {
        return in_array($dependency, $this->dependencies ?? []);
    }

    /**
     * Get all dependencies for this module.
     */
    public function getDependencies(): array
    {
        return $this->dependencies ?? [];
    }

    /**
     * Check if the module requires specific permissions.
     */
    public function requiresPermission(string $permission): bool
    {
        return in_array($permission, $this->permissions ?? []);
    }

    /**
     * Get the provider class for the module.
     */
    public function getProviderClass(): ?string
    {
        return $this->provider_class;
    }

    /**
     * Check if the module is registered in the application.
     */
    public function isRegistered(): bool
    {
        return config("modules.{$this->name}") !== null;
    }

    /**
     * Get the module's configuration.
     */
    public function getConfig(): array
    {
        return config("modules.{$this->name}", []);
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\ModuleFactory::new();
    }
}

---- File Content End ----


=== File: Payment.php ===
Path: Payment.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Support\Str;

class Payment extends Model
{
    use HasFactory, SoftDeletes;

    protected $table = 'acct.payments';

    protected $primaryKey = 'id';

    protected $keyType = 'string';

    public $incrementing = false;

    protected $fillable = [
        'id',
        'company_id',
        'customer_id',
        'payment_number',
        'payment_date',
        'payment_method',
        'reference_number',
        'amount',
        'currency',
        'status',
        'notes',
        'batch_id',
        'created_by_user_id',
        'reconciled',
        'reconciled_date',
    ];

    protected $casts = [
        'amount' => 'decimal:2',
        'payment_date' => 'date',
        'reconciled' => 'boolean',
        'reconciled_date' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    protected $hidden = [
        'deleted_at',
    ];

    protected $dates = [
        'payment_date',
        'reconciled_date',
        'created_at',
        'updated_at',
        'deleted_at',
    ];

    // Constants for status
    const STATUS_PENDING = 'pending';
    const STATUS_COMPLETED = 'completed';
    const STATUS_FAILED = 'failed';
    const STATUS_CANCELLED = 'cancelled';
    const STATUS_REVERSED = 'reversed';

    // Constants for payment methods
    const METHOD_CASH = 'cash';
    const METHOD_BANK_TRANSFER = 'bank_transfer';
    const METHOD_CARD = 'card';
    const METHOD_CHEQUE = 'cheque';
    const METHOD_OTHER = 'other';

    /**
     * Get the allocations for this payment.
     */
    public function allocations(): HasMany
    {
        return $this->hasMany(PaymentAllocation::class, 'payment_id')
                    ->whereNull('reversed_at');
    }

    /**
     * Get all allocations including reversed ones.
     */
    public function allAllocations(): HasMany
    {
        return $this->hasMany(PaymentAllocation::class, 'payment_id');
    }

    /**
     * Get the company that owns this payment.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class, 'company_id');
    }

    /**
     * Get the customer that made this payment.
     */
    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class, 'customer_id');
    }

    /**
     * Get the user who created this payment.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by_user_id');
    }

    /**
     * Get the batch this payment belongs to.
     */
    public function batch(): BelongsTo
    {
        return $this->belongsTo(PaymentBatch::class, 'batch_id');
    }

    /**
     * Get the reversal record for this payment.
     */
    public function reversal(): HasOne
    {
        return $this->hasOne(PaymentReversal::class, 'payment_id');
    }

    /**
     * Get the total allocated amount.
     */
    public function getTotalAllocatedAttribute(): float
    {
        return $this->allocations()->sum('allocated_amount');
    }

    /**
     * Get the remaining amount.
     */
    public function getRemainingAmountAttribute(): float
    {
        return $this->amount - $this->total_allocated;
    }

    /**
     * Check if the payment is fully allocated.
     */
    public function getIsFullyAllocatedAttribute(): bool
    {
        return $this->remaining_amount <= 0;
    }

    /**
     * Get payment method label.
     */
    public function getPaymentMethodLabelAttribute(): string
    {
        return match($this->payment_method) {
            self::METHOD_CASH => 'Cash',
            self::METHOD_BANK_TRANSFER => 'Bank Transfer',
            self::METHOD_CARD => 'Card',
            self::METHOD_CHEQUE => 'Cheque',
            self::METHOD_OTHER => 'Other',
            default => $this->payment_method,
        };
    }

    /**
     * Get status label.
     */
    public function getStatusLabelAttribute(): string
    {
        return match($this->status) {
            self::STATUS_PENDING => 'Pending',
            self::STATUS_COMPLETED => 'Completed',
            self::STATUS_FAILED => 'Failed',
            self::STATUS_CANCELLED => 'Cancelled',
            self::STATUS_REVERSED => 'Reversed',
            default => $this->status,
        };
    }

    /**
     * Scope payments by company.
     */
    public function scopeForCompany($query, $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope payments by customer.
     */
    public function scopeForCustomer($query, $customerId)
    {
        return $query->where('customer_id', $customerId);
    }

    /**
     * Scope payments by status.
     */
    public function scopeByStatus($query, $status)
    {
        return $query->where('status', $status);
    }

    /**
     * Scope payments by payment method.
     */
    public function scopeByPaymentMethod($query, $method)
    {
        return $query->where('payment_method', $method);
    }

    /**
     * Scope payments by date range.
     */
    public function scopeByDateRange($query, $startDate, $endDate = null)
    {
        $query->where('payment_date', '>=', $startDate);
        
        if ($endDate) {
            $query->where('payment_date', '<=', $endDate);
        }
        
        return $query;
    }

    /**
     * Scope unreconciled payments.
     */
    public function scopeUnreconciled($query)
    {
        return $query->where('reconciled', false);
    }

    /**
     * Scope reconciled payments.
     */
    public function scopeReconciled($query)
    {
        return $query->where('reconciled', true);
    }

    /**
     * Scope payments that can be reversed.
     */
    public function scopeReversible($query)
    {
        return $query->whereIn('status', [self::STATUS_COMPLETED, self::STATUS_FAILED]);
    }

    /**
     * Check if the payment can be reversed.
     */
    public function canBeReversed(): bool
    {
        return in_array($this->status, [self::STATUS_COMPLETED, self::STATUS_FAILED]) &&
               !$this->reversal()->exists();
    }

    /**
     * Check if the payment has been reversed.
     */
    public function isReversed(): bool
    {
        return $this->status === self::STATUS_REVERSED || $this->reversal()->exists();
    }

    /**
     * Get allocation summary.
     */
    public function getAllocationSummaryAttribute(): array
    {
        $allocations = $this->allocations;
        $totalAllocated = $allocations->sum('allocated_amount');
        
        return [
            'total_allocated' => $totalAllocated,
            'remaining_amount' => $this->amount - $totalAllocated,
            'is_fully_allocated' => $totalAllocated >= $this->amount,
            'allocation_count' => $allocations->count(),
        ];
    }

    /**
     * Boot the model.
     */
    protected static function booted()
    {
        static::creating(function ($payment) {
            if (!$payment->id) {
                $payment->id = Str::uuid();
            }
            
            if (!$payment->created_by_user_id) {
                $payment->created_by_user_id = auth()->id();
            }
        });

        static::updating(function ($payment) {
            // Prevent status changes for reversed payments
            if ($payment->isDirty('status') && $payment->getOriginal('status') === self::STATUS_REVERSED) {
                throw new \InvalidArgumentException('Cannot change status of a reversed payment');
            }
        });
    }

    /**
     * The attributes that are mass assignable.
     */
    protected $guarded = [];
}

---- File Content End ----


=== File: PaymentAllocation.php ===
Path: PaymentAllocation.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Support\Str;

class PaymentAllocation extends Model
{
    use HasFactory, SoftDeletes;

    protected $table = 'acct.payment_allocations';

    protected $primaryKey = 'id';

    protected $keyType = 'string';

    public $incrementing = false;

    protected $fillable = [
        'id',
        'company_id',
        'payment_id',
        'invoice_id',
        'allocated_amount',
        'original_amount',
        'discount_amount',
        'discount_percent',
        'allocation_date',
        'allocation_method',
        'allocation_strategy',
        'notes',
        'reversed_at',
        'reversal_reason',
        'reversed_by_user_id',
        'status',
        'created_by_user_id',
    ];

    protected $casts = [
        'allocated_amount' => 'decimal:2',
        'original_amount' => 'decimal:2',
        'discount_amount' => 'decimal:2',
        'discount_percent' => 'decimal:2',
        'allocation_date' => 'date',
        'reversed_at' => 'datetime',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
        'deleted_at' => 'datetime',
    ];

    protected $dates = [
        'allocation_date',
        'reversed_at',
        'created_at',
        'updated_at',
        'deleted_at',
    ];

    // Constants for status
    const STATUS_ACTIVE = 'active';
    const STATUS_REVERSED = 'reversed';

    // Constants for allocation methods
    const METHOD_MANUAL = 'manual';
    const METHOD_AUTOMATIC = 'automatic';

    /**
     * Get the payment for this allocation.
     */
    public function payment(): BelongsTo
    {
        return $this->belongsTo(Payment::class, 'payment_id');
    }

    /**
     * Get the invoice for this allocation.
     */
    public function invoice(): BelongsTo
    {
        return $this->belongsTo(Invoice::class, 'invoice_id');
    }

    /**
     * Get the company that owns this allocation.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class, 'company_id');
    }

    /**
     * Get the user who created this allocation.
     */
    public function creator(): BelongsTo
    {
        return $this->belongsTo(User::class, 'created_by_user_id');
    }

    /**
     * Get the user who reversed this allocation.
     */
    public function reverser(): BelongsTo
    {
        return $this->belongsTo(User::class, 'reversed_by_user_id');
    }

    /**
     * Get allocation method label.
     */
    public function getAllocationMethodLabelAttribute(): string
    {
        return match($this->allocation_method) {
            self::METHOD_MANUAL => 'Manual',
            self::METHOD_AUTOMATIC => 'Automatic',
            default => $this->allocation_method,
        };
    }

    /**
     * Get status label.
     */
    public function getStatusLabelAttribute(): string
    {
        return match($this->status) {
            self::STATUS_ACTIVE => 'Active',
            self::STATUS_REVERSED => 'Reversed',
            default => $this->status,
        };
    }

    /**
     * Scope allocations by company.
     */
    public function scopeForCompany($query, $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    /**
     * Scope allocations by payment.
     */
    public function scopeForPayment($query, $paymentId)
    {
        return $query->where('payment_id', $paymentId);
    }

    /**
     * Scope allocations by invoice.
     */
    public function scopeForInvoice($query, $invoiceId)
    {
        return $query->where('invoice_id', $invoiceId);
    }

    /**
     * Scope active allocations (not reversed).
     */
    public function scopeActive($query)
    {
        return $query->whereNull('reversed_at')->where('status', self::STATUS_ACTIVE);
    }

    /**
     * Scope reversed allocations.
     */
    public function scopeReversed($query)
    {
        return $query->whereNotNull('reversed_at')->orWhere('status', self::STATUS_REVERSED);
    }

    /**
     * Scope allocations by method.
     */
    public function scopeByMethod($query, $method)
    {
        return $query->where('allocation_method', $method);
    }

    /**
     * Scope allocations by date range.
     */
    public function scopeByDateRange($query, $startDate, $endDate = null)
    {
        $query->where('allocation_date', '>=', $startDate);
        
        if ($endDate) {
            $query->where('allocation_date', '<=', $endDate);
        }
        
        return $query;
    }

    /**
     * Check if the allocation is active.
     */
    public function isActive(): bool
    {
        return is_null($this->reversed_at) && $this->status === self::STATUS_ACTIVE;
    }

    /**
     * Check if the allocation has been reversed.
     */
    public function isReversed(): bool
    {
        return !is_null($this->reversed_at) || $this->status === self::STATUS_REVERSED;
    }

    /**
     * Check if the allocation can be reversed.
     */
    public function canBeReversed(): bool
    {
        return $this->isActive();
    }

    /**
     * Reverse the allocation.
     */
    public function reverse(string $reason, ?string $reverserUserId = null): void
    {
        $this->update([
            'reversed_at' => now(),
            'reversal_reason' => $reason,
            'reversed_by_user_id' => $reverserUserId ?? auth()->id(),
            'status' => self::STATUS_REVERSED,
        ]);
    }

    /**
     * Get the effective amount (after discount).
     */
    public function getEffectiveAmountAttribute(): float
    {
        return $this->allocated_amount - ($this->discount_amount ?? 0);
    }

    /**
     * Get the discount percentage as a formatted string.
     */
    public function getDiscountPercentFormattedAttribute(): string
    {
        return number_format($this->discount_percent, 2) . '%';
    }

    /**
     * Boot the model.
     */
    protected static function booted()
    {
        static::creating(function ($allocation) {
            if (!$allocation->id) {
                $allocation->id = Str::uuid();
            }
            
            if (!$allocation->created_by_user_id) {
                $allocation->created_by_user_id = auth()->id();
            }
            
            if (!$allocation->status) {
                $allocation->status = self::STATUS_ACTIVE;
            }
            
            if (!$allocation->allocation_date) {
                $allocation->allocation_date = now();
            }
        });

        static::updating(function ($allocation) {
            // Prevent changes to reversed allocations
            if ($allocation->isReversed() && $allocation->isDirty('allocated_amount')) {
                throw new \InvalidArgumentException('Cannot modify a reversed allocation');
            }
        });
    }

    /**
     * The attributes that are mass assignable.
     */
    protected $guarded = [];
}

---- File Content End ----

