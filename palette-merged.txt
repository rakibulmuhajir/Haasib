===== build/resources/js/palette/autocomplete.ts =====
import { GRAMMAR, ENTITY_ICONS, COMMAND_DESCRIPTIONS } from './grammar'
import type { Suggestion } from '@/types/palette'

/**
 * Generate command suggestions based on partial input
 */
export function generateSuggestions(input: string, maxResults = 8): Suggestion[] {
  if (!input.trim()) return getQuickStartSuggestions()

  const inputLower = input.toLowerCase()
  const suggestions: Suggestion[] = []

  // Generate all possible completions
  const completions = getAllCompletions()

  for (const completion of completions) {
    const score = scoreSuggestion(inputLower, completion.value.toLowerCase())
    if (score > 0) {
      suggestions.push({ ...completion, score })
    }
  }

  // Sort by score (higher = better match), then by length (shorter = simpler)
  return suggestions
    .sort((a, b) => {
      if (b.score !== a.score) return b.score! - a.score!
      return a.value.length - b.value.length
    })
    .slice(0, maxResults)
}

/**
 * Quick start suggestions when input is empty
 */
function getQuickStartSuggestions(): Suggestion[] {
  return [
    {
      type: 'command',
      value: 'company list',
      label: 'company list',
      description: 'View all companies',
      icon: ENTITY_ICONS.company,
    },
    {
      type: 'command',
      value: 'user invite ',
      label: 'user invite',
      description: 'Invite a new user',
      icon: ENTITY_ICONS.user,
    },
    {
      type: 'command',
      value: 'user list',
      label: 'user list',
      description: 'View all users',
      icon: ENTITY_ICONS.user,
    },
    {
      type: 'command',
      value: 'help',
      label: 'help',
      description: 'Show all commands',
      icon: '‚ùì',
    },
  ]
}

/**
 * Score how well input matches a completion
 * Higher score = better match
 */
function scoreSuggestion(input: string, completion: string): number {
  // Exact prefix match - highest score
  if (completion.startsWith(input)) {
    return 100 + (input.length / completion.length) * 50
  }

  // Match after the dot (e.g., "list" matches "company.list")
  const dotIndex = completion.indexOf('.')
  if (dotIndex > 0) {
    const afterDot = completion.substring(dotIndex + 1)
    if (afterDot.startsWith(input)) {
      return 80 + (input.length / afterDot.length) * 30
    }
  }

  // Fuzzy match - each character in order
  let inputIdx = 0
  let score = 0
  for (let i = 0; i < completion.length && inputIdx < input.length; i++) {
    if (completion[i] === input[inputIdx]) {
      // Bonus for consecutive matches
      score += (i === 0 || completion[i - 1] === '.' || completion[i - 1] === ' ') ? 10 : 5
      inputIdx++
    }
  }

  // Only return score if all input chars were found
  return inputIdx === input.length ? score : 0
}

/**
 * Get all possible command completions from grammar
 */
function getAllCompletions(): Suggestion[] {
  const completions: Suggestion[] = []

  for (const [entityName, entity] of Object.entries(GRAMMAR)) {
    // Entity alone
    completions.push({
      type: 'entity',
      value: `${entityName} `,
      label: entityName,
      description: `${entity.verbs.length} commands available`,
      icon: ENTITY_ICONS[entityName] || 'üì¶',
    })

    // Entity verb combinations (canonical only)
    for (const verb of entity.verbs) {
      const commandKey = `${entityName}.${verb.name}`
      const description = COMMAND_DESCRIPTIONS[commandKey] || `${verb.name} ${entityName}`

      // Only suggest canonical verb name, not aliases
      completions.push({
        type: 'command',
        value: `${entityName} ${verb.name} `,
        label: `${entityName} ${verb.name}`,
        description,
        icon: ENTITY_ICONS[entityName] || 'üì¶',
      })
    }
  }

  // Built-in commands
  completions.push({
    type: 'command',
    value: 'help',
    label: 'help',
    description: COMMAND_DESCRIPTIONS['help'] || 'Show help',
    icon: '‚ùì',
  })

  completions.push({
    type: 'command',
    value: 'clear',
    label: 'clear',
    description: COMMAND_DESCRIPTIONS['clear'] || 'Clear output',
    icon: 'üóëÔ∏è',
  })

  return completions
}

/**
 * Get suggestions for flag values (for future use with entity catalogs)
 */
export function getFlagSuggestions(
  entity: string,
  verb: string,
  flag: string,
  partial: string,
  catalog: Record<string, string[]> = {}
): string[] {
  // For now, just return from catalog if available
  const key = `${entity}.${flag}`
  const values = catalog[key] || []

  if (!partial) return values.slice(0, 5)

  const partialLower = partial.toLowerCase()
  return values
    .filter(v => v.toLowerCase().includes(partialLower))
    .slice(0, 5)
}


===== build/resources/js/palette/formatter.ts =====
/**
 * Format text with semantic color tags
 * Supports: {success}, {error}, {warning}, {accent}, {primary}, {secondary}, {link:url}
 */

export function formatText(text: string): string {
  if (!text || typeof text !== 'string') return ''

  let result = escapeHtml(text)

  // Semantic color tags
  result = result.replace(/\{success\}(.*?)\{\/\}/g, '<span class="fmt-success">$1</span>')
  result = result.replace(/\{error\}(.*?)\{\/\}/g, '<span class="fmt-error">$1</span>')
  result = result.replace(/\{warning\}(.*?)\{\/\}/g, '<span class="fmt-warning">$1</span>')
  result = result.replace(/\{accent\}(.*?)\{\/\}/g, '<span class="fmt-accent">$1</span>')
  result = result.replace(/\{primary\}(.*?)\{\/\}/g, '<span class="fmt-primary">$1</span>')
  result = result.replace(/\{secondary\}(.*?)\{\/\}/g, '<span class="fmt-secondary">$1</span>')

  // Text formatting
  result = result.replace(/\{bold\}(.*?)\{\/\}/g, '<strong>$1</strong>')
  result = result.replace(/\{dim\}(.*?)\{\/\}/g, '<span class="fmt-dim">$1</span>')
  result = result.replace(/\{code\}(.*?)\{\/\}/g, '<code class="fmt-code">$1</code>')

  // Links - sanitize URLs
  result = result.replace(/\{link:(.*?)\}(.*?)\{\/\}/g, (match, url, text) => {
    const sanitizedUrl = sanitizeUrl(url)
    return `<a href="${sanitizedUrl}" class="fmt-link" target="_blank" rel="noopener noreferrer">${text}</a>`
  })

  return result
}

/**
 * Basic HTML escape to prevent XSS
 */
function escapeHtml(text: string): string {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

/**
 * Sanitize URL to prevent javascript: and data: URLs
 */
function sanitizeUrl(url: string): string {
  const trimmed = url.trim().toLowerCase()

  // Block dangerous protocols
  if (
    trimmed.startsWith('javascript:') ||
    trimmed.startsWith('data:') ||
    trimmed.startsWith('vbscript:')
  ) {
    return '#'
  }

  // Allow http, https, mailto, relative paths
  if (
    trimmed.startsWith('http://') ||
    trimmed.startsWith('https://') ||
    trimmed.startsWith('mailto:') ||
    trimmed.startsWith('/') ||
    trimmed.startsWith('./')
  ) {
    return url
  }

  // Default to relative path
  return `/${url}`
}

/**
 * Helper to format money
 */
export function formatMoney(amount: number | string, currency = 'USD'): string {
  const num = typeof amount === 'string' ? parseFloat(amount) : amount
  if (isNaN(num)) return String(amount)

  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(num)
}

/**
 * Helper to format date
 */
export function formatDate(date: string | Date): string {
  const d = typeof date === 'string' ? new Date(date) : date
  if (isNaN(d.getTime())) return String(date)

  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  }).format(d)
}


===== build/resources/js/palette/grammar.ts =====
import type { EntityDefinition } from '@/types/palette'

/**
 * Entity icons
 */
export const ENTITY_ICONS: Record<string, string> = {
  company: 'üè¢',
  user: 'üë§',
  role: 'üîë',
}

/**
 * Command descriptions
 */
export const COMMAND_DESCRIPTIONS: Record<string, string> = {
  'company.create': 'Create a new company',
  'company.list': 'Show all companies you have access to',
  'company.view': 'View company details',
  'company.switch': 'Switch to a different company',
  'company.delete': 'Delete a company (cannot be undone)',

  'user.invite': 'Invite a new user to the company',
  'user.list': 'Show all users in the company',
  'user.view': 'View user details',
  'user.assign-role': 'Assign a role to a user',
  'user.remove-role': 'Remove a role from a user',
  'user.deactivate': 'Deactivate a user account',
  'user.activate': 'Activate a deactivated user',
  'user.delete': 'Delete a user (cannot be undone)',

  'role.list': 'Show all available roles',
  'role.view': 'View role details and permissions',
  'role.assign': 'Assign a permission to a role',
  'role.revoke': 'Revoke a permission from a role',

  'help': 'Show available commands',
  'clear': 'Clear output history',
}

/**
 * Command grammar definitions
 *
 * Each entity defines:
 * - name: canonical name
 * - shortcuts: short aliases (e.g., "co" for "company")
 * - defaultVerb: verb used when only entity is specified
 * - verbs: available operations with their flags
 */
export const GRAMMAR: Record<string, EntityDefinition> = {
  company: {
    name: 'company',
    shortcuts: ['co', 'comp'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'create',
        aliases: ['new', 'add'],
        requiresSubject: true,
        flags: [
          { name: 'name', type: 'string', required: true },
          { name: 'currency', type: 'string', required: true },
          { name: 'industry', type: 'string', required: false },
          { name: 'country', type: 'string', required: false },
        ],
      },
      {
        name: 'list',
        aliases: [],
        requiresSubject: false,
        flags: [],
      },
      {
        name: 'view',
        aliases: ['get', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'slug', type: 'string', required: true },
        ],
      },
      {
        name: 'switch',
        aliases: [],
        requiresSubject: true,
        flags: [
          { name: 'slug', type: 'string', required: true },
        ],
      },
      {
        name: 'delete',
        aliases: [],
        requiresSubject: true,
        flags: [
          { name: 'slug', type: 'string', required: true },
        ],
      },
    ],
  },

  user: {
    name: 'user',
    shortcuts: ['u', 'usr'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'invite',
        aliases: [],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
          { name: 'role', type: 'string', required: false, default: 'member' },
          { name: 'name', type: 'string', required: false },
        ],
      },
      {
        name: 'list',
        aliases: [],
        requiresSubject: false,
        flags: [],
      },
      {
        name: 'view',
        aliases: ['get', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
      {
        name: 'assign-role',
        aliases: ['assign', 'grant'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
      {
        name: 'remove-role',
        aliases: ['revoke', 'unassign'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
      {
        name: 'deactivate',
        aliases: ['disable', 'suspend'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
      {
        name: 'activate',
        aliases: ['enable', 'restore'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
      {
        name: 'delete',
        aliases: [],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
    ],
  },

  role: {
    name: 'role',
    shortcuts: ['r'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'list',
        aliases: [],
        requiresSubject: false,
        flags: [],
      },
      {
        name: 'view',
        aliases: ['get', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'name', type: 'string', required: true },
        ],
      },
      {
        name: 'assign',
        aliases: ['grant', 'give'],
        requiresSubject: true,
        flags: [
          { name: 'permission', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
      {
        name: 'revoke',
        aliases: ['remove', 'take'],
        requiresSubject: true,
        flags: [
          { name: 'permission', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
    ],
  },
}

/**
 * Resolve entity shortcut to canonical name
 */
export function resolveEntityShortcut(shortcut: string): string | null {
  const normalized = shortcut.toLowerCase()
  
  for (const [entity, def] of Object.entries(GRAMMAR)) {
    if (entity === normalized || def.shortcuts.includes(normalized)) {
      return entity
    }
  }
  
  return null
}

/**
 * Resolve verb alias to canonical name
 */
export function resolveVerbAlias(entity: string, verb: string): string | null {
  const entityDef = GRAMMAR[entity]
  if (!entityDef) return null
  
  const normalized = verb.toLowerCase()
  
  for (const verbDef of entityDef.verbs) {
    if (verbDef.name === normalized || verbDef.aliases.includes(normalized)) {
      return verbDef.name
    }
  }
  
  return null
}

/**
 * Check if verb is valid for entity
 */
export function isValidVerb(entity: string, verb: string): boolean {
  return resolveVerbAlias(entity, verb) !== null
}

/**
 * Get full verb definition
 */
export function getVerbDefinition(entity: string, verb: string) {
  const entityDef = GRAMMAR[entity]
  if (!entityDef) return null
  
  const resolvedVerb = resolveVerbAlias(entity, verb)
  if (!resolvedVerb) return null
  
  return entityDef.verbs.find(v => v.name === resolvedVerb) || null
}

/**
 * Get all entities
 */
export function getEntities(): string[] {
  return Object.keys(GRAMMAR)
}

/**
 * Get all verbs for an entity
 */
export function getVerbs(entity: string): string[] {
  const entityDef = GRAMMAR[entity]
  if (!entityDef) return []
  return entityDef.verbs.map(v => v.name)
}

/**
 * Command examples for inline placeholder hints
 */
export const COMMAND_EXAMPLES: Record<string, string> = {
  'company.create': 'company create Acme Inc USD',
  'company.list': 'company list',
  'company.view': 'company view acme-corp',
  'company.switch': 'company switch acme-corp',
  'company.delete': 'company delete acme-corp',

  'user.invite': 'user invite john@example.com',
  'user.list': 'user list',
  'user.view': 'user view john@example.com',
  'user.assign-role': 'user assign-role john@example.com admin',
  'user.remove-role': 'user remove-role john@example.com admin',
  'user.deactivate': 'user deactivate john@example.com',
  'user.activate': 'user activate john@example.com',
  'user.delete': 'user delete john@example.com',

  'role.list': 'role list',
  'role.view': 'role view admin',
  'role.assign': 'role assign users:create admin',
  'role.revoke': 'role revoke users:create admin',
}

/**
 * Get command example for inline placeholder
 */
export function getCommandExample(entity: string, verb: string): string {
  const key = `${entity}.${verb}`
  return COMMAND_EXAMPLES[key] || ''
}


===== build/resources/js/palette/help.ts =====
import { GRAMMAR } from './grammar'

/**
 * Get help text for a topic
 */
export function getHelp(topic?: string): string {
  if (!topic) {
    return getGeneralHelp()
  }

  const topicLower = topic.toLowerCase()

  // Help for specific entity
  if (GRAMMAR[topicLower]) {
    return getEntityHelp(topicLower)
  }

  // Help for entity.verb
  if (topicLower.includes('.')) {
    const [entity, verb] = topicLower.split('.')
    if (GRAMMAR[entity]) {
      return getVerbHelp(entity, verb)
    }
  }

  // Try to find entity by shortcut
  for (const [entityName, entityDef] of Object.entries(GRAMMAR)) {
    if (entityDef.shortcuts.includes(topicLower)) {
      return getEntityHelp(entityName)
    }
  }

  // Topic not found
  return `Unknown topic: ${topic}\n\nAvailable: ${Object.keys(GRAMMAR).join(', ')}, or type 'help' for overview.`
}

/**
 * General help - list all commands
 */
function getGeneralHelp(): string {
  const lines: string[] = [
    'COMMAND PALETTE',
    '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê',
    '',
    'Usage: entity verb [arguments] [--flags]',
    '',
    'AVAILABLE ENTITIES:',
    '',
  ]

  for (const [entityName, entity] of Object.entries(GRAMMAR)) {
    const shortcuts = entity.shortcuts.length > 0 
      ? ` (${entity.shortcuts.join(', ')})` 
      : ''
    const verbs = entity.verbs.map(v => v.name).join(', ')
    lines.push(`  ${entityName}${shortcuts}`)
    lines.push(`    verbs: ${verbs}`)
    lines.push('')
  }

  lines.push('BUILT-IN COMMANDS:')
  lines.push('')
  lines.push('  help [topic]     Show help (e.g., help company)')
  lines.push('  clear            Clear output')
  lines.push('')
  lines.push('SHORTCUTS:')
  lines.push('')
  lines.push('  ‚Üë/‚Üì              Navigate history')
  lines.push('  Tab              Accept suggestion')
  lines.push('  Ctrl+L           Clear output')
  lines.push('  Ctrl+U           Clear input')
  lines.push('  Esc              Close palette')
  lines.push('')
  lines.push('EXAMPLES:')
  lines.push('')
  lines.push('  company.list                    List all companies')
  lines.push('  co.create "Acme Corp" USD       Create company')
  lines.push('  user.invite john@example.com    Invite user')
  lines.push('')
  lines.push('Type "help <entity>" for detailed help (e.g., help company)')

  return lines.join('\n')
}

/**
 * Help for a specific entity
 */
function getEntityHelp(entityName: string): string {
  const entity = GRAMMAR[entityName]
  if (!entity) return `Unknown entity: ${entityName}`

  const lines: string[] = [
    `${entityName.toUpperCase()}`,
    '‚ïê'.repeat(entityName.length),
    '',
  ]

  if (entity.shortcuts.length > 0) {
    lines.push(`Shortcuts: ${entity.shortcuts.join(', ')}`)
    lines.push('')
  }

  lines.push('COMMANDS:')
  lines.push('')

  for (const verb of entity.verbs) {
    const aliases = verb.aliases.length > 0 
      ? ` (aliases: ${verb.aliases.join(', ')})` 
      : ''
    lines.push(`  ${entityName} ${verb.name}${aliases}`)

    // Show flags
    if (verb.flags.length > 0) {
      for (const flag of verb.flags) {
        const required = flag.required ? ' (required)' : ''
        const shorthand = flag.shorthand ? ` (-${flag.shorthand})` : ''
        const defaultVal = flag.default !== undefined ? ` [default: ${flag.default}]` : ''
        lines.push(`    --${flag.name}${shorthand}: ${flag.type}${required}${defaultVal}`)
      }
    } else {
      lines.push('    (no flags)')
    }

    // Example using canonical entity and verb
    lines.push(`    Example: ${buildExample(entityName, verb)}`)
    lines.push('')
  }

  lines.push('EXAMPLES:')
  lines.push('')
  lines.push(...getEntityExamples(entityName))

  return lines.join('\n')
}

/**
 * Help for a specific verb
 */
function getVerbHelp(entityName: string, verbName: string): string {
  const entity = GRAMMAR[entityName]
  if (!entity) return `Unknown entity: ${entityName}`

  const verb = entity.verbs.find(v => 
    v.name === verbName || v.aliases.includes(verbName)
  )
  if (!verb) return `Unknown verb: ${entityName}.${verbName}`

  const lines: string[] = [
    `${entityName.toUpperCase()} ${verb.name.toUpperCase()}`,
    '‚ïê'.repeat(entityName.length + verb.name.length + 1),
    '',
  ]

  if (verb.aliases.length > 0) {
    lines.push(`Aliases: ${verb.aliases.join(', ')}`)
    lines.push('')
  }

  lines.push('FLAGS:')
  lines.push('')

  if (verb.flags.length > 0) {
    for (const flag of verb.flags) {
      const required = flag.required ? ' (required)' : ''
      const shorthand = flag.shorthand ? `, -${flag.shorthand}` : ''
      const defaultVal = flag.default !== undefined ? `\n      Default: ${flag.default}` : ''
      lines.push(`  --${flag.name}${shorthand}`)
      lines.push(`      Type: ${flag.type}${required}${defaultVal}`)
      lines.push('')
    }
  } else {
    lines.push('  (no flags)')
    lines.push('')
  }

  lines.push('EXAMPLES:')
  lines.push('')
  lines.push(`  ${buildExample(entityName, verb)}`)
  lines.push(...getVerbExamples(entityName, verb.name))

  return lines.join('\n')
}

/**
 * Get example commands for an entity
 */
function getEntityExamples(entityName: string): string[] {
  const examples: Record<string, string[]> = {
    company: [
      '  company list',
      '  company create "Acme Corp" USD',
      '  co create "My Company" USD --industry=tech',
      '  company switch acme-corp',
      '  company delete acme-corp',
    ],
    user: [
      '  user list',
      '  user invite john@example.com',
      '  user invite jane@example.com --role=admin',
      '  user assign-role john@example.com --role=accountant',
      '  user deactivate john@example.com',
    ],
    role: [
      '  role list',
      '  role assign --permission=invoice:create --role=accountant',
      '  role revoke --permission=invoice:delete --role=member',
    ],
  }

  return examples[entityName] || ['  (no examples available)']
}

/**
 * Get example commands for a specific verb
 */
function getVerbExamples(entityName: string, verbName: string): string[] {
  const key = `${entityName}.${verbName}`
  const examples: Record<string, string[]> = {
    'company.list': [
      '  company list',
      '  co list',
    ],
    'company.create': [
      '  company create "Acme Corp" USD',
      '  co create "My Company" CAD',
      '  company create --name="Big Corp" --currency=EUR --industry=finance',
    ],
    'company.switch': [
      '  company switch acme-corp',
      '  co switch my-company',
    ],
    'company.delete': [
      '  company delete acme-corp',
      '  co delete old-company',
    ],
    'user.list': [
      '  user list',
      '  u list',
    ],
    'user.invite': [
      '  user invite john@example.com',
      '  user invite jane@example.com --role=admin',
      '  u invite test@test.com --name="John Doe"',
    ],
    'user.assign-role': [
      '  user assign-role john@example.com --role=admin',
      '  user assign --email=jane@example.com --role=accountant',
    ],
    'user.deactivate': [
      '  user deactivate john@example.com',
      '  user disable --email=test@test.com',
    ],
    'role.list': [
      '  role list',
      '  r list',
    ],
  }

  return examples[key] || ['  (no examples available)']
}

function buildExample(
  entityName: string,
  verb: { name: string; flags: Array<{ name: string; required: boolean }>; requiresSubject: boolean }
): string {
  const base = `${entityName}.${verb.name}`
  const requiredFlags = verb.flags
    .filter(f => f.required)
    .map(f => `--${f.name}=<${f.name}>`)
    .join(' ')

  const subjectHint = verb.requiresSubject ? '<value>' : ''
  return [base, subjectHint, requiredFlags].filter(Boolean).join(' ').trim()
}


===== build/resources/js/palette/parser.ts =====
import type { ParsedCommand } from '@/types/palette'
import { GRAMMAR, resolveEntityShortcut, resolveVerbAlias, getVerbDefinition } from './grammar'

/**
 * Parse a command string into a structured ParsedCommand
 */
export function parse(input: string): ParsedCommand {
  const result: ParsedCommand = {
    raw: input.trim(),
    entity: '',
    verb: '',
    flags: {},
    complete: false,
    confidence: 0,
    errors: [],
    idemKey: '',
  }

  if (!result.raw) {
    result.errors.push('Empty command')
    return result
  }

  const tokens = tokenize(result.raw)
  
  if (tokens.length === 0) {
    result.errors.push('No tokens found')
    return result
  }

  const first = tokens[0]
  let rest = tokens.slice(1)

  // Parse entity.verb
  const entityVerb = parseEntityVerb(first, rest)
  if (entityVerb) {
    result.entity = entityVerb.entity
    result.verb = entityVerb.verb
    if (entityVerb.consumed > 1) {
      rest = rest.slice(entityVerb.consumed - 1)
    }
  } else {
    result.errors.push(`Unknown command: ${first}`)
    return result
  }

  // Extract flags and remaining positional args
  const { flags, remaining, flagErrors } = extractFlags(rest, result.entity, result.verb)
  result.flags = flags
  result.errors.push(...flagErrors)

  // Set subject from remaining tokens
  if (remaining.length > 0) {
    result.subject = remaining.join(' ')
  }

  // Infer flags from subject (smart parsing)
  inferFromSubject(result)

  // Calculate completion status
  result.complete = isComplete(result)
  result.confidence = calculateConfidence(result)
  result.idemKey = generateIdemKey(result)

  return result
}

/**
 * Parse entity.verb from tokens
 */
function parseEntityVerb(
  token: string, 
  remainingTokens: string[]
): { entity: string; verb: string; consumed: number } | null {
  
  // Handle "entity.verb" format
  if (token.includes('.')) {
    const [entityPart, verbPart] = token.split('.')
    const entity = resolveEntityShortcut(entityPart)
    if (!entity) return null
    
    const verb = resolveVerbAlias(entity, verbPart)
    if (!verb) return null
    
    return { entity, verb, consumed: 1 }
  }

  // Handle "entity verb" format (space separated)
  const entity = resolveEntityShortcut(token)
  if (entity) {
    if (remainingTokens.length > 0) {
      const candidateVerb = resolveVerbAlias(entity, remainingTokens[0])
      if (candidateVerb) {
        return { entity, verb: candidateVerb, consumed: 2 }
      }
    }
    // Use default verb
    return { entity, verb: GRAMMAR[entity].defaultVerb, consumed: 1 }
  }

  return null
}

/**
 * Tokenize input, respecting quotes
 */
function tokenize(input: string): string[] {
  const tokens: string[] = []
  let current = ''
  let inQuotes = false
  let quoteChar = ''

  for (const char of input) {
    if ((char === '"' || char === "'") && !inQuotes) {
      inQuotes = true
      quoteChar = char
    } else if (char === quoteChar && inQuotes) {
      inQuotes = false
      quoteChar = ''
    } else if (char === ' ' && !inQuotes) {
      if (current) {
        tokens.push(current)
        current = ''
      }
    } else {
      current += char
    }
  }

  if (current) tokens.push(current)
  return tokens
}

/**
 * Extract flags from tokens
 */
function extractFlags(
  tokens: string[],
  entity: string,
  verb: string
): { flags: Record<string, unknown>; remaining: string[]; flagErrors: string[] } {
  const flags: Record<string, unknown> = {}
  const remaining: string[] = []
  const errors: string[] = []

  const verbDef = getVerbDefinition(entity, verb)
  if (!verbDef) {
    return { flags, remaining: tokens, flagErrors: errors }
  }

  let i = 0
  while (i < tokens.length) {
    const token = tokens[i]

    if (token.startsWith('--')) {
      const { name, value, consumed, error } = parseLongFlag(token, tokens[i + 1], verbDef.flags)
      if (error) errors.push(error)
      else if (name) flags[name] = value
      i += consumed
    } else if (token.startsWith('-') && token.length === 2) {
      const { name, value, consumed, error } = parseShortFlag(token, tokens[i + 1], verbDef.flags)
      if (error) errors.push(error)
      else if (name) flags[name] = value
      i += consumed
    } else {
      remaining.push(token)
      i++
    }
  }

  return { flags, remaining, flagErrors: errors }
}

/**
 * Parse --flag or --flag=value
 */
function parseLongFlag(
  token: string,
  nextToken: string | undefined,
  flagDefs: Array<{ name: string; shorthand?: string; type: string; required: boolean; default?: unknown }>
): { name: string | null; value: unknown; consumed: number; error: string | null } {
  const withoutDashes = token.substring(2)
  
  // Handle --flag=value
  if (withoutDashes.includes('=')) {
    const [name, ...valueParts] = withoutDashes.split('=')
    const value = valueParts.join('=')
    const flagDef = flagDefs.find(f => f.name === name)
    
    if (!flagDef) {
      return { name: null, value: null, consumed: 1, error: `Unknown flag: --${name}` }
    }
    
    return { name, value: coerceValue(value, flagDef.type), consumed: 1, error: null }
  }

  // Handle --flag value or --flag (boolean)
  const flagDef = flagDefs.find(f => f.name === withoutDashes)
  
  if (!flagDef) {
    return { name: null, value: null, consumed: 1, error: `Unknown flag: --${withoutDashes}` }
  }

  if (flagDef.type === 'boolean') {
    return { name: withoutDashes, value: true, consumed: 1, error: null }
  }

  if (!nextToken || nextToken.startsWith('-')) {
    return { name: null, value: null, consumed: 1, error: `Flag --${withoutDashes} requires a value` }
  }

  return { name: withoutDashes, value: coerceValue(nextToken, flagDef.type), consumed: 2, error: null }
}

/**
 * Parse -f or -f value
 */
function parseShortFlag(
  token: string,
  nextToken: string | undefined,
  flagDefs: Array<{ name: string; shorthand?: string; type: string; required: boolean }>
): { name: string | null; value: unknown; consumed: number; error: string | null } {
  const shorthand = token[1]
  const flagDef = flagDefs.find(f => f.shorthand === shorthand)
  
  if (!flagDef) {
    return { name: null, value: null, consumed: 1, error: `Unknown flag: -${shorthand}` }
  }

  if (flagDef.type === 'boolean') {
    return { name: flagDef.name, value: true, consumed: 1, error: null }
  }

  if (!nextToken || nextToken.startsWith('-')) {
    return { name: null, value: null, consumed: 1, error: `Flag -${shorthand} requires a value` }
  }

  return { name: flagDef.name, value: coerceValue(nextToken, flagDef.type), consumed: 2, error: null }
}

/**
 * Coerce string value to appropriate type
 */
function coerceValue(value: string, type: string): unknown {
  if (type === 'number') {
    const num = parseFloat(value)
    return isNaN(num) ? value : num
  }
  
  if (type === 'boolean') {
    return value.toLowerCase() === 'true' || value === '1'
  }
  
  return value
}

/**
 * Infer flag values from positional subject
 */
function inferFromSubject(result: ParsedCommand): void {
  if (!result.subject) return

  const words = result.subject.split(/\s+/)

  // Company create: "company.create Acme Corp USD"
  if (result.entity === 'company' && result.verb === 'create') {
    if (!result.flags.name && words.length > 0) {
      // Find currency (3 uppercase letters at the end)
      const lastWord = words[words.length - 1]
      if (lastWord && lastWord.length === 3 && lastWord.toUpperCase() === lastWord) {
        result.flags.currency = lastWord.toUpperCase()
        result.flags.name = words.slice(0, -1).join(' ')
      } else {
        // No currency found, entire subject is name
        result.flags.name = result.subject
      }
    }
  }

  // Company switch/delete: "company.switch acme-corp"
  if (result.entity === 'company' && ['switch', 'delete', 'view'].includes(result.verb)) {
    if (!result.flags.slug && words.length > 0) {
      result.flags.slug = words.join('-').toLowerCase()
    }
  }

  // User invite: "user.invite john@example.com"
  if (result.entity === 'user' && result.verb === 'invite') {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    const emailWord = words.find(w => emailRegex.test(w))
    
    if (emailWord && !result.flags.email) {
      result.flags.email = emailWord
      // Remaining words could be name
      const nameWords = words.filter(w => w !== emailWord)
      if (nameWords.length > 0 && !result.flags.name) {
        result.flags.name = nameWords.join(' ')
      }
    }
  }

  // User operations with email: deactivate, delete, assign-role
  if (result.entity === 'user' && ['deactivate', 'delete', 'assign-role', 'remove-role'].includes(result.verb)) {
    if (!result.flags.email && words.length > 0) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      const emailWord = words.find(w => emailRegex.test(w))
      if (emailWord) {
        result.flags.email = emailWord
      }
    }
  }
}

/**
 * Check if command has all required flags
 */
function isComplete(result: ParsedCommand): boolean {
  if (result.errors.length > 0) return false
  if (!result.entity || !result.verb) return false

  const verbDef = getVerbDefinition(result.entity, result.verb)
  if (!verbDef) return false

  const requiredFlags = verbDef.flags.filter(f => f.required)
  for (const flag of requiredFlags) {
    if (!(flag.name in result.flags)) {
      return false
    }
  }

  return true
}

/**
 * Calculate confidence score (0-1)
 */
function calculateConfidence(result: ParsedCommand): number {
  if (!result.entity || !result.verb) return 0
  if (result.errors.length > 0) return 0.3

  const verbDef = getVerbDefinition(result.entity, result.verb)
  if (!verbDef) return 0

  const totalFlags = verbDef.flags.length
  const providedFlags = Object.keys(result.flags).length

  if (totalFlags === 0) return 1

  const flagScore = providedFlags / totalFlags
  return result.complete ? 1 : Math.min(0.9, flagScore)
}

/**
 * Generate idempotency key for the command
 */
function generateIdemKey(result: ParsedCommand): string {
  if (!result.complete) return ''
  
  const parts = [
    result.entity,
    result.verb,
    ...Object.entries(result.flags)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}=${v}`),
  ]
  
  return btoa(parts.join('|')).substring(0, 32)
}


===== build/resources/js/palette/quick-actions.ts =====
import type { QuickAction, TableState } from '@/types/palette'

/**
 * Quick Actions System
 *
 * Provides numbered shortcuts for common actions after list commands.
 * Actions are context-aware and can be row-specific.
 */

/**
 * Get quick actions for a given entity/verb combination
 */
export function getQuickActions(entity: string, verb: string): QuickAction[] {
  const key = `${entity}.${verb}`

  switch (key) {
    case 'company.list':
      return [
        {
          key: '1',
          label: 'Switch to company',
          command: 'company switch {slug}',
          needsRow: true,
        },
        {
          key: '2',
          label: 'View details',
          command: 'company view {slug}',
          needsRow: true,
        },
        {
          key: '3',
          label: 'Assign user',
          command: 'user invite',
          needsRow: true,
          prompt: 'Enter user email (optionally add role, e.g., jane@x.com --role owner)',
        },
        {
          key: '4',
          label: 'Create new company',
          command: 'company create',
          needsRow: false,
          prompt: 'Enter company name and currency (e.g., Acme Inc USD)',
        },
        {
          key: '0',
          label: 'Delete company',
          command: 'company delete {slug}',
          needsRow: true,
        },
      ]

    case 'user.list':
      return [
        {
          key: '1',
          label: 'View user',
          command: 'user view {email}',
          needsRow: true,
        },
        {
          key: '2',
          label: 'Assign role',
          command: 'user assign-role {email}',
          needsRow: true,
          prompt: 'Enter role name',
        },
        {
          key: '3',
          label: 'Deactivate user',
          command: 'user deactivate {email}',
          needsRow: true,
        },
        {
          key: '4',
          label: 'Invite new user',
          command: 'user invite',
          needsRow: false,
          prompt: 'Enter email address',
        },
      ]

    case 'role.list':
      return [
        {
          key: '1',
          label: 'View role',
          command: 'role view {name}',
          needsRow: true,
        },
        {
          key: '2',
          label: 'Assign permission',
          command: 'role assign',
          needsRow: true,
          prompt: 'Enter permission name',
        },
        {
          key: '3',
          label: 'Revoke permission',
          command: 'role revoke',
          needsRow: true,
          prompt: 'Enter permission name',
        },
      ]

    default:
      return []
  }
}

/**
 * Check if entity.verb combination supports quick actions
 */
export function hasQuickActions(entity: string, verb: string): boolean {
  return getQuickActions(entity, verb).length > 0
}

/**
 * Resolve command template with row data
 *
 * @param template - Command template with {field} placeholders
 * @param tableState - Current table state
 * @returns Resolved command string
 */
export function resolveQuickActionCommand(
  template: string,
  tableState: TableState | null
): string | null {
  if (!template) return null

  // If template has no placeholders, return as-is
  if (!template.includes('{')) {
    return template
  }

  // Need table state to resolve placeholders
  if (!tableState) return null

  const { headers, rows, selectedRowIndex } = tableState

  // Need a selected row
  if (selectedRowIndex < 0 || selectedRowIndex >= rows.length) {
    return null
  }

  const selectedRow = rows[selectedRowIndex]
  let resolved = template

  // Replace {field} placeholders with row values
  // Match headers to find the right column
  headers.forEach((header, index) => {
    const value = selectedRow[index] || ''
    const normalizedHeader = header.toLowerCase().replace(/\s+/g, '')

    // Try to match common patterns
    const patterns = [
      `{${normalizedHeader}}`,
      `{${header.toLowerCase()}}`,
      `{${header}}`,
    ]

    patterns.forEach(pattern => {
      resolved = resolved.replace(new RegExp(pattern.replace(/[{}]/g, '\\$&'), 'g'), value)
    })
  })

  // Handle common field name mappings
  const mappings: Record<string, string[]> = {
    slug: ['slug', 'id', 'name', 'company'],
    email: ['email', 'user', 'emailaddress'],
    name: ['name', 'rolename', 'role'],
  }

  Object.entries(mappings).forEach(([placeholder, possibleHeaders]) => {
    const pattern = `{${placeholder}}`
    if (resolved.includes(pattern)) {
      // Find matching header
      for (const possibleHeader of possibleHeaders) {
        const headerIndex = headers.findIndex(h =>
          h.toLowerCase().replace(/\s+/g, '') === possibleHeader
        )
        if (headerIndex >= 0) {
          const value = selectedRow[headerIndex] || ''
          resolved = resolved.replace(new RegExp(pattern.replace(/[{}]/g, '\\$&'), 'g'), value)
          break
        }
      }
    }
  })

  // If still has unresolved placeholders, return null
  if (resolved.includes('{')) {
    return null
  }

  return resolved.trim()
}

/**
 * Get display label with row data
 *
 * @param action - Quick action
 * @param tableState - Current table state
 * @returns Display label with context
 */
export function getQuickActionLabel(
  action: QuickAction,
  tableState: TableState | null
): string {
  if (!action.needsRow || !tableState) {
    return action.label
  }

  const { headers, rows, selectedRowIndex } = tableState

  if (selectedRowIndex < 0 || selectedRowIndex >= rows.length) {
    return action.label
  }

  const selectedRow = rows[selectedRowIndex]

  // Try to find a meaningful identifier from the row
  // Priority: name/slug/email -> first column -> generic
  const identifierHeaders = ['name', 'slug', 'email', 'company']
  let identifier = ''

  for (const headerName of identifierHeaders) {
    const headerIndex = headers.findIndex(h =>
      h.toLowerCase().replace(/\s+/g, '') === headerName
    )
    if (headerIndex >= 0 && selectedRow[headerIndex]) {
      identifier = selectedRow[headerIndex]
      break
    }
  }

  // Fallback to first column
  if (!identifier && selectedRow.length > 0) {
    identifier = selectedRow[0]
  }

  if (!identifier) {
    return action.label
  }

  // Append identifier to label
  return `${action.label}: ${identifier}`
}


===== build/resources/js/palette/table.ts =====
/**
 * Format data as an ASCII table
 */
export function formatTable(
  rows: string[][],
  headers?: string[],
  footer?: string
): string {
  if (rows.length === 0 && !headers) {
    return '(no results)'
  }

  // Calculate column widths
  const allRows = headers ? [headers, ...rows] : rows
  const colCount = Math.max(...allRows.map(r => r.length))
  const colWidths: number[] = []

  for (let col = 0; col < colCount; col++) {
    let maxWidth = 0
    for (const row of allRows) {
      const cell = stripAnsi(row[col] || '')
      maxWidth = Math.max(maxWidth, cell.length)
    }
    // Cap column width at 40 chars
    colWidths.push(Math.min(maxWidth, 40))
  }

  const lines: string[] = []

  // Top border
  lines.push(formatBorder(colWidths, '‚îå', '‚î¨', '‚îê'))

  // Header
  if (headers) {
    lines.push(formatRow(headers, colWidths))
    lines.push(formatBorder(colWidths, '‚îú', '‚îº', '‚î§'))
  }

  // Rows
  for (let i = 0; i < rows.length; i++) {
    lines.push(formatRow(rows[i], colWidths))
  }

  // Bottom border
  lines.push(formatBorder(colWidths, '‚îî', '‚î¥', '‚îò'))

  // Footer
  if (footer) {
    lines.push('')
    lines.push(footer)
  }

  return lines.join('\n')
}

/**
 * Format a single row
 */
function formatRow(cells: string[], widths: number[]): string {
  const parts: string[] = []

  for (let i = 0; i < widths.length; i++) {
    const cell = cells[i] || ''
    const stripped = stripAnsi(cell)
    const padded = stripped.padEnd(widths[i])
    // Truncate if too long
    const final = padded.length > widths[i] 
      ? padded.substring(0, widths[i] - 1) + '‚Ä¶'
      : padded
    parts.push(final)
  }

  return '‚îÇ ' + parts.join(' ‚îÇ ') + ' ‚îÇ'
}

/**
 * Format a border line
 */
function formatBorder(widths: number[], left: string, mid: string, right: string): string {
  const segments = widths.map(w => '‚îÄ'.repeat(w + 2))
  return left + segments.join(mid) + right
}

/**
 * Strip ANSI codes and our custom tags from text
 */
function stripAnsi(text: string): string {
  // Remove ANSI escape codes
  let result = text.replace(/\x1b\[[0-9;]*m/g, '')
  // Remove our {tag}...{/} format
  result = result.replace(/\{[^}]+\}/g, '')
  return result
}

/**
 * Simple table format (no borders) for compact output
 */
export function formatSimpleTable(
  rows: string[][],
  headers?: string[]
): string {
  if (rows.length === 0) return '(no results)'

  const allRows = headers ? [headers, ...rows] : rows
  const colCount = Math.max(...allRows.map(r => r.length))
  const colWidths: number[] = []

  for (let col = 0; col < colCount; col++) {
    let maxWidth = 0
    for (const row of allRows) {
      const cell = stripAnsi(row[col] || '')
      maxWidth = Math.max(maxWidth, cell.length)
    }
    colWidths.push(Math.min(maxWidth, 40))
  }

  const lines: string[] = []

  if (headers) {
    lines.push(formatSimpleRow(headers, colWidths))
    lines.push(colWidths.map(w => '‚îÄ'.repeat(w)).join('  '))
  }

  for (const row of rows) {
    lines.push(formatSimpleRow(row, colWidths))
  }

  return lines.join('\n')
}

function formatSimpleRow(cells: string[], widths: number[]): string {
  return cells
    .map((cell, i) => {
      const stripped = stripAnsi(cell || '')
      return stripped.padEnd(widths[i] || 0)
    })
    .join('  ')
}

/**
 * Format key-value pairs (for single record display)
 */
export function formatKeyValue(data: Record<string, unknown>): string {
  const maxKeyLen = Math.max(...Object.keys(data).map(k => k.length))

  return Object.entries(data)
    .map(([key, value]) => {
      const paddedKey = key.padEnd(maxKeyLen)
      const displayValue = formatValue(value)
      return `${paddedKey}  ${displayValue}`
    })
    .join('\n')
}

function formatValue(value: unknown): string {
  if (value === null || value === undefined) return '‚Äî'
  if (typeof value === 'boolean') return value ? 'Yes' : 'No'
  if (typeof value === 'number') return value.toLocaleString()
  if (value instanceof Date) return value.toLocaleDateString()
  if (Array.isArray(value)) return value.join(', ')
  return String(value)
}


===== build/resources/js/components/palette/CommandPalette.vue =====
<script setup lang="ts">
import { ref, watch, nextTick, computed, onMounted, onUnmounted } from 'vue'
import { parse } from '@/palette/parser'
import { generateSuggestions } from '@/palette/autocomplete'
import { formatTable } from '@/palette/table'
import { getHelp } from '@/palette/help'
import { formatText } from '@/palette/formatter'
import { getCommandExample } from '@/palette/grammar'
import { getQuickActions, resolveQuickActionCommand, getQuickActionLabel } from '@/palette/quick-actions'
import { usePage } from '@inertiajs/vue3'
import type { ParsedCommand, Suggestion, QuickAction, TableState } from '@/types/palette'

const props = defineProps<{ visible: boolean }>()
const emit = defineEmits<{ 'update:visible': [v: boolean] }>()

// State
const input = ref('')
const output = ref<OutputLine[]>([])
const history = ref<string[]>(loadHistory())
const historyIndex = ref(-1)
const executing = ref(false)
const suggestions = ref<Suggestion[]>([])
const suggestionIndex = ref(0)
const showSuggestions = ref(false)
const awaitingConfirmation = ref<{
  original: string
  parsed: ParsedCommand
  message: string
} | null>(null)

// Quick actions state
const tableState = ref<TableState | null>(null)
const quickActions = ref<QuickAction[]>([])
const showSubPrompt = ref(false)
const subPromptAction = ref<QuickAction | null>(null)
const subPromptInput = ref('')
const pendingRefreshEntity = ref<string | null>(null)

// Parsed command (reactive)
const parsed = computed(() => parse(input.value))

// Parsed display helpers
const hasFlags = computed(() => Object.keys(parsed.value.flags).length > 0)
const flagEntries = computed(() => Object.entries(parsed.value.flags))

// Inline placeholder hint (ghosted text showing example)
const placeholderHint = computed(() => {
  // Don't show if suggestions are visible
  if (showSuggestions.value) return ''

  // Don't show if executing
  if (executing.value) return ''

  // Don't show if awaiting confirmation
  if (awaitingConfirmation.value) return ''

  const trimmed = input.value.trim()
  const parsedCmd = parse(trimmed)

  // Only show if we have entity + verb
  if (!parsedCmd.entity || !parsedCmd.verb) return ''

  const example = getCommandExample(parsedCmd.entity, parsedCmd.verb)

  // Only show the remaining part (what user hasn't typed yet)
  if (example && example.startsWith(trimmed)) {
    return example.slice(trimmed.length)
  }

  return ''
})

// Width of typed text for positioning ghost text
const typedTextWidth = ref('0px')

// Dynamic suggestions fetch timeout
const fetchTimeout = ref<number | null>(null)

// Refs
const inputEl = ref<HTMLInputElement>()
const outputEl = ref<HTMLDivElement>()
const subPromptInputEl = ref<HTMLInputElement>()

// Company context
const page = usePage()
const initialCompany = computed(() => (page.props.auth as any)?.currentCompany)
const activeCompany = ref(initialCompany.value || null)
const companySlug = computed(() => activeCompany.value?.slug || '')

interface OutputLine {
  type: 'input' | 'output' | 'error' | 'success' | 'table'
  content: string | string[][]
  headers?: string[]
  footer?: string
}

// Focus on open
watch(() => props.visible, (v) => {
  if (v) {
    nextTick(() => inputEl.value?.focus())
    document.addEventListener('keydown', handleKeydown)
  } else {
    showSuggestions.value = false
    historyIndex.value = -1
    document.removeEventListener('keydown', handleKeydown)
  }
})

// Auto-scroll output
watch(() => output.value.length, () => {
  nextTick(() => {
    if (outputEl.value) outputEl.value.scrollTop = outputEl.value.scrollHeight
  })
})

// Update suggestions on input
watch(input, async (val) => {
  const trimmed = val.trim()

  // Calculate text width for ghost text positioning
  if (inputEl.value) {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    if (ctx) {
      const style = window.getComputedStyle(inputEl.value)
      ctx.font = style.font
      const width = ctx.measureText(val).width
      typedTextWidth.value = `${width}px`
    }
  }

  if (!trimmed) {
    showSuggestions.value = false
    return
  }

  const words = trimmed.split(/\s+/)
  const parsedCmd = parse(trimmed)

  // Special case: If we have entity + verb and input ends with space,
  // show placeholder hint instead of suggestions
  if (words.length === 2 && val.endsWith(' ') && parsedCmd.entity && parsedCmd.verb) {
    showSuggestions.value = false
    return
  }

  // If less than 3 words, use static grammar-based suggestions
  if (words.length < 3) {
    suggestions.value = generateSuggestions(val)
    showSuggestions.value = suggestions.value.length > 0
    suggestionIndex.value = 0
    return
  }

  // 3+ words: fetch dynamic suggestions
  if (!parsedCmd.entity || !parsedCmd.verb) {
    suggestions.value = generateSuggestions(val)
    showSuggestions.value = suggestions.value.length > 0
    suggestionIndex.value = 0
    return
  }

  // Extract partial value (everything after entity and verb)
  const partialValue = words.slice(2).join(' ')

  // Fetch dynamic suggestions
  await fetchDynamicSuggestions(parsedCmd.entity, parsedCmd.verb, partialValue)
})

// Watch output for table data to populate tableState
watch(output, (newOutput) => {
  const lastTable = newOutput.slice().reverse().find(line => line.type === 'table')

  if (!lastTable) {
    tableState.value = null
    return
  }

  // Get the last command that was executed
  const lastInput = newOutput.slice().reverse().find(line => line.type === 'input')
  if (!lastInput) {
    return
  }

  // Parse the command to get entity and verb
  const cmd = String(lastInput.content).replace('‚ùØ ', '')
  const parsedCmd = parse(cmd)

  if (!parsedCmd.entity || !parsedCmd.verb) {
    return
  }

  // Populate tableState
  tableState.value = {
    headers: lastTable.headers || [],
    rows: lastTable.content as string[][],
    selectedRowIndex: 0,
    entity: parsedCmd.entity,
    verb: parsedCmd.verb,
  }
}, { deep: true })

// Watch tableState to update quickActions
watch(tableState, (newState) => {
  if (!newState) {
    quickActions.value = []
    return
  }

  const actions = getQuickActions(newState.entity, newState.verb)
  quickActions.value = actions
})

function close() {
  emit('update:visible', false)
  input.value = ''
  if (fetchTimeout.value) clearTimeout(fetchTimeout.value)
}

/**
 * Fetch dynamic suggestions from backend
 */
async function fetchDynamicSuggestions(
  entity: string,
  verb: string,
  partial: string
) {
  // Clear existing timeout
  if (fetchTimeout.value) clearTimeout(fetchTimeout.value)

  // Debounce to avoid excessive requests
  fetchTimeout.value = setTimeout(async () => {
    try {
      const params = new URLSearchParams({
        entity,
        verb,
        q: partial,
      })

      const res = await fetch(`/api/palette/suggestions?${params}`, {
        credentials: 'same-origin',
        headers: {
          'Accept': 'application/json',
          'X-Requested-With': 'XMLHttpRequest',
        },
      })

      if (!res.ok) {
        // Fallback to static suggestions on error
        suggestions.value = generateSuggestions(input.value)
        showSuggestions.value = suggestions.value.length > 0
        return
      }

      const data = await res.json()

      // Merge dynamic suggestions with static ones
      const dynamicSuggestions = (data.suggestions || []).map((s: any) => ({
        type: 'value' as const,
        value: `${entity} ${verb} ${s.value}`,
        label: s.label,
        description: s.description,
        icon: s.icon,
      }))

      const staticSuggestions = generateSuggestions(input.value)

      // Combine and deduplicate
      suggestions.value = [...dynamicSuggestions, ...staticSuggestions].slice(0, 8)
      showSuggestions.value = suggestions.value.length > 0
      suggestionIndex.value = 0

    } catch (e) {
      console.error('Failed to fetch palette suggestions:', e)
      // Fallback to static suggestions
      suggestions.value = generateSuggestions(input.value)
      showSuggestions.value = suggestions.value.length > 0
    }
  }, 300) // 300ms debounce
}

function addOutput(type: OutputLine['type'], content: string | string[][], headers?: string[], footer?: string) {
  output.value.push({ type, content, headers, footer })
  // Keep max 200 lines
  if (output.value.length > 200) {
    output.value = output.value.slice(-200)
  }
}

// Destructive actions requiring confirmation
const DESTRUCTIVE_ACTIONS = [
  'company.delete',
  'user.delete',
  'role.delete',
  'user.deactivate',
]

async function execute() {
  const cmd = input.value.trim()
  if (!cmd || executing.value) return

  showSuggestions.value = false

  // Check if we're awaiting confirmation
  if (awaitingConfirmation.value) {
    if (cmd.toLowerCase() === 'yes') {
      // User confirmed - execute the original command
      const { parsed } = awaitingConfirmation.value
      awaitingConfirmation.value = null
      await executeCommand(parsed)
    } else {
      // User cancelled
      addOutput('output', '{secondary}Cancelled{/}')
      awaitingConfirmation.value = null
    }
    input.value = ''
    focusInput()
    return
  }

  // Handle built-in commands
  if (cmd === 'clear' || cmd === 'cls') {
    output.value = []
    input.value = ''
    focusInput()
    return
  }

  if (cmd === 'help' || cmd.startsWith('help ')) {
    const topic = cmd.slice(5).trim() || undefined
    const helpText = getHelp(topic)
    addOutput('output', helpText)
    addToHistory(cmd)
    input.value = ''
    focusInput()
    return
  }

  // Parse command
  const parsed = parse(cmd)

  if (parsed.errors.length > 0) {
    addOutput('input', `‚ùØ ${cmd}`)
    addOutput('error', `{error}‚úó{/} ${parsed.errors.join(', ')}`)
    input.value = ''
    focusInput()
    return
  }

  if (!parsed.entity || !parsed.verb) {
    addOutput('input', `‚ùØ ${cmd}`)
    addOutput('error', `{error}‚úó{/} Unknown command. Type 'help' for available commands.`)
    input.value = ''
    focusInput()
    return
  }

  // Check if destructive
  const actionKey = `${parsed.entity}.${parsed.verb}`
  if (DESTRUCTIVE_ACTIONS.includes(actionKey)) {
    // Show confirmation prompt
    const entityName = String(parsed.flags.slug || parsed.flags.email || parsed.flags.name || 'this item')
    addOutput('input', `‚ùØ ${cmd}`)
    addOutput('warning', `{warning}‚ö†Ô∏è  Delete ${entityName}?{/}`)
    addOutput('warning', `{warning}Type 'yes' to confirm, or anything else to cancel{/}`)

    awaitingConfirmation.value = {
      original: cmd,
      parsed: parsed,
      message: `Confirm deletion`,
    }
    addToHistory(cmd)
    input.value = ''
    focusInput()
    return
  }

  // Normal execution
  await executeCommand(parsed)
  input.value = ''
  focusInput()
}

async function executeCommand(parsed: ParsedCommand) {
  const cmd = parsed.raw
  const resolvedCompanySlug = getRequestCompanySlug(parsed)
  const requiresCompany = needsCompanyContext(parsed)

  // Clear quick actions when new command executes
  tableState.value = null
  quickActions.value = []
  showSubPrompt.value = false
  subPromptAction.value = null
  subPromptInput.value = ''

  addOutput('input', `‚ùØ ${cmd}`)
  addToHistory(cmd)
  executing.value = true

  try {
    // Require company context for tenant commands
    if (requiresCompany && !resolvedCompanySlug) {
      addOutput('error', `{error}‚úó{/} Company context required. Switch into a company or include --slug.`)
      return
    }

    // Read-only verbs that shouldn't use idempotency (always fetch fresh)
    const readOnlyVerbs = ['list', 'view', 'get', 'show']
    const isReadOnly = readOnlyVerbs.includes(parsed.verb)

    // For read operations, add timestamp to ensure fresh data
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'X-Requested-With': 'XMLHttpRequest',
      'X-Action': `${parsed.entity}.${parsed.verb}`,
      'X-CSRF-TOKEN': getCsrfToken(),
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
    }

    if (resolvedCompanySlug) {
      headers['X-Company-Slug'] = resolvedCompanySlug
    }

    // Only use idempotency for write operations
    if (!isReadOnly) {
      // ALWAYS generate a fresh idempotency key with timestamp
      // Don't use parsed.idemKey as it's deterministic (same command = same key)
      headers['X-Idempotency-Key'] = generateIdemKey(parsed)
    } else {
      // For read ops, add timestamp to bust any backend caching
      headers['X-Request-Time'] = Date.now().toString()
    }

    const res = await fetch('/api/commands', {
      method: 'POST',
      credentials: 'same-origin',
      cache: 'no-store', // Prevent browser caching
      headers,
      body: JSON.stringify({ params: parsed.flags }),
    })

    const data = await res.json()

    if (data.ok) {
      // Table response
      if (data.data?.headers && data.data?.rows) {
        addOutput('table', data.data.rows, data.data.headers, data.data.footer)
      } 
      // Message response
      else if (data.message) {
        addOutput('success', `{success}‚úì{/} ${data.message}`)
      }
      // Generic success
      else {
        addOutput('success', '{success}‚úì{/} Done')
      }

      // After deletes, refresh the list to show updated rows
      if (parsed.verb === 'delete' && parsed.entity) {
        pendingRefreshEntity.value = parsed.entity
      }

      // Handle redirect
      if (data.redirect) {
        addOutput('output', `{link:${data.redirect}}‚Üí Open in GUI{/}`)
      }

      // Update active company after switch
      if (parsed.entity === 'company' && parsed.verb === 'switch') {
        const payload = data.data || {}
        activeCompany.value = {
          id: payload.id || '',
          name: payload.name || '',
          slug: payload.slug || '',
          user_count: payload.user_count,
          base_currency: payload.base_currency,
          status: payload.status,
        }
      }
    } else {
      const friendly = normalizePermissionError(data.message)
      addOutput('error', `{error}‚úó{/} ${friendly}`)
      if (data.errors) {
        Object.entries(data.errors).forEach(([field, messages]) => {
          addOutput('error', `{error}  ${field}:{/} ${(messages as string[]).join(', ')}`)
        })
      }
    }
  } catch (e) {
    addOutput('error', `{error}‚úó{/} Network error: ${e instanceof Error ? e.message : 'Unknown'}`)
  } finally {
    executing.value = false
    const refreshEntity = pendingRefreshEntity.value
    pendingRefreshEntity.value = null
    focusInput()
    if (refreshEntity) {
      input.value = `${refreshEntity} list`
      execute()
    }
  }
}

function handleKeydown(e: KeyboardEvent) {
  if (!props.visible) return

  if (showSubPrompt.value) {
    if (e.key === 'Escape') {
      e.preventDefault()
      closeSubPrompt()
    }
    return
  }

  // Escape - close
  if (e.key === 'Escape') {
    if (showSuggestions.value) {
      showSuggestions.value = false
    } else {
      close()
    }
    return
  }

  // Enter - execute or accept suggestion
  if (e.key === 'Enter') {
    if (showSuggestions.value && suggestions.value.length > 0) {
      e.preventDefault()
      acceptSuggestion()
    } else {
      execute()
    }
    return
  }

  // Tab - accept suggestion or execute complete command; keep focus inside palette
  if (e.key === 'Tab') {
    e.preventDefault()
    if (showSuggestions.value && suggestions.value.length > 0) {
      acceptSuggestion()
      return
    }
    const parsedCmd = parsed.value
    if (
      parsedCmd.entity &&
      parsedCmd.verb &&
      parsedCmd.errors.length === 0
    ) {
      const noFlags = Object.keys(parsedCmd.flags || {}).length === 0
      if (parsedCmd.complete || noFlags) {
        execute()
      } else {
        focusInput()
      }
    } else {
      focusInput()
    }
    return
  }

  // Arrow navigation
  if (e.key === 'ArrowUp') {
    e.preventDefault()
    if (showSuggestions.value) {
      suggestionIndex.value = Math.max(0, suggestionIndex.value - 1)
    } else if (tableState.value && tableState.value.rows.length > 0) {
      // Navigate table rows
      const newIndex = Math.max(0, tableState.value.selectedRowIndex - 1)
      tableState.value.selectedRowIndex = newIndex
    } else if (history.value.length && historyIndex.value < history.value.length - 1) {
      historyIndex.value++
      input.value = history.value[historyIndex.value]
    }
    return
  }

  if (e.key === 'ArrowDown') {
    e.preventDefault()
    if (showSuggestions.value) {
      suggestionIndex.value = Math.min(suggestions.value.length - 1, suggestionIndex.value + 1)
    } else if (tableState.value && tableState.value.rows.length > 0) {
      // Navigate table rows
      const newIndex = Math.min(tableState.value.rows.length - 1, tableState.value.selectedRowIndex + 1)
      tableState.value.selectedRowIndex = newIndex
    } else if (historyIndex.value > 0) {
      historyIndex.value--
      input.value = history.value[historyIndex.value]
    } else if (historyIndex.value === 0) {
      historyIndex.value = -1
      input.value = ''
    }
    return
  }

  // Number keys (0-9) - trigger quick actions
  if (quickActions.value.length > 0 && /^[0-9]$/.test(e.key)) {
    const action = quickActions.value.find(a => a.key === e.key)
    if (action) {
      e.preventDefault()
      handleQuickAction(action)
      return
    }
  }

  // Ctrl+L - clear
  if (e.key === 'l' && e.ctrlKey) {
    e.preventDefault()
    output.value = []
    return
  }

  // Ctrl+U - clear input
  if (e.key === 'u' && e.ctrlKey) {
    e.preventDefault()
    input.value = ''
    return
  }
}

function acceptSuggestion() {
  const suggestion = suggestions.value[suggestionIndex.value] || suggestions.value[0]
  if (!suggestion) return

  // Use the value from the suggestion
  input.value = suggestion.value
  showSuggestions.value = false
  nextTick(() => inputEl.value?.focus())
}

function selectSuggestion(index: number) {
  suggestionIndex.value = index
  acceptSuggestion()
}

function addToHistory(cmd: string) {
  history.value = [cmd, ...history.value.filter(h => h !== cmd)].slice(0, 100)
  historyIndex.value = -1
  saveHistory()
}

function loadHistory(): string[] {
  try {
    return JSON.parse(localStorage.getItem('palette-history') || '[]')
  } catch {
    return []
  }
}

function saveHistory() {
  try {
    localStorage.setItem('palette-history', JSON.stringify(history.value))
  } catch { /* ignore */ }
}

function getCsrfToken(): string {
  return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
}

function generateIdemKey(parsed: ParsedCommand): string {
  const parts = [parsed.entity, parsed.verb, Date.now(), JSON.stringify(parsed.flags)]
  return btoa(parts.join('|')).substring(0, 32)
}

function needsCompanyContext(parsed: ParsedCommand): boolean {
  const key = `${parsed.entity}.${parsed.verb}`
  const globalCommands = new Set([
    'company.list',
    'company.create',
    'company.switch',
    'help',
    'clear',
  ])
  return !globalCommands.has(key)
}

function normalizePermissionError(message?: string): string {
  if (!message) return 'Command failed'
  if (message.includes('There is no permission named')) {
    return `${message} (permissions cache likely stale ‚Äî run app:sync-permissions and app:sync-role-permissions)`
  }
  return message
}

function getRequestCompanySlug(parsed: ParsedCommand): string {
  const flags = parsed.flags as Record<string, unknown>
  const fromFlags = ['slug', 'company', 'id'].map((key) => {
    const val = flags?.[key]
    return typeof val === 'string' ? val.trim() : ''
  }).find(Boolean) || ''

  return companySlug.value || fromFlags || getSlugFromTableState()
}

function getSlugFromTableState(): string {
  const state = tableState.value
  if (!state) return ''

  const rowIndex = state.selectedRowIndex
  if (rowIndex < 0 || rowIndex >= state.rows.length) return ''

  const slugIndex = state.headers.findIndex(h => h.toLowerCase().replace(/\s+/g, '') === 'slug')
  if (slugIndex === -1) return ''

  return state.rows[rowIndex]?.[slugIndex] || ''
}

// Handle quick action click
function handleQuickAction(action: QuickAction) {
  // Check if action needs row selection
  if (action.needsRow && (!tableState.value || tableState.value.selectedRowIndex < 0)) {
    return
  }

  // Check if action needs sub-prompt
  if (action.prompt) {
    subPromptAction.value = action
    subPromptInput.value = ''
    showSubPrompt.value = true
    nextTick(() => subPromptInputEl.value?.focus())
    return
  }

  // Execute directly
  const resolved = resolveQuickActionCommand(action.command, tableState.value)
  if (resolved) {
    input.value = resolved
    execute()
  }
}

// Select row in table
function selectRow(rowIndex: number) {
  if (tableState.value) {
    tableState.value.selectedRowIndex = rowIndex
  }
  focusInput()
}

// Close sub-prompt modal
function closeSubPrompt() {
  showSubPrompt.value = false
  subPromptAction.value = null
  subPromptInput.value = ''
  focusInput()
}

// Confirm sub-prompt and execute
function confirmSubPrompt() {
  if (!subPromptAction.value || !subPromptInput.value.trim()) return

  // Resolve command with row data first
  let resolved = resolveQuickActionCommand(subPromptAction.value.command, tableState.value)

  // If command still has placeholders or is null, use the base command
  if (!resolved) {
    resolved = subPromptAction.value.command
  }

  // Append the user input
  const finalCommand = `${resolved} ${subPromptInput.value.trim()}`

  // Execute
  input.value = finalCommand
  closeSubPrompt()
  execute()
}

// Click outside to close suggestions
function handleClickOutside(e: MouseEvent) {
  const target = e.target as HTMLElement
  if (!target.closest('.palette-autocomplete') && !target.closest('.palette-input')) {
    showSuggestions.value = false
  }
}

onMounted(() => {
  document.addEventListener('click', handleClickOutside)
})

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside)
  document.removeEventListener('keydown', handleKeydown)
})

function focusInput() {
  nextTick(() => inputEl.value?.focus())
}
</script>

<template>
  <Teleport to="body">
    <!-- Backdrop -->
    <div v-if="visible" class="palette-backdrop" @click="close" />

    <!-- Palette -->
    <div v-if="visible" class="palette">
      <!-- Header - minimal, just company context -->
      <div class="palette-header">
        <span class="palette-company">
          <span class="palette-company-icon">‚óè</span>
          {{ activeCompany?.name || 'No company' }}
        </span>
        <div v-if="activeCompany" class="palette-company-meta">
          <span class="palette-chip">Slug: {{ activeCompany.slug }}</span>
          <span v-if="activeCompany.id" class="palette-chip">ID: {{ activeCompany.id }}</span>
          <span v-if="activeCompany.user_count !== undefined" class="palette-chip">Users: {{ activeCompany.user_count }}</span>
        </div>
        <div class="palette-header-right">
          <span class="palette-shortcut">Esc to close</span>
        </div>
      </div>

      <!-- Main content area with sidebar -->
      <div class="palette-body">
        <!-- Main output and input area -->
        <div class="palette-main">
          <!-- Output -->
          <div ref="outputEl" class="palette-output">
        <template v-if="output.length === 0">
          <div class="palette-empty">
            Type a command or <span class="palette-cmd">help</span> for available commands
          </div>
        </template>
        <template v-for="(line, i) in output" :key="i">
          <!-- Table with row selection -->
          <div v-if="line.type === 'table'" class="palette-table">
            <div class="table-wrapper">
              <!-- Table headers -->
              <div v-if="line.headers && line.headers.length" class="table-header">
                <div
                  v-for="(header, colIndex) in line.headers"
                  :key="colIndex"
                  class="table-cell table-cell--header"
                >
                  {{ header }}
                </div>
              </div>
              <!-- Table rows -->
              <div
                v-for="(row, rowIndex) in (line.content as string[][])"
                :key="rowIndex"
                class="table-row"
                :class="{
                  'table-row--selected': tableState && i === output.length - 1 && rowIndex === tableState.selectedRowIndex
                }"
                @click="selectRow(rowIndex)"
              >
                <div
                  v-for="(cell, colIndex) in row"
                  :key="colIndex"
                  class="table-cell"
                >
                  {{ cell }}
                </div>
              </div>
              <!-- Table footer -->
              <div v-if="line.footer" class="table-footer">
                {{ line.footer }}
              </div>
            </div>
          </div>
          <!-- Text lines -->
          <div
            v-else
            class="palette-line"
            :class="{
              'palette-line--input': line.type === 'input',
              'palette-line--error': line.type === 'error',
              'palette-line--success': line.type === 'success',
            }"
            v-html="formatText(String(line.content))"
          ></div>
        </template>
      </div>

      <!-- Input area -->
      <div class="palette-input-area">
        <!-- Autocomplete dropdown (above input) -->
        <div v-if="showSuggestions && suggestions.length" class="palette-autocomplete">
          <div
            v-for="(suggestion, index) in suggestions"
            :key="suggestion.value"
            class="palette-autocomplete-item"
            :class="{ 'palette-autocomplete-item--selected': index === suggestionIndex }"
            @click="selectSuggestion(index)"
            @mouseenter="suggestionIndex = index"
          >
            <span class="suggestion-icon">{{ suggestion.icon || 'üì¶' }}</span>
            <div class="suggestion-content">
              <span class="suggestion-label">{{ suggestion.label }}</span>
              <span v-if="suggestion.description" class="suggestion-desc">{{ suggestion.description }}</span>
            </div>
            <kbd v-if="index === suggestionIndex">Tab</kbd>
          </div>
        </div>

        <!-- Input row -->
        <div class="palette-input-row">
          <span class="palette-prompt" :class="{ 'palette-prompt--busy': executing }">
            {{ executing ? '‚ãØ' : '‚ùØ' }}
          </span>
          <div class="palette-input-container">
            <input
              ref="inputEl"
              v-model="input"
              type="text"
              class="palette-input"
              :disabled="executing"
              placeholder="Type a command..."
              autocomplete="off"
              autocorrect="off"
              autocapitalize="off"
              spellcheck="false"
            />
            <span
              v-if="placeholderHint"
              class="palette-placeholder-hint"
              :style="{ '--typed-text-width': typedTextWidth }"
            >
              {{ placeholderHint }}
            </span>
          </div>
          <div v-if="executing" class="palette-loading">
            <div class="palette-spinner"></div>
            <span class="palette-loading-text">Executing...</span>
          </div>
        </div>

        <!-- Helper text -->
        <div class="palette-helper">
          <template v-if="showSuggestions">
            <span><kbd>‚Üë‚Üì</kbd> navigate</span>
            <span><kbd>Tab</kbd> accept</span>
          </template>
          <template v-else>
            <span><kbd>Enter</kbd> run</span>
            <span><kbd>‚Üë‚Üì</kbd> history</span>
            <span><kbd>Ctrl+L</kbd> clear</span>
          </template>
        </div>

        <!-- Parsed status bar -->
        <div v-if="input.trim()" class="palette-parsed">
          <span 
            class="palette-parsed__pill" 
            :class="{ 'palette-parsed__pill--valid': parsed.entity }"
          >
            {{ parsed.entity || 'entity' }}
          </span>
          <span class="palette-parsed__dot">.</span>
          <span 
            class="palette-parsed__pill palette-parsed__pill--verb"
            :class="{ 'palette-parsed__pill--valid': parsed.verb }"
          >
            {{ parsed.verb || 'verb' }}
          </span>
          
          <template v-if="hasFlags">
            <span class="palette-parsed__flags">
              <span 
                v-for="[key, val] in flagEntries" 
                :key="key" 
                class="palette-parsed__flag"
              >
                --{{ key }}={{ val }}
              </span>
            </span>
          </template>

          <span v-if="parsed.errors.length" class="palette-parsed__error">
            ‚úó {{ parsed.errors[0] }}
          </span>
          <span v-else-if="parsed.complete" class="palette-parsed__ready">
            ‚úì ready
          </span>
        </div>
      </div>
        </div>

        <!-- Quick Actions Sidebar -->
        <div v-if="quickActions.length > 0" class="palette-sidebar">
          <div class="sidebar-header">
            Quick Actions
            <span v-if="tableState" class="sidebar-debug">
              ({{ tableState.entity }}.{{ tableState.verb }})
            </span>
          </div>
          <div class="sidebar-actions">
            <div
              v-for="action in quickActions"
              :key="action.key"
              class="sidebar-action"
              :class="{
                'sidebar-action--needs-row': action.needsRow && !tableState,
                'sidebar-action--disabled': action.needsRow && (!tableState || tableState.selectedRowIndex < 0)
              }"
              @click="handleQuickAction(action)"
            >
              <span class="action-key">{{ action.key }}</span>
              <span class="action-label">{{ getQuickActionLabel(action, tableState) }}</span>
            </div>
        </div>
        <div class="sidebar-hint">
          Press the shown number keys (0-9)
          <template v-if="tableState">
            <br />
            <span class="hint-small">Use ‚Üë‚Üì to select row</span>
          </template>
        </div>
        </div>
      </div>
    </div>

    <!-- Sub-Prompt Modal -->
    <div v-if="showSubPrompt && subPromptAction" class="subprompt-backdrop" @click="closeSubPrompt">
      <div class="subprompt-modal" @click.stop>
        <div class="subprompt-header">
          <span class="subprompt-title">{{ subPromptAction.label }}</span>
          <button class="subprompt-close" @click="closeSubPrompt">‚úï</button>
        </div>
        <div class="subprompt-body">
          <p class="subprompt-prompt">{{ subPromptAction.prompt }}</p>
          <input
            ref="subPromptInputEl"
            v-model="subPromptInput"
            type="text"
            class="subprompt-input"
            placeholder="Enter value..."
            @keydown.enter="confirmSubPrompt"
            @keydown.esc="closeSubPrompt"
          />
        </div>
        <div class="subprompt-footer">
          <button class="subprompt-btn subprompt-btn--cancel" @click="closeSubPrompt">
            Cancel
          </button>
          <button class="subprompt-btn subprompt-btn--confirm" @click="confirmSubPrompt">
            Confirm
          </button>
        </div>
      </div>
    </div>
  </Teleport>
</template>

<style scoped>
/* Single dark theme - no switching */
.palette-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.6);
  z-index: 9998;
}

.palette {
  position: fixed;
  top: 8vh;
  left: 50%;
  transform: translateX(-50%);
  width: 1100px;
  max-width: calc(100vw - 40px);
  max-height: 80vh;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 10px;
  font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Consolas', monospace;
  font-size: 14px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  box-shadow:
    0 0 0 1px rgba(255, 255, 255, 0.05),
    0 20px 50px rgba(0, 0, 0, 0.5);
  overflow: hidden;
}

/* Body with sidebar */
.palette-body {
  display: flex;
  flex: 1;
  min-height: 0;
}

.palette-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
}

/* Header */
.palette-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: #1e293b;
  border-bottom: 1px solid #334155;
  font-size: 13px;
}

.palette-company {
  display: flex;
  align-items: center;
  gap: 8px;
  color: #e2e8f0;
  font-weight: 500;
}

.palette-company-icon {
  color: #22d3ee;
  font-size: 10px;
}

.palette-company-meta {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
  margin-left: 12px;
}

.palette-chip {
  background: rgba(255, 255, 255, 0.06);
  border: 1px solid rgba(255, 255, 255, 0.1);
  padding: 3px 8px;
  border-radius: 6px;
  color: #cbd5e1;
  font-size: 11px;
}

.palette-header-right {
  display: flex;
  align-items: center;
  gap: 12px;
}

.palette-shortcut {
  color: #64748b;
  font-size: 12px;
}

/* Output */
.palette-output {
  flex: 1;
  overflow-y: auto;
  padding: 12px 14px;
  min-height: 120px;
  max-height: 400px;
}

.palette-output::-webkit-scrollbar {
  width: 6px;
}

.palette-output::-webkit-scrollbar-track {
  background: transparent;
}

.palette-output::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 3px;
}

.palette-output::-webkit-scrollbar-thumb:hover {
  background: #475569;
}

.palette-empty {
  color: #64748b;
  text-align: center;
  padding: 40px 20px;
}

.palette-cmd {
  color: #22d3ee;
  background: rgba(34, 211, 238, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
}

.palette-line {
  color: #e2e8f0;
  line-height: 1.7;
  white-space: pre-wrap;
  word-break: break-word;
}

.palette-line--input {
  color: #22d3ee;
}

.palette-line--error {
  color: #f43f5e;
}

.palette-line--success {
  color: #10b981;
}

.palette-table {
  margin: 8px 0;
}

.palette-table pre {
  margin: 0;
  color: #e2e8f0;
  font-family: inherit;
  font-size: 13px;
  line-height: 1.5;
  overflow-x: auto;
}

/* Custom table with row selection */
.table-wrapper {
  border: 1px solid #334155;
  border-radius: 6px;
  overflow: hidden;
}

.table-header {
  display: flex;
  background: rgba(34, 211, 238, 0.1);
  border-bottom: 1px solid #334155;
}

.table-row {
  display: flex;
  border-bottom: 1px solid #334155;
  cursor: pointer;
  transition: background 0.1s;
}

.table-row:last-child {
  border-bottom: none;
}

.table-row:hover {
  background: rgba(34, 211, 238, 0.05);
}

.table-row--selected {
  background: rgba(34, 211, 238, 0.15) !important;
  border-left: 3px solid #22d3ee;
}

.table-cell {
  flex: 1;
  padding: 8px 12px;
  color: #e2e8f0;
  font-size: 12px;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.table-cell--header {
  font-weight: 600;
  color: #22d3ee;
  text-transform: uppercase;
  font-size: 11px;
  letter-spacing: 0.5px;
}

.table-footer {
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.2);
  border-top: 1px solid #334155;
  color: #64748b;
  font-size: 11px;
  text-align: right;
}

/* Input area */
.palette-input-area {
  position: relative;
  border-top: 1px solid #334155;
  background: #1e293b;
}

.palette-input-row {
  display: flex;
  align-items: center;
  padding: 12px 14px;
}

.palette-prompt {
  color: #22d3ee;
  margin-right: 10px;
  font-weight: 600;
  transition: color 0.15s;
  flex-shrink: 0;
}

.palette-prompt--busy {
  color: #f59e0b;
}

.palette-input-container {
  position: relative;
  flex: 1;
  min-width: 0;
}

.palette-input {
  width: 100%;
  background: transparent;
  border: none;
  outline: none;
  color: #e2e8f0;
  font: inherit;
  caret-color: #22d3ee;
  position: relative;
  z-index: 2;
}

.palette-input::placeholder {
  color: #475569;
}

.palette-input:disabled {
  opacity: 0.5;
}

.palette-placeholder-hint {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: #475569;
  opacity: 0.4;
  white-space: nowrap;
  font: inherit;
  z-index: 1;
  padding-left: var(--typed-text-width, 0);
}

/* Helper */
.palette-helper {
  display: flex;
  gap: 16px;
  padding: 0 14px 10px;
  font-size: 11px;
  color: #64748b;
}

.palette-helper kbd {
  display: inline-block;
  background: rgba(255, 255, 255, 0.08);
  padding: 1px 5px;
  border-radius: 3px;
  margin-right: 4px;
  font-family: inherit;
  font-size: 10px;
}

/* Autocomplete */
.palette-autocomplete {
  position: absolute;
  bottom: 100%;
  left: 0;
  right: 0;
  background: #1e293b;
  border: 1px solid #334155;
  border-bottom: none;
  border-radius: 8px 8px 0 0;
  max-height: 220px;
  overflow-y: auto;
  box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3);
}

.palette-autocomplete-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 14px;
  color: #e2e8f0;
  cursor: pointer;
  transition: background 0.1s;
}

.palette-autocomplete-item:hover,
.palette-autocomplete-item--selected {
  background: rgba(34, 211, 238, 0.1);
}

.palette-autocomplete-item--selected .suggestion-label {
  color: #22d3ee;
}

.suggestion-icon {
  font-size: 16px;
  flex-shrink: 0;
  width: 20px;
  text-align: center;
}

.suggestion-content {
  flex: 1;
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.suggestion-label {
  font-weight: 500;
  color: #e2e8f0;
  font-size: 13px;
}

.suggestion-desc {
  font-size: 11px;
  color: #64748b;
  line-height: 1.4;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.palette-autocomplete-item kbd {
  font-size: 10px;
  padding: 2px 6px;
  background: rgba(34, 211, 238, 0.2);
  border-radius: 3px;
  color: #22d3ee;
  flex-shrink: 0;
}

/* Parsed status bar */
.palette-parsed {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 8px 14px;
  border-top: 1px solid #334155;
  background: rgba(0, 0, 0, 0.2);
  font-size: 12px;
  flex-wrap: wrap;
}

.palette-parsed__pill {
  padding: 3px 8px;
  background: rgba(100, 116, 139, 0.2);
  border: 1px solid rgba(100, 116, 139, 0.3);
  border-radius: 4px;
  color: #64748b;
  font-family: inherit;
}

.palette-parsed__pill--valid {
  background: rgba(34, 211, 238, 0.1);
  border-color: rgba(34, 211, 238, 0.3);
  color: #22d3ee;
}

.palette-parsed__pill--verb.palette-parsed__pill--valid {
  background: rgba(99, 102, 241, 0.1);
  border-color: rgba(99, 102, 241, 0.3);
  color: #a5b4fc;
}

.palette-parsed__dot {
  color: #475569;
  font-weight: 600;
}

.palette-parsed__flags {
  display: flex;
  gap: 6px;
  margin-left: 8px;
  flex-wrap: wrap;
}

.palette-parsed__flag {
  padding: 2px 6px;
  background: rgba(245, 158, 11, 0.1);
  border: 1px solid rgba(245, 158, 11, 0.25);
  border-radius: 4px;
  color: #fbbf24;
  font-size: 11px;
}

.palette-parsed__error {
  margin-left: auto;
  color: #f43f5e;
  font-size: 11px;
}

.palette-parsed__ready {
  margin-left: auto;
  color: #10b981;
  font-size: 11px;
}

/* Loading indicator */
.palette-loading {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: 12px;
  color: #f59e0b;
  font-size: 13px;
}

.palette-spinner {
  width: 14px;
  height: 14px;
  border: 2px solid rgba(34, 211, 238, 0.2);
  border-top-color: #22d3ee;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.palette-loading-text {
  color: #22d3ee;
  font-size: 12px;
}

/* Semantic formatting classes */
.fmt-success {
  color: #10b981;
}

.fmt-error {
  color: #f43f5e;
}

.fmt-warning {
  color: #f59e0b;
}

.fmt-accent {
  color: #22d3ee;
}

.fmt-primary {
  color: #6366f1;
}

.fmt-secondary {
  color: #64748b;
}

.fmt-dim {
  opacity: 0.5;
}

.fmt-code {
  background: rgba(34, 211, 238, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
  font-family: inherit;
  font-size: 13px;
}

.fmt-link {
  color: #22d3ee;
  text-decoration: none;
  border-bottom: 1px dotted #22d3ee;
  cursor: pointer;
}

.fmt-link:hover {
  text-decoration: underline;
  border-bottom-style: solid;
}

/* Quick Actions Sidebar */
.palette-sidebar {
  width: 260px;
  background: #1e293b;
  border-left: 1px solid #334155;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
}

.sidebar-header {
  padding: 12px 14px;
  font-size: 12px;
  font-weight: 600;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid #334155;
}

.sidebar-debug {
  display: block;
  font-size: 10px;
  color: #fbbf24;
  text-transform: none;
  margin-top: 4px;
  font-weight: normal;
}

.sidebar-actions {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.sidebar-action {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  margin-bottom: 6px;
  background: rgba(34, 211, 238, 0.05);
  border: 1px solid rgba(34, 211, 238, 0.2);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s;
}

.sidebar-action:hover {
  background: rgba(34, 211, 238, 0.1);
  border-color: rgba(34, 211, 238, 0.3);
}

.sidebar-action--disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.sidebar-action--disabled:hover {
  background: rgba(34, 211, 238, 0.05);
  border-color: rgba(34, 211, 238, 0.2);
}

.action-key {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  background: rgba(34, 211, 238, 0.2);
  color: #22d3ee;
  border-radius: 4px;
  font-weight: 600;
  font-size: 13px;
  flex-shrink: 0;
}

.action-label {
  flex: 1;
  color: #e2e8f0;
  font-size: 12px;
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.sidebar-hint {
  padding: 12px 14px;
  border-top: 1px solid #334155;
  font-size: 11px;
  color: #64748b;
  line-height: 1.5;
}

.hint-small {
  font-size: 10px;
  opacity: 0.7;
}

/* Sub-Prompt Modal */
.subprompt-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.subprompt-modal {
  width: 480px;
  max-width: calc(100vw - 40px);
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 8px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
  font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Consolas', monospace;
}

.subprompt-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 18px;
  border-bottom: 1px solid #334155;
}

.subprompt-title {
  font-size: 14px;
  font-weight: 600;
  color: #e2e8f0;
}

.subprompt-close {
  width: 28px;
  height: 28px;
  background: transparent;
  border: none;
  color: #64748b;
  font-size: 18px;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.subprompt-close:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #e2e8f0;
}

.subprompt-body {
  padding: 20px 18px;
}

.subprompt-prompt {
  margin: 0 0 14px 0;
  font-size: 13px;
  color: #94a3b8;
  line-height: 1.5;
}

.subprompt-input {
  width: 100%;
  padding: 12px 14px;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #e2e8f0;
  font-family: inherit;
  font-size: 14px;
  outline: none;
  transition: border-color 0.15s;
}

.subprompt-input:focus {
  border-color: #22d3ee;
}

.subprompt-input::placeholder {
  color: #475569;
}

.subprompt-footer {
  display: flex;
  gap: 10px;
  padding: 16px 18px;
  border-top: 1px solid #334155;
  justify-content: flex-end;
}

.subprompt-btn {
  padding: 8px 16px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s;
  border: none;
}

.subprompt-btn--cancel {
  background: transparent;
  color: #64748b;
  border: 1px solid #334155;
}

.subprompt-btn--cancel:hover {
  background: rgba(255, 255, 255, 0.05);
  color: #94a3b8;
}

.subprompt-btn--confirm {
  background: #22d3ee;
  color: #0f172a;
}

.subprompt-btn--confirm:hover {
  background: #06b6d4;
}
</style>


===== build/app/Services/CommandBus.php =====
<?php

namespace App\Services;

use App\Contracts\PaletteAction;
use Illuminate\Auth\Access\AuthorizationException;
use Illuminate\Support\Facades\Validator;
use InvalidArgumentException;

class CommandBus
{
    /**
     * @var array<string, class-string>
     */
    private array $map;

    public function __construct(?array $map = null)
    {
        $this->map = $map
            ?? config('command-bus')
            ?? config('command_bus')
            ?? $this->fallbackMap();
    }

    /**
     * Dispatch a command by name.
     */
    public function dispatch(string $action, array $params = [], $user = null, bool $skipPermission = false): array
    {
        $handler = $this->resolveHandler($action);

        $rules = $handler->rules();
        if (! empty($rules)) {
            $params = Validator::make($params, $rules)->validate();
        }

        $permission = $handler->permission();
        if ($permission && ! $skipPermission && $user && method_exists($user, 'hasCompanyPermission')) {
            if (! $user->hasCompanyPermission($permission)) {
                throw new AuthorizationException("Permission denied: {$permission}");
            }
        }

        return $handler->handle($params);
    }

    /**
     * List registered command names.
     *
     * @return array<int, string>
     */
    public function registered(): array
    {
        return array_keys($this->map);
    }

    /**
     * Check if a command is registered and its handler class is loadable.
     */
    public function has(string $action): bool
    {
        return isset($this->map[$action]) && class_exists($this->map[$action]);
    }

    private function resolveHandler(string $action): PaletteAction
    {
        $class = $this->map[$action] ?? null;
        if (! $class) {
            throw new InvalidArgumentException("Unknown command: {$action}");
        }

        if (! class_exists($class)) {
            throw new InvalidArgumentException("Command handler class not found: {$class}");
        }

        $handler = app($class);
        if (! $handler instanceof PaletteAction) {
            throw new InvalidArgumentException("Invalid handler for command: {$action}");
        }

        return $handler;
    }

    private function fallbackMap(): array
    {
        return [
            'company.create' => \App\Actions\Company\CreateAction::class,
            'company.list' => \App\Actions\Company\IndexAction::class,
            'company.switch' => \App\Actions\Company\SwitchAction::class,
            'company.view' => \App\Actions\Company\ViewAction::class,
            'company.delete' => \App\Actions\Company\DeleteAction::class,
            'user.invite' => \App\Actions\User\InviteAction::class,
            'user.list' => \App\Actions\User\IndexAction::class,
            'user.assign-role' => \App\Actions\User\AssignRoleAction::class,
            'user.remove-role' => \App\Actions\User\RemoveRoleAction::class,
            'user.deactivate' => \App\Actions\User\DeactivateAction::class,
            'user.delete' => \App\Actions\User\DeleteAction::class,
            'role.list' => \App\Actions\Role\IndexAction::class,
            'role.assign' => \App\Actions\Role\AssignPermissionAction::class,
            'role.revoke' => \App\Actions\Role\RevokePermissionAction::class,
        ];
    }
}


===== build/app/Http/Controllers/CommandController.php =====
<?php

namespace App\Http\Controllers;

use App\Facades\CompanyContext;
use App\Services\CommandBus;
use Illuminate\Http\JsonResponse;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class CommandController extends Controller
{
    public function __invoke(Request $request): JsonResponse
    {
        $action = $request->header('X-Action');
        $commandBus = app(CommandBus::class);
        $debugContext = $this->debugContext($request, $action, null);

        if (! $action || ! preg_match('/^[a-z]+\.[a-z-]+$/', $action)) {
            return $this->error('BAD_REQUEST', 'Invalid or missing X-Action header', 400, $debugContext);
        }

        if (! $commandBus->has($action)) {
            return $this->error('NOT_FOUND', "Unknown command: {$action}", 404, [
                ...$debugContext,
                'registered_actions' => $commandBus->registered(),
            ]);
        }

        $company = CompanyContext::getCompany();
        $debugContext['company_id'] = $company?->id;

        $companyOptionalCommands = [
            'company.list',
            'company.create',
            'company.switch',
            'company.view',
            'company.delete',
        ];

        if (! $company && ! in_array($action, $companyOptionalCommands)) {
            return $this->error('BAD_REQUEST', 'Company context required. Set X-Company-Slug header.', 400, $debugContext);
        }

        $idemKey = $request->header('X-Idempotency-Key');
        $isQuery = str_ends_with($action, '.list') ||
                   str_ends_with($action, '.view') ||
                   str_starts_with($action, 'report.');

        if ($idemKey && ! $isQuery) {
            $previous = $this->checkIdempotency($idemKey);
            if ($previous) {
                return response()->json([
                    'ok' => true,
                    'replayed' => true,
                    ...$previous,
                    ...($this->includeDebug() ? ['debug' => $debugContext] : []),
                ], 200);
            }
        }

        try {
            $params = $request->input('params', []);
            $skipPermission = $company === null && in_array($action, $companyOptionalCommands);
            $result = $commandBus->dispatch($action, $params, $request->user(), $skipPermission);

            if ($idemKey && ! $isQuery) {
                $this->storeIdempotency($idemKey, $result);
            }

            return $this->formatResponse($result, $action);

        } catch (\Illuminate\Validation\ValidationException $e) {
            return response()->json([
                'ok' => false,
                'code' => 'VALIDATION',
                'message' => 'Validation failed',
                'errors' => $e->errors(),
            ], 422);

        } catch (\Illuminate\Auth\Access\AuthorizationException $e) {
            return response()->json([
                'ok' => false,
                'code' => 'FORBIDDEN',
                'message' => $e->getMessage(),
            ], 403);

        } catch (\Illuminate\Database\Eloquent\ModelNotFoundException $e) {
            return response()->json([
                'ok' => false,
                'code' => 'NOT_FOUND',
                'message' => 'Record not found',
            ], 404);

        } catch (\Exception $e) {
            Log::error("Command execution failed: {$action}", [
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString(),
                'params' => $request->input('params'),
                'user' => $request->user()?->id,
                'company' => $company?->id,
            ]);

            return $this->error(
                'SERVER_ERROR',
                app()->environment('production') ? 'An error occurred' : $e->getMessage(),
                500,
                $debugContext + ['exception' => $e->getMessage()]
            );
        }
    }

    private function formatResponse(array $result, string $action): JsonResponse
    {
        $isQuery = str_ends_with($action, '.list') ||
                   str_ends_with($action, '.view') ||
                   str_starts_with($action, 'report.');

        if ($isQuery) {
            return response()->json([
                'ok' => true,
                'data' => $result['data'] ?? $result,
                'meta' => $result['meta'] ?? null,
            ], 200);
        }

        return response()->json([
            'ok' => true,
            'message' => $result['message'] ?? 'Success',
            'data' => $result['data'] ?? null,
            'redirect' => $result['redirect'] ?? null,
            'undo' => $result['undo'] ?? null,
        ], 201);
    }

    private function checkIdempotency(string $key): ?array
    {
        $record = DB::table('command_idempotency')
            ->where('key', hash('sha256', $key))
            ->where('created_at', '>', now()->subHours(24))
            ->first();

        return $record ? json_decode($record->result, true) : null;
    }

    private function storeIdempotency(string $key, array $result): void
    {
        DB::table('command_idempotency')->updateOrInsert(
            ['key' => hash('sha256', $key)],
            [
                'result' => json_encode($result),
                'created_at' => now(),
            ]
        );
    }

    private function error(string $code, string $message, int $status, array $debug = []): JsonResponse
    {
        $payload = [
            'ok' => false,
            'code' => $code,
            'message' => $message,
        ];

        if ($this->includeDebug()) {
            $payload['debug'] = $debug;
            $payload['status'] = $status;
        }

        return response()->json($payload, $status);
    }

    private function debugContext(Request $request, ?string $action, $company): array
    {
        return [
            'user_id' => $request->user()?->id,
            'company_id' => $company?->id,
            'company_slug_header' => $request->header('X-Company-Slug'),
            'action' => $action,
            'params' => $request->input('params', []),
            'headers' => collect($request->headers->all())
                ->only(['x-action', 'x-company-slug', 'x-idempotency-key'])
                ->toArray(),
        ];
    }

    private function includeDebug(): bool
    {
        return config('app.debug', false) && ! app()->environment('production');
    }
}


===== build/config/command-bus.php =====
<?php

return [
    'company.create' => \App\Actions\Company\CreateAction::class,
    'company.list' => \App\Actions\Company\IndexAction::class,
    'company.switch' => \App\Actions\Company\SwitchAction::class,
    'company.view' => \App\Actions\Company\ViewAction::class,
    'company.delete' => \App\Actions\Company\DeleteAction::class,

    'user.invite' => \App\Actions\User\InviteAction::class,
    'user.list' => \App\Actions\User\IndexAction::class,
    'user.assign-role' => \App\Actions\User\AssignRoleAction::class,
    'user.remove-role' => \App\Actions\User\RemoveRoleAction::class,
    'user.deactivate' => \App\Actions\User\DeactivateAction::class,
    'user.delete' => \App\Actions\User\DeleteAction::class,

    'role.list' => \App\Actions\Role\IndexAction::class,
    'role.assign' => \App\Actions\Role\AssignPermissionAction::class,
    'role.revoke' => \App\Actions\Role\RevokePermissionAction::class,
];


===== build/app/Contracts/PaletteAction.php =====
<?php

namespace App\Contracts;

interface PaletteAction
{
    /**
     * Execute the action.
     *
     * @param array $params Validated parameters from palette
     * @return array Response with 'message', 'data', 'redirect', 'undo' keys
     * @throws \Illuminate\Validation\ValidationException
     * @throws \Illuminate\Auth\Access\AuthorizationException
     */
    public function handle(array $params): array;

    /**
     * Validation rules for this action.
     */
    public function rules(): array;

    /**
     * Permission required (null = no check).
     */
    public function permission(): ?string;
}


===== build/app/Actions/Company/CreateAction.php =====
<?php

namespace App\Actions\Company;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Facades\CompanyContext;
use App\Models\Company;
use App\Models\CompanyCurrency;
use App\Models\Role;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;
use Spatie\Permission\Models\Permission;
use Spatie\Permission\PermissionRegistrar;

class CreateAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'name' => 'required|string|max:255',
            'currency' => 'required|string|size:3',
            'industry' => 'nullable|string|max:255',
            'country' => 'nullable|string|size:2',
            'language' => 'nullable|string|size:2',
            'locale' => 'nullable|string|max:10',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_CREATE;
    }

    public function handle(array $params): array
    {
        $params['currency'] = strtoupper($params['currency']);
        $slug = Str::slug($params['name']);

        return DB::transaction(function () use ($params, $slug) {
            $company = Company::create([
                'name' => $params['name'],
                'industry' => $params['industry'] ?? null,
                'slug' => $slug,
                'country' => $params['country'] ?? null,
                'base_currency' => $params['currency'],
                'language' => $params['language'] ?? 'en',
                'locale' => $params['locale'] ?? 'en_US',
                'created_by_user_id' => Auth::id(),
                'is_active' => true,
            ]);

            CompanyCurrency::create([
                'company_id' => $company->id,
                'currency_code' => $params['currency'],
                'is_base' => true,
                'enabled_at' => now(),
            ]);

            DB::table('auth.company_user')->insert([
                'company_id' => $company->id,
                'user_id' => Auth::id(),
                'role' => 'owner',
                'invited_by_user_id' => Auth::id(),
                'joined_at' => now(),
                'is_active' => true,
                'created_at' => now(),
                'updated_at' => now(),
            ]);

            // Ensure company-scoped roles exist and carry permissions, then assign owner to creator
            CompanyContext::withContext($company, function () use ($company) {
                $this->syncRolesForCompany($company);
                CompanyContext::assignRole(Auth::user(), 'owner');
            });

            // Set as active context
            CompanyContext::setContext($company);

            return [
                'message' => "Company created: {$company->name} ({$company->slug})",
                'data' => [
                    'id' => $company->id,
                    'name' => $company->name,
                    'slug' => $company->slug,
                    'currency' => $company->base_currency,
                ],
                'redirect' => "/{$company->slug}/dashboard",
            ];
        });
    }

    private function syncRolesForCompany(Company $company): void
    {
        $matrix = config('role-permissions', []);
        if (empty($matrix)) {
            return;
        }

        $registrar = app(PermissionRegistrar::class);
        $registrar->setPermissionsTeamId($company->id);

        foreach ($matrix as $roleName => $permissionNames) {
            // Create role if missing (raw to avoid team scoping issues)
            $role = Role::where('name', $roleName)
                ->where('guard_name', 'web')
                ->where('company_id', $company->id)
                ->first();

            if (!$role) {
                $role = Role::forceCreate([
                    'id' => (string) \Illuminate\Support\Str::orderedUuid(),
                    'name' => $roleName,
                    'guard_name' => 'web',
                    'company_id' => $company->id,
                ]);
            }

            $permissionIds = Permission::whereIn('name', $permissionNames)
                ->where('guard_name', 'web')
                ->pluck('id')
                ->filter()
                ->all();

            // Manually sync permissions to avoid null IDs or team context issues
            DB::table('role_has_permissions')
                ->where('role_id', $role->id)
                ->delete();

            foreach ($permissionIds as $permissionId) {
                DB::table('role_has_permissions')->insert([
                    'permission_id' => $permissionId,
                    'role_id' => $role->id,
                ]);
            }
        }

        $registrar->forgetCachedPermissions();
    }
}


===== build/app/Actions/Company/IndexAction.php =====
<?php

namespace App\Actions\Company;

use App\Contracts\PaletteAction;
use App\Support\PaletteFormatter;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;

class IndexAction implements PaletteAction
{
    public function rules(): array
    {
        return [];
    }

    public function permission(): ?string
    {
        return null;
    }

    public function handle(array $params): array
    {
        $companies = DB::table('auth.companies as c')
            ->join('auth.company_user as cu', 'c.id', '=', 'cu.company_id')
            ->where('cu.user_id', Auth::id())
            ->where('cu.is_active', true)
            ->select('c.name', 'c.slug', 'c.base_currency', 'cu.role', 'c.is_active')
            ->orderBy('c.name')
            ->get();

        return [
            'data' => PaletteFormatter::table(
                headers: ['Name', 'Slug', 'Currency', 'Role', 'Status'],
                rows: $companies->map(fn($c) => [
                    $c->name,
                    $c->slug,
                    $c->base_currency,
                    ucfirst($c->role),
                    $c->is_active ? '{success}‚óè Active{/}' : '{secondary}‚óã Inactive{/}',
                ])->toArray(),
                footer: $companies->count() . ' companies'
            ),
        ];
    }
}


===== build/app/Actions/Company/SwitchAction.php =====
<?php

namespace App\Actions\Company;

use App\Contracts\PaletteAction;
use App\Facades\CompanyContext;
use App\Models\Company;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Str;

class SwitchAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'slug' => 'required|string',
        ];
    }

    public function permission(): ?string
    {
        return null;
    }

    public function handle(array $params): array
    {
        $company = Company::where('slug', $params['slug'])->firstOrFail();

        $membership = DB::table('auth.company_user')
            ->where('company_id', $company->id)
            ->where('user_id', Auth::id())
            ->where('is_active', true)
            ->first();

        if (!$membership) {
            throw new \Exception("You are not a member of {$company->name}");
        }

        CompanyContext::setContext($company);

        $userCount = DB::table('auth.company_user')
            ->where('company_id', $company->id)
            ->where('is_active', true)
            ->count();

        return [
            'message' => "Switched to {$company->name}",
            'data' => [
                'id' => $company->id,
                'name' => $company->name,
                'slug' => $company->slug,
                'base_currency' => $company->base_currency,
                'user_count' => $userCount,
                'status' => $company->is_active ? 'active' : 'inactive',
                'summary' => [
                    'invoices_due' => 0,
                    'open_bills' => 0,
                ],
            ],
            'redirect' => "/{$company->slug}/dashboard",
        ];
    }
}


===== build/app/Actions/Company/ViewAction.php =====
<?php

namespace App\Actions\Company;

use App\Contracts\PaletteAction;
use App\Support\PaletteFormatter;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;

class ViewAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'slug' => 'required|string',
        ];
    }

    public function permission(): ?string
    {
        return null;
    }

    public function handle(array $params): array
    {
        $company = DB::table('auth.companies as c')
            ->join('auth.company_user as cu', 'c.id', '=', 'cu.company_id')
            ->where('c.slug', $params['slug'])
            ->where('cu.user_id', Auth::id())
            ->where('cu.is_active', true)
            ->select(
                'c.id',
                'c.name',
                'c.slug',
                'c.base_currency',
                'c.country',
                'c.language',
                'c.locale',
                'c.is_active',
                'cu.role',
                'c.created_at'
            )
            ->first();

        if (!$company) {
            throw new \Exception('Company not found or you do not have access.');
        }

        $userCount = DB::table('auth.company_user')
            ->where('company_id', $company->id)
            ->where('is_active', true)
            ->count();

        return [
            'data' => PaletteFormatter::table(
                headers: ['Field', 'Value'],
                rows: [
                    ['Name', $company->name],
                    ['Slug', $company->slug],
                    ['Status', $company->is_active ? '{success}Active{/}' : '{secondary}Inactive{/}'],
                    ['Role', ucfirst($company->role)],
                    ['Base Currency', $company->base_currency],
                    ['Country', $company->country ?? '‚Äî'],
                    ['Language', $company->language ?? '‚Äî'],
                    ['Locale', $company->locale ?? '‚Äî'],
                    ['Users', (string) $userCount],
                    ['Created', optional($company->created_at)->toDateTimeString() ?? '‚Äî'],
                ],
                footer: 'Company details'
            ),
        ];
    }
}


===== build/app/Actions/Company/DeleteAction.php =====
<?php

namespace App\Actions\Company;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Facades\CompanyContext;
use App\Models\Company;
use Illuminate\Support\Facades\DB;

class DeleteAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'slug' => 'required|string',
        ];
    }

    public function permission(): ?string
    {
        // Permission check handled manually in handle() for the specific company being deleted
        return null;
    }

    public function handle(array $params): array
    {
        $company = Company::where('slug', $params['slug'])->firstOrFail();

        // Check permission in the context of the company being deleted
        $hasPermission = CompanyContext::withContext($company, function () use ($company) {
            return \Illuminate\Support\Facades\Auth::user()->hasCompanyPermission(Permissions::COMPANY_DELETE);
        });

        if (!$hasPermission) {
            throw new \Illuminate\Auth\Access\AuthorizationException('Permission denied: ' . Permissions::COMPANY_DELETE);
        }

        return DB::transaction(function () use ($company) {
            DB::table('auth.company_user')
                ->where('company_id', $company->id)
                ->update(['is_active' => false, 'updated_at' => now()]);

            $company->update(['is_active' => false]);

            $currentCompany = CompanyContext::getCompany();
            if ($currentCompany && $currentCompany->id === $company->id) {
                CompanyContext::clearContext();
            }

            return [
                'message' => "Company deleted: {$company->name}",
                'data' => ['id' => $company->id],
                'redirect' => '/dashboard',
            ];
        });
    }
}


===== build/app/Actions/User/InviteAction.php =====
<?php

namespace App\Actions\User;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Facades\CompanyContext;
use App\Models\User;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Hash;
use Illuminate\Support\Str;

class InviteAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'email' => 'required|email',
            'role' => 'nullable|string',
            'name' => 'nullable|string|max:255',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_INVITE_USER;
    }

    public function handle(array $params): array
    {
        $company = CompanyContext::requireCompany();

        $role = $params['role'] ?? 'member';

        return DB::transaction(function () use ($params, $company, $role) {
            $user = User::where('email', $params['email'])->first();

            if (!$user) {
                $user = User::create([
                    'name' => $params['name'] ?? explode('@', $params['email'])[0],
                    'email' => $params['email'],
                    'username' => Str::slug(explode('@', $params['email'])[0]) . '-' . Str::random(4),
                    'password' => Hash::make(Str::random(32)),
                ]);
            }

            $existing = DB::table('auth.company_user')
                ->where('company_id', $company->id)
                ->where('user_id', $user->id)
                ->first();

            if ($existing) {
                throw new \Exception("User {$params['email']} is already a member");
            }

            DB::table('auth.company_user')->insert([
                'company_id' => $company->id,
                'user_id' => $user->id,
                'role' => $role,
                'invited_by_user_id' => Auth::id(),
                'joined_at' => now(),
                'is_active' => true,
                'created_at' => now(),
                'updated_at' => now(),
            ]);

            CompanyContext::assignRole($user, $role);

            return [
                'message' => "User invited: {$user->email} (" . ucfirst($role) . ")",
                'data' => [
                    'id' => $user->id,
                    'email' => $user->email,
                    'name' => $user->name,
                    'role' => $role,
                ],
            ];
        });
    }
}


===== build/app/Actions/User/IndexAction.php =====
<?php

namespace App\Actions\User;

use App\Contracts\PaletteAction;
use App\Facades\CompanyContext;
use App\Support\PaletteFormatter;
use Illuminate\Support\Facades\DB;

class IndexAction implements PaletteAction
{
    public function rules(): array
    {
        return [];
    }

    public function permission(): ?string
    {
        return null;
    }

    public function handle(array $params): array
    {
        $company = CompanyContext::requireCompany();

        $users = DB::table('auth.users as u')
            ->join('auth.company_user as cu', 'u.id', '=', 'cu.user_id')
            ->where('cu.company_id', $company->id)
            ->select('u.email', 'u.name', 'cu.role', 'cu.is_active', 'cu.joined_at')
            ->orderBy('u.name')
            ->get();

        return [
            'data' => PaletteFormatter::table(
                headers: ['Email', 'Name', 'Role', 'Status', 'Joined'],
                rows: $users->map(fn($u) => [
                    $u->email,
                    $u->name,
                    ucfirst($u->role),
                    $u->is_active ? '{success}‚óè Active{/}' : '{secondary}‚óã Inactive{/}',
                    $u->joined_at ? date('M d, Y', strtotime($u->joined_at)) : '-',
                ])->toArray(),
                footer: $users->count() . ' users'
            ),
        ];
    }
}


===== build/app/Actions/User/AssignRoleAction.php =====
<?php

namespace App\Actions\User;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Facades\CompanyContext;
use App\Models\User;
use Illuminate\Support\Facades\DB;

class AssignRoleAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'email' => 'required|email',
            'role' => 'required|string',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_MANAGE_ROLES;
    }

    public function handle(array $params): array
    {
        $company = CompanyContext::requireCompany();

        $user = User::where('email', $params['email'])->firstOrFail();

        $membership = DB::table('auth.company_user')
            ->where('company_id', $company->id)
            ->where('user_id', $user->id)
            ->first();

        if (!$membership) {
            throw new \Exception("User {$params['email']} is not a member of {$company->name}");
        }

        CompanyContext::assignRole($user, $params['role']);

        return [
            'message' => "Role assigned: {$params['role']} \u2192 {$user->email}",
            'data' => [
                'user' => $user->email,
                'role' => $params['role'],
            ],
        ];
    }
}


===== build/app/Actions/User/RemoveRoleAction.php =====
<?php

namespace App\Actions\User;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Facades\CompanyContext;
use App\Models\User;

class RemoveRoleAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'email' => 'required|email',
            'role' => 'required|string',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_MANAGE_ROLES;
    }

    public function handle(array $params): array
    {
        $company = CompanyContext::requireCompany();

        $user = User::where('email', $params['email'])->firstOrFail();

        CompanyContext::removeRole($user, $params['role']);

        return [
            'message' => "Role removed: {$params['role']} \u2190 {$user->email}",
            'data' => [
                'user' => $user->email,
                'role' => $params['role'],
            ],
        ];
    }
}


===== build/app/Actions/User/DeactivateAction.php =====
<?php

namespace App\Actions\User;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Models\User;
use App\Facades\CompanyContext;
use Illuminate\Support\Facades\DB;

class DeactivateAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'email' => 'required|email',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_MANAGE_USERS;
    }

    public function handle(array $params): array
    {
        $company = CompanyContext::requireCompany();

        $user = User::where('email', $params['email'])->firstOrFail();

        DB::table('auth.company_user')
            ->where('company_id', $company->id)
            ->where('user_id', $user->id)
            ->update(['is_active' => false, 'updated_at' => now()]);

        return [
            'message' => "User deactivated: {$user->email}",
            'data' => ['user' => $user->email],
        ];
    }
}


===== build/app/Actions/User/DeleteAction.php =====
<?php

namespace App\Actions\User;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Models\User;
use App\Facades\CompanyContext;
use Illuminate\Support\Facades\DB;

class DeleteAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'email' => 'required|email',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_DELETE_USER;
    }

    public function handle(array $params): array
    {
        $company = CompanyContext::requireCompany();

        $user = User::where('email', $params['email'])->firstOrFail();

        return DB::transaction(function () use ($user, $company) {
            DB::table('auth.company_user')
                ->where('company_id', $company->id)
                ->where('user_id', $user->id)
                ->delete();

            $otherMemberships = DB::table('auth.company_user')
                ->where('user_id', $user->id)
                ->count();

            if ($otherMemberships === 0) {
                $user->delete();
                $message = "User deleted permanently: {$user->email}";
            } else {
                $message = "User removed from company: {$user->email}";
            }

            return [
                'message' => $message,
                'data' => ['user' => $user->email],
            ];
        });
    }
}


===== build/app/Actions/Role/IndexAction.php =====
<?php

namespace App\Actions\Role;

use App\Contracts\PaletteAction;
use App\Models\Role;
use App\Support\PaletteFormatter;
use App\Facades\CompanyContext;

class IndexAction implements PaletteAction
{
    public function rules(): array
    {
        return [];
    }

    public function permission(): ?string
    {
        return null;
    }

    public function handle(array $params): array
    {
        
        $company = CompanyContext::requireCompany();

        $roles = Role::with('permissions')
            ->when($company, fn($query) => $query->where(fn($inner) => $inner
                ->where('company_id', $company->id)
                ->orWhereNull('company_id')
            ))
            ->orderBy('name')
            ->get();

        return [
            'data' => PaletteFormatter::table(
                headers: ['Role', 'Permissions', 'Users'],
                rows: $roles->map(fn($r) => [
                    $r->name,
                    $r->permissions->pluck('name')->implode(', ') ?: '{secondary}None{/}',
                    $r->users()
                        ->when($company, fn($users) => $users->wherePivot('company_id', $company->id))
                        ->count(),
                ])->toArray(),
                footer: $roles->count() . ' roles'
            ),
        ];
    }
}


===== build/app/Actions/Role/AssignPermissionAction.php =====
<?php

namespace App\Actions\Role;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Models\Permission;
use App\Models\Role;
use App\Facades\CompanyContext;

class AssignPermissionAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'permission' => 'required|string',
            'role' => 'required|string',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_MANAGE_ROLES;
    }

    public function handle(array $params): array
    {
        
        $company = CompanyContext::requireCompany();

        $role = Role::where('name', $params['role'])
            ->where(fn($q) => $q->where('company_id', $company?->id)->orWhereNull('company_id'))
            ->firstOrFail();

        $permission = Permission::where('name', $params['permission'])->firstOrFail();

        $role->givePermissionTo($permission);

        return [
            'message' => "Permission assigned: {$permission->name} \u2192 {$role->name}",
            'data' => [
                'role' => $role->name,
                'permission' => $permission->name,
            ],
        ];
    }
}


===== build/app/Actions/Role/RevokePermissionAction.php =====
<?php

namespace App\Actions\Role;

use App\Constants\Permissions;
use App\Contracts\PaletteAction;
use App\Models\Permission;
use App\Models\Role;
use App\Facades\CompanyContext;

class RevokePermissionAction implements PaletteAction
{
    public function rules(): array
    {
        return [
            'permission' => 'required|string',
            'role' => 'required|string',
        ];
    }

    public function permission(): ?string
    {
        return Permissions::COMPANY_MANAGE_ROLES;
    }

    public function handle(array $params): array
    {
        
        $company = CompanyContext::requireCompany();

        $role = Role::where('name', $params['role'])
            ->where(fn($q) => $q->where('company_id', $company?->id)->orWhereNull('company_id'))
            ->firstOrFail();

        $permission = Permission::where('name', $params['permission'])->firstOrFail();

        $role->revokePermissionTo($permission);

        return [
            'message' => "Permission revoked: {$permission->name} \u2190 {$role->name}",
            'data' => [
                'role' => $role->name,
                'permission' => $permission->name,
            ],
        ];
    }
}


