===== build/resources/js/components/palette/CommandPalette.vue =====
<script setup lang="ts">
import { ref, watch, nextTick, computed, onMounted, onUnmounted } from 'vue'
import { parse } from '@/palette/parser'
import { generateSuggestions } from '@/palette/autocomplete'
import { getHelp } from '@/palette/help'
import { formatText } from '@/palette/formatter'
import { getCommandExample, resolveEntityShortcut } from '@/palette/grammar'
import { getQuickActions, resolveQuickActionCommand, getQuickActionLabel } from '@/palette/quick-actions'
import { getSchema } from '@/palette/schemas'
import { buildScaffold } from '@/palette/scaffold'
import { getFrecencyScores, recordCommandUse } from '@/palette/frecency'
import { isPresetShortcut } from '@/palette/shortcuts'
import { usePage } from '@inertiajs/vue3'
import type { ParsedCommand, Suggestion, QuickAction, TableState, OutputLine } from '@/types/palette'

const props = defineProps<{ visible: boolean }>()
const emit = defineEmits<{ 'update:visible': [v: boolean] }>()

type Stage = 'entity' | 'verb'
interface ContextRecord {
  label: string
  value: string
  meta?: string
}

// State
const input = ref('')
const output = ref<OutputLine[]>([])
const history = ref<string[]>(loadHistory())
const historyIndex = ref(-1)
const executing = ref(false)
const suggestions = ref<Suggestion[]>([])
const suggestionIndex = ref(0)
const showSuggestions = ref(false)
const awaitingConfirmation = ref<{
  original: string
  parsed: ParsedCommand
  message: string
} | null>(null)

// Quick actions state
const tableState = ref<TableState | null>(null)
const quickActions = ref<QuickAction[]>([])
const showSubPrompt = ref(false)
const subPromptAction = ref<QuickAction | null>(null)
const subPromptInput = ref('')
const pendingRefreshEntity = ref<string | null>(null)
const stage = ref<Stage>('entity')
const frecencyScores = ref<Record<string, number>>(getFrecencyScores())
const contextRecords = ref<ContextRecord[]>([])
const contextTitle = ref('')
const defaults = ref<Record<string, { value: string; source?: string }>>({})
const cursorIndex = ref(0)
const defaultsLoading = ref(false)
const scaffoldState = computed(() => {
  const schema = getSchema(parsed.value.entity, parsed.value.verb)
  const activeArg = getActiveArgFromCursor(schema)
  const flagsWithState = schema?.flags?.map(flag => ({
    ...flag,
    loading: defaultsLoading.value && !defaults.value[flag.name]?.value,
  })) || []
  return buildScaffold(parsed.value, schema ? { ...schema, flags: flagsWithState } : null, {
    companyName: activeCompany.value?.name,
    companyCurrency: activeCompany.value?.base_currency ?? activeCompany.value?.currency,
    defaults: defaults.value,
  }, activeArg)
})

const validationHint = computed(() => {
  const schema = getSchema(parsed.value.entity, parsed.value.verb)
  if (!schema) return ''
  const missing = schema.args.filter(arg => arg.required && !parsed.value.flags?.[arg.name])
  if (missing.length > 0) {
    const arg = missing[0]
    return `Need ${arg.name}${arg.hint ? ` (${arg.hint})` : ''}`
  }
  return ''
})

// Parsed command (reactive)
const parsed = computed(() => parse(input.value))

// Inline placeholder hint (ghosted text showing example)
const placeholderHint = computed(() => {
  // Don't show if suggestions are visible
  if (showSuggestions.value) return ''

  // Don't show if executing
  if (executing.value) return ''

  // Don't show if awaiting confirmation
  if (awaitingConfirmation.value) return ''

  const trimmed = input.value.trim()
  const parsedCmd = parse(trimmed)

  // Only show if we have entity + verb
  if (!parsedCmd.entity || !parsedCmd.verb) return ''

  const example = getCommandExample(parsedCmd.entity, parsedCmd.verb)

  // Only show the remaining part (what user hasn't typed yet)
  if (example && example.startsWith(trimmed)) {
    return example.slice(trimmed.length)
  }

  return ''
})

// Width of typed text for positioning ghost text
const typedTextWidth = ref('0px')

// Dynamic suggestions fetch timeout
const fetchTimeout = ref<number | null>(null)
const fetchAbort = ref<AbortController | null>(null)

const tabActionLabel = computed(() => {
  if (showSuggestions.value) return 'select'
  if (parsed.value.complete) return 'run'
  return 'select'
})

// Refs
const inputEl = ref<HTMLInputElement>()
const outputEl = ref<HTMLDivElement>()
const subPromptInputEl = ref<HTMLInputElement>()

// Company context
const page = usePage()
const initialCompany = computed(() => (page.props.auth as any)?.currentCompany)
const activeCompany = ref(initialCompany.value || null)
const companySlug = computed(() => activeCompany.value?.slug || '')

// Focus on open
watch(() => props.visible, (v) => {
  if (v) {
    nextTick(() => inputEl.value?.focus())
    document.addEventListener('keydown', handleKeydown)
  } else {
    showSuggestions.value = false
    historyIndex.value = -1
    document.removeEventListener('keydown', handleKeydown)
  }
})

// Auto-scroll output
watch(() => output.value.length, () => {
  nextTick(() => {
    if (outputEl.value) outputEl.value.scrollTop = outputEl.value.scrollHeight
  })
})

watch(parsed, (val) => {
  handleContextRecords(val)
  resolveDefaults(val)
})

// Update suggestions on input
watch(input, async (val) => {
  // Calculate text width for ghost text positioning
  if (inputEl.value) {
    const canvas = document.createElement('canvas')
    const ctx = canvas.getContext('2d')
    if (ctx) {
      const style = window.getComputedStyle(inputEl.value)
      ctx.font = style.font
      const width = ctx.measureText(val).width
      typedTextWidth.value = `${width}px`
    }
  }

  stage.value = determineStage(val)
  await refreshSuggestions(val)
}, { immediate: true })

// Watch output for table data to populate tableState
watch(output, (newOutput) => {
  const lastTable = newOutput.slice().reverse().find(line => line.type === 'table')

  if (!lastTable) {
    tableState.value = null
    return
  }

  // Get the last command that was executed
  const lastInput = newOutput.slice().reverse().find(line => line.type === 'input')
  if (!lastInput) {
    return
  }

  // Parse the command to get entity and verb
  const cmd = String(lastInput.content).replace('‚ùØ ', '')
  const parsedCmd = parse(cmd)

  if (!parsedCmd.entity || !parsedCmd.verb) {
    return
  }

  // Populate tableState
  tableState.value = {
    headers: lastTable.headers || [],
    rows: lastTable.content as string[][],
    selectedRowIndex: 0,
    entity: parsedCmd.entity,
    verb: parsedCmd.verb,
  }
}, { deep: true })

// Watch tableState to update quickActions
watch(tableState, (newState) => {
  if (!newState) {
    quickActions.value = []
    return
  }

  const actions = getQuickActions(newState.entity, newState.verb)
  quickActions.value = actions
})

function close() {
  emit('update:visible', false)
  input.value = ''
  showSuggestions.value = false
  stage.value = 'entity'
  contextRecords.value = []
  contextTitle.value = ''
  if (fetchTimeout.value) clearTimeout(fetchTimeout.value)
}

async function refreshSuggestions(val: string) {
  const trimmed = val.trim()
  const parsedCmd = parse(trimmed)
  const tokens = trimmed ? trimmed.split(/\s+/) : []
  const inferredEntity = parsedCmd.entity || resolveEntityShortcut(tokens[0] || '') || ''

  // Hide suggestions when awaiting confirmation
  if (awaitingConfirmation.value) {
    showSuggestions.value = false
    return
  }

  // Show placeholder hint instead of suggestions when both entity+verb are present and user added trailing space
  if (tokens.length === 2 && val.endsWith(' ') && parsedCmd.entity && parsedCmd.verb) {
    showSuggestions.value = false
    return
  }

  const suggestionStage: Stage = stage.value === 'verb' && inferredEntity ? 'verb' : 'entity'
  const baseSuggestions = await generateFieldSuggestions(trimmed, parsedCmd, suggestionStage, inferredEntity)

  suggestions.value = baseSuggestions
  showSuggestions.value = baseSuggestions.length > 0
  suggestionIndex.value = 0

  // If no suggestions and scaffold has a current arg, show a placeholder hint
  if (!showSuggestions.value) {
    const scaffold = scaffoldState.value
    if (scaffold?.currentArg) {
      suggestions.value = [{
        type: 'command',
        value: val,
        label: `<${scaffold.currentArg}>`,
        description: scaffold.pointerLabel,
        icon: '‚å®Ô∏è',
      }]
      showSuggestions.value = true
      suggestionIndex.value = 0
    }
  }

  if (!parsedCmd.entity || !parsedCmd.verb) return
  if (tokens.length <= 2) return

  const dynamic = await fetchDynamicSuggestions(parsedCmd.entity, parsedCmd.verb, tokens.slice(2).join(' '))
  if (dynamic.length > 0) {
    suggestions.value = [...dynamic, ...baseSuggestions].slice(0, 8)
    showSuggestions.value = true
    suggestionIndex.value = 0
  }
}

/**
 * Fetch dynamic suggestions from backend (debounced)
 */
async function fetchDynamicSuggestions(
  entity: string,
  verb: string,
  partial: string
): Promise<Suggestion[]> {
  if (fetchTimeout.value) clearTimeout(fetchTimeout.value)
  fetchAbort.value?.abort()

  return new Promise((resolve) => {
    fetchTimeout.value = window.setTimeout(async () => {
      fetchAbort.value = new AbortController()
      try {
        const params = new URLSearchParams({
          entity,
          verb,
          q: partial,
        })

        const res = await fetch(`/api/palette/suggestions?${params}`, {
          credentials: 'same-origin',
          headers: {
            'Accept': 'application/json',
            'X-Requested-With': 'XMLHttpRequest',
          },
          signal: fetchAbort.value.signal,
        })

        if (!res.ok) {
          resolve([])
          return
        }

        const data = await res.json()
        const dynamicSuggestions = (data.suggestions || []).map((s: any) => ({
          type: 'value' as const,
          value: `${entity} ${verb} ${s.value}`,
          label: s.label,
          description: s.description,
          icon: s.icon,
        }))

        resolve(dynamicSuggestions)
      } catch (e) {
        if (e instanceof DOMException && e.name === 'AbortError') {
          resolve([])
        } else {
          console.error('Failed to fetch palette suggestions:', e)
          resolve([])
        }
      }
    }, 250)
  })
}

function addOutput(type: OutputLine['type'], content: string | string[][], headers?: string[], footer?: string) {
  output.value.push({ type, content, headers, footer })
  // Keep max 200 lines
  if (output.value.length > 200) {
    output.value = output.value.slice(-200)
  }
}

function determineStage(val: string): Stage {
  const trimmed = val.trim()
  if (!trimmed) return 'entity'
  const tokens = trimmed.split(/\s+/)
  if (tokens.length === 0) return 'entity'

  const first = tokens[0]
  const isShortcut = isPresetShortcut(first)
  const resolved = resolveEntityShortcut(first)

  if ((resolved || isShortcut) && (trimmed.endsWith(' ') || tokens.length > 1)) {
    return 'verb'
  }

  return 'entity'
}

async function handleContextRecords(parsedCmd: ParsedCommand) {
  if (parsedCmd.entity === 'payment' && parsedCmd.verb === 'create') {
    contextTitle.value = 'Recent unpaid invoices'
    if (contextRecords.value.length === 0) {
      contextRecords.value = await loadRecentInvoices()
    }
    return
  }

  contextTitle.value = ''
  contextRecords.value = []
}

async function loadRecentInvoices(): Promise<ContextRecord[]> {
  try {
    const res = await fetch('/api/palette/invoices/recent', {
      credentials: 'same-origin',
      headers: {
        'Accept': 'application/json',
        'X-Requested-With': 'XMLHttpRequest',
      },
    })

    if (!res.ok) return []
    const invoices = await res.json()
    return (invoices || []).slice(0, 5).map((inv: any) => ({
      label: inv.number || inv.id,
      value: inv.number || inv.id,
      meta: inv.meta?.customer
        ? `${inv.meta.customer}${inv.meta.amount ? ` ¬∑ ${inv.meta.amount}` : ''}`
        : inv.meta?.amount,
    }))
  } catch (e) {
    console.error('Failed to load recent invoices', e)
    return []
  }
}

function applyContextRecord(record: ContextRecord) {
  const base = input.value.trim()
  const parsedCmd = parse(base)
  const entity = parsedCmd.entity || resolveEntityShortcut(base.split(/\s+/)[0] || '') || 'payment'
  const verb = parsedCmd.verb || 'create'
  input.value = `${entity} ${verb} --invoice=${record.value} `
  stage.value = 'verb'
  showSuggestions.value = false
  focusInput()
}

function applyFlagChip(flag: { name: string; value?: string }) {
  const existing = input.value.trim()
  const append = flag.value ? ` --${flag.name}=${flag.value}` : ` --${flag.name}=`
  input.value = `${existing}${append}`.trim() + ' '
  focusInput()
}

function handleCursor() {
  const el = inputEl.value
  if (el) {
    cursorIndex.value = el.selectionStart || 0
  }
}

function getActiveArgFromCursor(schema: any): string | undefined {
  if (!schema || !input.value) return undefined
  // Remove prompt parts
  const beforeCursor = input.value.slice(0, cursorIndex.value)
  const tokens = beforeCursor.trimEnd().split(/\s+/).filter(Boolean)
  // tokens[0] = entity, tokens[1] = verb, args follow
  const argIndex = Math.max(0, tokens.length - 2)
  const args = schema.args || []
  return args[argIndex]?.name
}

async function generateFieldSuggestions(
  trimmed: string,
  parsedCmd: ParsedCommand,
  stage: 'entity' | 'verb',
  inferredEntity: string
): Promise<Suggestion[]> {
  // Default grammar-based suggestions
  const base = generateSuggestions(trimmed, {
    stage,
    entity: inferredEntity,
    frecencyScores: frecencyScores.value,
  })

  const schema = getSchema(parsedCmd.entity, parsedCmd.verb)
  const currentArg = scaffoldState.value?.currentArg

  if (!schema || !currentArg) return base

  // Field-aware suggestions
  if (parsedCmd.entity === 'invoice' && parsedCmd.verb === 'create') {
    if (currentArg === 'customer') {
      const q = trimmed.split(/\s+/).pop() || ''
      const customers = await fetchCatalog(`/api/palette/customers?q=${encodeURIComponent(q)}`)
      const mapped = customers.slice(0, 5).map((c: any) => ({
        type: 'entity' as const,
        value: `${schema.entity} ${schema.verb} ${c.name} `,
        label: c.name,
        description: c.meta?.outstanding,
        icon: 'üë§',
      }))
      return mapped.length ? mapped : base
    }
    if (currentArg === 'currency') {
      const currency = activeCompany.value?.base_currency
      if (currency) {
        return [{
          type: 'flag',
          value: `${trimmed} ${currency}`.trim(),
          label: currency,
          description: 'Company base currency',
          icon: 'üí±',
        }]
      }
    }
  }

  if (parsedCmd.entity === 'payment' && parsedCmd.verb === 'create') {
    if (currentArg === 'invoice') {
      const q = trimmed.split(/\s+/).pop() || ''
      const invoices = await fetchCatalog('/api/palette/invoices/recent')
      const filtered = invoices.filter((i: any) =>
        i.number?.toLowerCase().includes(q.toLowerCase()) ||
        i.meta?.customer?.toLowerCase().includes(q.toLowerCase())
      )
      const mapped = filtered.slice(0, 5).map((i: any) => ({
        type: 'entity' as const,
        value: `${schema.entity} ${schema.verb} ${i.number} `,
        label: i.number,
        description: `${i.meta?.customer || ''} ${i.meta?.amount ? `¬∑ ${i.meta.amount}` : ''}`,
        icon: 'üìÑ',
      }))
      return mapped.length ? mapped : base
    }
  }

  if (parsedCmd.entity === 'customer' && parsedCmd.verb === 'create') {
    if (currentArg === 'currency') {
      const currency = activeCompany.value?.base_currency
      if (currency) {
        return [{
          type: 'flag',
          value: `${trimmed} ${currency}`.trim(),
          label: currency,
          description: 'Company base currency',
          icon: 'üí±',
        }]
      }
    }
  }

  return base
}

async function fetchCatalog(url: string): Promise<any[]> {
  try {
    const res = await fetch(url, {
      credentials: 'same-origin',
      headers: { 'Accept': 'application/json' },
    })
    if (!res.ok) return []
    return await res.json()
  } catch (e) {
    console.error('Catalog fetch failed', e)
    return []
  }
}

async function resolveDefaults(parsedCmd: ParsedCommand) {
  const schema = getSchema(parsedCmd.entity, parsedCmd.verb)
  if (!schema) return

  defaultsLoading.value = true
  const nextDefaults: Record<string, { value: string; source?: string }> = {}

  // Invoice create: customer currency/payment_terms
  if (parsedCmd.entity === 'invoice' && parsedCmd.verb === 'create') {
    const customerName = parsedCmd.flags?.customer as string
    if (customerName) {
      const customers = await fetchCatalog(`/api/palette/customers?q=${encodeURIComponent(customerName)}`)
      const match = customers.find((c: any) =>
        c.name?.toLowerCase() === customerName.toLowerCase() ||
        c.id === customerName
      )
      if (match?.meta?.currency) {
        nextDefaults.currency = { value: match.meta.currency, source: 'customer' }
      } else if (activeCompany.value?.base_currency) {
        nextDefaults.currency = { value: activeCompany.value.base_currency, source: 'company' }
      }
      if (match?.meta?.payment_terms) {
        nextDefaults.due = { value: `+${match.meta.payment_terms}d`, source: 'customer' }
      }
    } else if (activeCompany.value?.base_currency) {
      nextDefaults.currency = { value: activeCompany.value.base_currency, source: 'company' }
    }
  }

  // Payment create: invoice balance/currency
  if (parsedCmd.entity === 'payment' && parsedCmd.verb === 'create') {
    const invoiceToken = parsedCmd.flags?.invoice as string
    if (invoiceToken) {
      const invoices = await fetchCatalog('/api/palette/invoices/recent')
      const match = invoices.find((i: any) =>
        i.number?.toLowerCase() === invoiceToken.toLowerCase() ||
        i.id === invoiceToken
      )
      if (match?.meta?.amount) {
        nextDefaults.amount = { value: match.meta.amount.replace(/[^\d.]/g, ''), source: 'invoice.balance' }
      }
      if (match?.meta?.amount_currency) {
        nextDefaults.currency = { value: match.meta.amount_currency, source: 'invoice' }
      }
    }
  }

  defaults.value = nextDefaults
  defaultsLoading.value = false
}

// Destructive actions requiring confirmation
const DESTRUCTIVE_ACTIONS = [
  'company.delete',
  'user.delete',
  'role.delete',
  'user.deactivate',
]

async function execute() {
  const cmd = input.value.trim()
  if (!cmd || executing.value) return

  showSuggestions.value = false

  // Check if we're awaiting confirmation
  if (awaitingConfirmation.value) {
    if (cmd.toLowerCase() === 'yes') {
      // User confirmed - execute the original command
      const { parsed } = awaitingConfirmation.value
      awaitingConfirmation.value = null
      await executeCommand(parsed)
    } else {
      // User cancelled
      addOutput('output', '{secondary}Cancelled{/}')
      awaitingConfirmation.value = null
    }
    input.value = ''
    focusInput()
    return
  }

  // Handle built-in commands
  if (cmd === 'clear' || cmd === 'cls') {
    output.value = []
    input.value = ''
    focusInput()
    return
  }

  if (cmd === 'help' || cmd.startsWith('help ')) {
    const topic = cmd.slice(5).trim() || undefined
    const helpText = getHelp(topic)
    addOutput('output', helpText)
    addToHistory(cmd)
    input.value = ''
    focusInput()
    return
  }

  if (cmd === '?' || cmd.startsWith('?')) {
    const topic = cmd.slice(1).trim()
    const helpText = getHelp(topic ? `? ${topic}` : '?')
    addOutput('output', helpText)
    addToHistory(cmd)
    input.value = ''
    focusInput()
    return
  }

  // Parse command
  const parsed = parse(cmd)

  if (parsed.errors.length > 0) {
    addOutput('input', `‚ùØ ${cmd}`)
    addOutput('error', `{error}‚úó{/} ${parsed.errors.join(', ')}`)
    input.value = ''
    focusInput()
    return
  }

  if (!parsed.entity || !parsed.verb) {
    addOutput('input', `‚ùØ ${cmd}`)
    addOutput('error', `{error}‚úó{/} Unknown command. Type 'help' for available commands.`)
    input.value = ''
    focusInput()
    return
  }

  // Check if destructive
  const actionKey = `${parsed.entity}.${parsed.verb}`
  if (DESTRUCTIVE_ACTIONS.includes(actionKey)) {
    // Show confirmation prompt
    const entityName = String(parsed.flags.slug || parsed.flags.email || parsed.flags.name || 'this item')
    addOutput('input', `‚ùØ ${cmd}`)
    addOutput('warning', `{warning}‚ö†Ô∏è  Delete ${entityName}?{/}`)
    addOutput('warning', `{warning}Type 'yes' to confirm, or anything else to cancel{/}`)

    awaitingConfirmation.value = {
      original: cmd,
      parsed: parsed,
      message: `Confirm deletion`,
    }
    addToHistory(cmd)
    input.value = ''
    focusInput()
    return
  }

  // Normal execution
  await executeCommand(parsed)
  input.value = ''
  focusInput()
}

async function executeCommand(parsed: ParsedCommand) {
  const cmd = parsed.raw
  const resolvedCompanySlug = getRequestCompanySlug(parsed)
  const requiresCompany = needsCompanyContext(parsed)

  // Clear quick actions when new command executes
  tableState.value = null
  quickActions.value = []
  showSubPrompt.value = false
  subPromptAction.value = null
  subPromptInput.value = ''

  addOutput('input', `‚ùØ ${cmd}`)
  addToHistory(cmd)
  recordCommandUse(cmd)
  frecencyScores.value = getFrecencyScores()
  executing.value = true

  try {
    // Require company context for tenant commands
    if (requiresCompany && !resolvedCompanySlug) {
      addOutput('error', `{error}‚úó{/} Company context required. Switch into a company or include --slug.`)
      return
    }

    // Read-only verbs that shouldn't use idempotency (always fetch fresh)
    const readOnlyVerbs = ['list', 'view', 'get', 'show']
    const isReadOnly = readOnlyVerbs.includes(parsed.verb)

    // For read operations, add timestamp to ensure fresh data
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'X-Requested-With': 'XMLHttpRequest',
      'X-Action': `${parsed.entity}.${parsed.verb}`,
      'X-CSRF-TOKEN': getCsrfToken(),
      'Cache-Control': 'no-cache, no-store, must-revalidate',
      'Pragma': 'no-cache',
    }

    if (resolvedCompanySlug) {
      headers['X-Company-Slug'] = resolvedCompanySlug
    }

    // Only use idempotency for write operations
    if (!isReadOnly) {
      // ALWAYS generate a fresh idempotency key with timestamp
      // Don't use parsed.idemKey as it's deterministic (same command = same key)
      headers['X-Idempotency-Key'] = generateIdemKey(parsed)
    } else {
      // For read ops, add timestamp to bust any backend caching
      headers['X-Request-Time'] = Date.now().toString()
    }

    const res = await fetch('/api/commands', {
      method: 'POST',
      credentials: 'same-origin',
      cache: 'no-store', // Prevent browser caching
      headers,
      body: JSON.stringify({ params: parsed.flags }),
    })

    const data = await res.json()

    if (data.ok) {
      // Table response
      if (data.data?.headers && data.data?.rows) {
        addOutput('table', data.data.rows, data.data.headers, data.data.footer)
      } 
      // Message response
      else if (data.message) {
        addOutput('success', `{success}‚úì{/} ${data.message}`)
      }
      // Generic success
      else {
        addOutput('success', '{success}‚úì{/} Done')
      }

      // After deletes, refresh the list to show updated rows
      if (parsed.verb === 'delete' && parsed.entity) {
        pendingRefreshEntity.value = parsed.entity
      }

      // Handle redirect
      if (data.redirect) {
        addOutput('output', `{link:${data.redirect}}‚Üí Open in GUI{/}`)
      }

      // Update active company after switch
      if (parsed.entity === 'company' && parsed.verb === 'switch') {
        const payload = data.data || {}
        activeCompany.value = {
          id: payload.id || '',
          name: payload.name || '',
          slug: payload.slug || '',
          user_count: payload.user_count,
          base_currency: payload.base_currency,
          status: payload.status,
        }
      }
    } else {
      const friendly = normalizePermissionError(data.message)
      addOutput('error', `{error}‚úó{/} ${friendly}`)
      if (data.errors) {
        Object.entries(data.errors).forEach(([field, messages]) => {
          addOutput('error', `{error}  ${field}:{/} ${(messages as string[]).join(', ')}`)
        })
      }
    }
  } catch (e) {
    addOutput('error', `{error}‚úó{/} Network error: ${e instanceof Error ? e.message : 'Unknown'}`)
  } finally {
    executing.value = false
    const refreshEntity = pendingRefreshEntity.value
    pendingRefreshEntity.value = null
    focusInput()
    if (refreshEntity) {
      input.value = `${refreshEntity} list`
      execute()
    }
  }
}

function handleKeydown(e: KeyboardEvent) {
  if (!props.visible) return

  if (showSubPrompt.value) {
    if (e.key === 'Escape') {
      e.preventDefault()
      closeSubPrompt()
    }
    return
  }

  // Escape - close
  if (e.key === 'Escape') {
    if (showSuggestions.value) {
      showSuggestions.value = false
    } else {
      close()
    }
    return
  }

  // Enter - execute or accept suggestion
  if (e.key === 'Enter') {
  if (showSuggestions.value && suggestions.value.length > 0) {
    e.preventDefault()
    acceptSuggestion()
  } else {
    execute()
    }
    return
  }

  // Space - commit entity during stage 1
  if (
    e.key === ' ' &&
    stage.value === 'entity' &&
    showSuggestions.value &&
    !input.value.includes(' ')
  ) {
    e.preventDefault()
    acceptSuggestion(true)
    return
  }

  // Tab - accept suggestion or execute complete command; keep focus inside palette
  if (e.key === 'Tab') {
    e.preventDefault()
    const backwards = e.shiftKey
    if (showSuggestions.value && suggestions.value.length > 0) {
      const wasEntityStage = stage.value === 'entity'
      acceptSuggestion(wasEntityStage)
      nextTick(() => {
        const newParsed = parse(input.value)
        if (wasEntityStage) {
          stage.value = 'verb'
          refreshSuggestions(input.value)
        } else if (stage.value === 'verb' && newParsed.complete) {
          execute()
        }
      })
      return
    }

    // No suggestions: move through required args in order
    const scaffold = scaffoldState.value
    if (scaffold) {
      const schema = getSchema(parsed.value.entity, parsed.value.verb)
      const argOrder = schema?.args.filter(a => a.required).map(a => a.name) || []
      const current = scaffold.currentArg
      let target = current
      if (argOrder.length) {
        const idx = argOrder.indexOf(current || '')
        if (backwards) {
          target = argOrder[Math.max(0, idx <= 0 ? argOrder.length - 1 : idx - 1)]
        } else {
          target = argOrder[Math.min(argOrder.length - 1, idx < 0 ? 0 : idx + 1)]
        }
      }
      if (target) {
        moveCursorToArg(target)
        refreshSuggestions(input.value)
      }
      return
    }

    if (parsed.value.complete) {
      execute()
    }
    return
  }

  // Arrow navigation
  if (e.key === 'ArrowUp') {
    e.preventDefault()
    if (showSuggestions.value) {
      suggestionIndex.value = Math.max(0, suggestionIndex.value - 1)
    } else if (tableState.value && tableState.value.rows.length > 0) {
      // Navigate table rows
      const newIndex = Math.max(0, tableState.value.selectedRowIndex - 1)
      tableState.value.selectedRowIndex = newIndex
    } else if (history.value.length && historyIndex.value < history.value.length - 1) {
      historyIndex.value++
      input.value = history.value[historyIndex.value]
    }
    return
  }

  if (e.key === 'ArrowDown') {
    e.preventDefault()
    if (showSuggestions.value) {
      suggestionIndex.value = Math.min(suggestions.value.length - 1, suggestionIndex.value + 1)
    } else if (tableState.value && tableState.value.rows.length > 0) {
      // Navigate table rows
      const newIndex = Math.min(tableState.value.rows.length - 1, tableState.value.selectedRowIndex + 1)
      tableState.value.selectedRowIndex = newIndex
    } else if (historyIndex.value > 0) {
      historyIndex.value--
      input.value = history.value[historyIndex.value]
    } else if (historyIndex.value === 0) {
      historyIndex.value = -1
      input.value = ''
    }
    return
  }

  // Number keys (0-9) - trigger quick actions
  if (quickActions.value.length > 0 && /^[0-9]$/.test(e.key)) {
    const action = quickActions.value.find(a => a.key === e.key)
    if (action) {
      e.preventDefault()
      handleQuickAction(action)
      return
    }
  }

  // Ctrl+L - clear
  if (e.key === 'l' && e.ctrlKey) {
    e.preventDefault()
    output.value = []
    return
  }

  // Ctrl+U - clear input
  if (e.key === 'u' && e.ctrlKey) {
    e.preventDefault()
    input.value = ''
    return
  }
}

function acceptSuggestion(advanceStage = false) {
  const suggestion = suggestions.value[suggestionIndex.value] || suggestions.value[0]
  if (!suggestion) return

  // Use the value from the suggestion
  input.value = suggestion.value
  showSuggestions.value = false
  stage.value = advanceStage ? 'verb' : determineStage(input.value)
  nextTick(() => inputEl.value?.focus())
}

function moveCursorToArg(arg: string) {
  // Simple strategy: append placeholder if missing
  if (!input.value.includes(` ${arg}`) && !input.value.includes(`--${arg}`)) {
    input.value = `${input.value.trim()} ${arg} `.trim()
  }
  focusInput()
}

function selectSuggestion(index: number) {
  suggestionIndex.value = index
  acceptSuggestion()
}

function addToHistory(cmd: string) {
  history.value = [cmd, ...history.value.filter(h => h !== cmd)].slice(0, 100)
  historyIndex.value = -1
  saveHistory()
}

function loadHistory(): string[] {
  try {
    return JSON.parse(localStorage.getItem('palette-history') || '[]')
  } catch {
    return []
  }
}

function saveHistory() {
  try {
    localStorage.setItem('palette-history', JSON.stringify(history.value))
  } catch { /* ignore */ }
}

function getCsrfToken(): string {
  return document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || ''
}

function generateIdemKey(parsed: ParsedCommand): string {
  const parts = [parsed.entity, parsed.verb, Date.now(), JSON.stringify(parsed.flags)]
  return btoa(parts.join('|')).substring(0, 32)
}

function needsCompanyContext(parsed: ParsedCommand): boolean {
  const key = `${parsed.entity}.${parsed.verb}`
  const globalCommands = new Set([
    'company.list',
    'company.create',
    'company.switch',
    'help',
    'clear',
  ])
  return !globalCommands.has(key)
}

function normalizePermissionError(message?: string): string {
  if (!message) return 'Command failed'
  if (message.includes('There is no permission named')) {
    return `${message} (permissions cache likely stale ‚Äî run app:sync-permissions and app:sync-role-permissions)`
  }
  return message
}

function getRequestCompanySlug(parsed: ParsedCommand): string {
  const flags = parsed.flags as Record<string, unknown>
  const fromFlags = ['slug', 'company', 'id'].map((key) => {
    const val = flags?.[key]
    return typeof val === 'string' ? val.trim() : ''
  }).find(Boolean) || ''

  return companySlug.value || fromFlags || getSlugFromTableState()
}

function getSlugFromTableState(): string {
  const state = tableState.value
  if (!state) return ''

  const rowIndex = state.selectedRowIndex
  if (rowIndex < 0 || rowIndex >= state.rows.length) return ''

  const slugIndex = state.headers.findIndex(h => h.toLowerCase().replace(/\s+/g, '') === 'slug')
  if (slugIndex === -1) return ''

  return state.rows[rowIndex]?.[slugIndex] || ''
}

// Handle quick action click
function handleQuickAction(action: QuickAction) {
  // Check if action needs row selection
  if (action.needsRow && (!tableState.value || tableState.value.selectedRowIndex < 0)) {
    return
  }

  // Check if action needs sub-prompt
  if (action.prompt) {
    subPromptAction.value = action
    subPromptInput.value = ''
    showSubPrompt.value = true
    nextTick(() => subPromptInputEl.value?.focus())
    return
  }

  // Execute directly
  const resolved = resolveQuickActionCommand(action.command, tableState.value)
  if (resolved) {
    input.value = resolved
    execute()
  }
}

// Select row in table
function selectRow(rowIndex: number) {
  if (tableState.value) {
    tableState.value.selectedRowIndex = rowIndex
  }
  focusInput()
}

// Close sub-prompt modal
function closeSubPrompt() {
  showSubPrompt.value = false
  subPromptAction.value = null
  subPromptInput.value = ''
  focusInput()
}

// Confirm sub-prompt and execute
function confirmSubPrompt() {
  if (!subPromptAction.value || !subPromptInput.value.trim()) return

  // Resolve command with row data first
  let resolved = resolveQuickActionCommand(subPromptAction.value.command, tableState.value)

  // If command still has placeholders or is null, use the base command
  if (!resolved) {
    resolved = subPromptAction.value.command
  }

  // Append the user input
  const finalCommand = `${resolved} ${subPromptInput.value.trim()}`

  // Execute
  input.value = finalCommand
  closeSubPrompt()
  execute()
}

// Click outside to close suggestions
function handleClickOutside(e: MouseEvent) {
  const target = e.target as HTMLElement
  if (!target.closest('.palette')) {
    showSuggestions.value = false
  }
}

onMounted(() => {
  document.addEventListener('click', handleClickOutside)
})

onUnmounted(() => {
  document.removeEventListener('click', handleClickOutside)
  document.removeEventListener('keydown', handleKeydown)
})

function focusInput() {
  nextTick(() => inputEl.value?.focus())
}
</script>

<template>
  <Teleport to="body">
    <!-- Backdrop -->
    <div v-if="visible" class="palette-backdrop" @click="close" />

    <!-- Palette -->
    <div v-if="visible" class="palette">
      <!-- Header - simplified -->
      <div class="palette-header">
        <div class="palette-company">
          <span class="palette-dot" :class="{ 'palette-dot--active': activeCompany }"></span>
          {{ activeCompany?.name || 'Global' }}
        </div>
        <span class="palette-esc">Esc to close</span>
      </div>

      <!-- Main content area with sidebar -->
      <div class="palette-body">
        <!-- Main output and input area -->
        <div class="palette-main">
          <!-- Output -->
          <div ref="outputEl" class="palette-output">
        <template v-if="output.length === 0">
          <div class="palette-empty">
            Type a command or <span class="palette-cmd">help</span> for available commands
          </div>
        </template>
        <template v-for="(line, i) in output" :key="i">
          <!-- Table with row selection -->
          <div v-if="line.type === 'table'" class="palette-table">
            <div class="table-wrapper">
              <!-- Table headers -->
              <div v-if="line.headers && line.headers.length" class="table-header">
                <div
                  v-for="(header, colIndex) in line.headers"
                  :key="colIndex"
                  class="table-cell table-cell--header"
                >
                  {{ header }}
                </div>
              </div>
              <!-- Table rows -->
              <div
                v-for="(row, rowIndex) in (line.content as string[][])"
                :key="rowIndex"
                class="table-row"
                :class="{
                  'table-row--selected': tableState && i === output.length - 1 && rowIndex === tableState.selectedRowIndex
                }"
                @click="selectRow(rowIndex)"
              >
                <div
                  v-for="(cell, colIndex) in row"
                  :key="colIndex"
                  class="table-cell"
                >
                  {{ cell }}
                </div>
              </div>
              <!-- Table footer -->
              <div v-if="line.footer" class="table-footer">
                {{ line.footer }}
              </div>
            </div>
          </div>
          <!-- Text lines -->
      <div
        v-else
        class="palette-line"
        :class="{
          'palette-line--input': line.type === 'input',
          'palette-line--error': line.type === 'error',
          'palette-line--success': line.type === 'success',
          'palette-line--warning': line.type === 'warning',
        }"
        v-html="formatText(String(line.content))"
      ></div>
        </template>
      </div>

      <!-- Input area -->
      <div class="palette-input-area">
        <div class="palette-input-row">
          <span class="palette-prompt" :class="{ 'palette-prompt--busy': executing }">
            {{ executing ? '‚ãØ' : '‚ùØ' }}
          </span>
          <div class="palette-input-container">
            <input
              ref="inputEl"
              v-model="input"
              type="text"
              class="palette-input"
              :disabled="executing"
              placeholder="Type a command..."
              autocomplete="off"
              autocorrect="off"
              autocapitalize="off"
              spellcheck="false"
              @click="handleCursor"
              @keyup="handleCursor"
              @keydown="handleCursor"
            />
            <span
              v-if="scaffoldState?.ghosts?.length"
              class="palette-placeholder-hint"
              :style="{ '--typed-text-width': typedTextWidth }"
            >
              <template v-for="ghost in scaffoldState.ghosts" :key="ghost.label">
                <span :class="ghost.completed ? 'ghost-complete' : 'ghost-pending'">
                  {{ ghost.completed ? ghost.label : `<${ghost.label}>` }}
                </span>
                <span class="ghost-sep"> </span>
              </template>
            </span>
          </div>
          <div v-if="executing" class="palette-loading">
            <div class="palette-spinner"></div>
            <span class="palette-loading-text">Executing...</span>
          </div>
        </div>

        <!-- Skeleton zone -->
        <div v-if="scaffoldState" class="palette-skeleton">
          <div class="skeleton-row">
            <span class="skeleton-text">{{ scaffoldState.skeleton }}</span>
          </div>
          <div class="skeleton-pointer">
            <span class="skeleton-arrow">‚Üë</span>
            <span class="skeleton-hint">{{ scaffoldState.pointerLabel }}</span>
            <span v-if="cursorIndex" class="skeleton-cursor">cursor: {{ cursorIndex }}</span>
          </div>
          <div class="skeleton-flags">
            <button
              v-for="flag in scaffoldState.optionalFlags"
              :key="flag.name"
              class="flag-chip"
              @click="applyFlagChip(flag)"
            >
              --{{ flag.name }}
              <span v-if="flag.value" class="flag-value">={{ flag.value }}</span>
              <span v-if="flag.source" class="flag-source" :title="flag.source">*</span>
              <span v-if="defaultsLoading && !flag.value" class="flag-loading">‚Ä¶</span>
            </button>
          </div>
          <div class="skeleton-status">
            <span v-if="scaffoldState.requiredRemaining.length">Required: {{ scaffoldState.requiredRemaining.join(', ') }}</span>
            <span v-else>Ready</span>
            <span class="status-optional">Optional: flags</span>
            <span v-if="validationHint" class="status-hint">{{ validationHint }}</span>
          </div>
        </div>

        <!-- Dropdown below input -->
        <div v-if="showSuggestions && suggestions.length" class="palette-dropdown">
          <div
            v-for="(suggestion, index) in suggestions"
            :key="suggestion.value"
            class="dropdown-item"
            :class="{ 'dropdown-item--selected': index === suggestionIndex }"
            @click="selectSuggestion(index)"
            @mouseenter="suggestionIndex = index"
          >
            <span class="dropdown-icon">{{ suggestion.icon || 'üì¶' }}</span>
            <div class="dropdown-text">
              <span class="dropdown-label">{{ suggestion.label }}</span>
              <span v-if="stage === 'verb' && suggestion.description" class="dropdown-desc">
                {{ suggestion.description }}
              </span>
            </div>
            <kbd v-if="index === suggestionIndex">Tab</kbd>
          </div>
        </div>

        <!-- Helper bar -->
        <div class="palette-helper">
          <span class="palette-stage">
            {{ stage === 'entity' ? 'Entity' : 'Verb' }}
          </span>
          <div class="palette-keys">
            <span><kbd>‚Üë‚Üì</kbd> navigate</span>
            <span><kbd>Tab</kbd> {{ tabActionLabel }}</span>
            <span><kbd>Esc</kbd> close</span>
          </div>
        </div>

        <div v-if="contextRecords.length" class="palette-context">
          <div class="palette-context__title">{{ contextTitle }}</div>
          <div class="palette-context__chips">
            <button
              v-for="record in contextRecords"
              :key="record.value"
              class="palette-context__chip"
              @click="applyContextRecord(record)"
            >
              <span class="palette-context__label">{{ record.label }}</span>
              <span v-if="record.meta" class="palette-context__meta">{{ record.meta }}</span>
            </button>
          </div>
        </div>

      </div>
        </div>

        <!-- Quick Actions Sidebar -->
        <div v-if="quickActions.length > 0" class="palette-sidebar">
          <div class="sidebar-header">
            Quick Actions
            <span v-if="tableState" class="sidebar-debug">
              ({{ tableState.entity }}.{{ tableState.verb }})
            </span>
          </div>
          <div class="sidebar-actions">
            <div
              v-for="action in quickActions"
              :key="action.key"
              class="sidebar-action"
            :class="{
              'sidebar-action--needs-row': action.needsRow && !tableState,
              'sidebar-action--disabled': action.needsRow && (!tableState || tableState.selectedRowIndex < 0)
            }"
            @click="handleQuickAction(action)"
            :aria-label="`Quick action ${action.key}: ${getQuickActionLabel(action, tableState)}`"
          >
              <span class="action-key">{{ action.key }}</span>
              <span class="action-label">{{ getQuickActionLabel(action, tableState) }}</span>
            </div>
        </div>
        <div class="sidebar-hint">
          Press the shown number keys (0-9)
          <template v-if="tableState">
            <br />
            <span class="hint-small">Use ‚Üë‚Üì to select row</span>
          </template>
        </div>
        </div>
      </div>
    </div>

    <!-- Sub-Prompt Modal -->
    <div v-if="showSubPrompt && subPromptAction" class="subprompt-backdrop" @click="closeSubPrompt">
      <div class="subprompt-modal" @click.stop>
        <div class="subprompt-header">
          <span class="subprompt-title">{{ subPromptAction.label }}</span>
          <button class="subprompt-close" @click="closeSubPrompt">‚úï</button>
        </div>
        <div class="subprompt-body">
          <p class="subprompt-prompt">{{ subPromptAction.prompt }}</p>
          <input
            ref="subPromptInputEl"
            v-model="subPromptInput"
            type="text"
            class="subprompt-input"
            placeholder="Enter value..."
            @keydown.enter="confirmSubPrompt"
            @keydown.esc="closeSubPrompt"
          />
        </div>
        <div class="subprompt-footer">
          <button class="subprompt-btn subprompt-btn--cancel" @click="closeSubPrompt">
            Cancel
          </button>
          <button class="subprompt-btn subprompt-btn--confirm" @click="confirmSubPrompt">
            Confirm
          </button>
        </div>
      </div>
    </div>
  </Teleport>
</template>

<style scoped>
/* Single dark theme - no switching */
.palette-backdrop {
  position: fixed;
  inset: 0;
  background: linear-gradient(to top, rgba(0, 0, 0, 0.55), rgba(0, 0, 0, 0.15) 50%, transparent);
  z-index: 9998;
}

.palette {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 80vw;
  height: 80vh;
  max-width: 1400px;
  max-height: calc(100vh - 40px);
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 16px;
  font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Consolas', monospace;
  font-size: 14px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  box-shadow:
    0 0 0 1px rgba(255, 255, 255, 0.05),
    0 20px 50px rgba(0, 0, 0, 0.5);
  overflow: hidden;
}

/* Body with sidebar */
.palette-body {
  display: flex;
  flex: 1;
  min-height: 0;
}

.palette-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  min-width: 0;
}

/* Header */
.palette-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: #1e293b;
  border-bottom: 1px solid #334155;
  font-size: 13px;
}

.palette-company {
  display: flex;
  align-items: center;
  gap: 8px;
  font-size: 13px;
  font-weight: 500;
  color: #e2e8f0;
}

.palette-dot {
  width: 8px;
  height: 8px;
  background: #475569;
  border-radius: 50%;
}

.palette-dot--active {
  background: #22d3ee;
}

.palette-esc {
  font-size: 11px;
  color: #64748b;
}

/* Output */
.palette-output {
  flex: 1;
  overflow-y: auto;
  padding: 12px 14px;
  min-height: 120px;
}

.palette-output::-webkit-scrollbar {
  width: 6px;
}

.palette-output::-webkit-scrollbar-track {
  background: transparent;
}

.palette-output::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 3px;
}

.palette-output::-webkit-scrollbar-thumb:hover {
  background: #475569;
}

.palette-empty {
  color: #64748b;
  text-align: center;
  padding: 40px 20px;
}

.palette-cmd {
  color: #22d3ee;
  background: rgba(34, 211, 238, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
}

.palette-line {
  color: #e2e8f0;
  line-height: 1.7;
  white-space: pre-wrap;
  word-break: break-word;
}

.palette-line--input {
  color: #22d3ee;
}

.palette-line--error {
  color: #f43f5e;
}

.palette-line--success {
  color: #10b981;
}
.palette-line--warning {
  color: #f59e0b;
}

.palette-table {
  margin: 8px 0;
}

.palette-table pre {
  margin: 0;
  color: #e2e8f0;
  font-family: inherit;
  font-size: 13px;
  line-height: 1.5;
  overflow-x: auto;
}

/* Custom table with row selection */
.table-wrapper {
  border: 1px solid #334155;
  border-radius: 6px;
  overflow: hidden;
}

.table-header {
  display: flex;
  background: rgba(34, 211, 238, 0.1);
  border-bottom: 1px solid #334155;
}

.table-row {
  display: flex;
  border-bottom: 1px solid #334155;
  cursor: pointer;
  transition: background 0.1s;
}

.table-row:last-child {
  border-bottom: none;
}

.table-row:hover {
  background: rgba(34, 211, 238, 0.05);
}

.table-row--selected {
  background: rgba(34, 211, 238, 0.15) !important;
  border-left: 3px solid #22d3ee;
}

.table-cell {
  flex: 1;
  padding: 8px 12px;
  color: #e2e8f0;
  font-size: 12px;
  min-width: 0;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.table-cell--header {
  font-weight: 600;
  color: #22d3ee;
  text-transform: uppercase;
  font-size: 11px;
  letter-spacing: 0.5px;
}

.table-footer {
  padding: 8px 12px;
  background: rgba(0, 0, 0, 0.2);
  border-top: 1px solid #334155;
  color: #64748b;
  font-size: 11px;
  text-align: right;
}

/* Input area */
.palette-input-area {
  position: relative;
  border-top: 1px solid #334155;
  background: #1e293b;
  display: flex;
  flex-direction: column;
}

.palette-input-row {
  display: flex;
  align-items: center;
  padding: 12px 14px;
}

.palette-prompt {
  color: #22d3ee;
  margin-right: 10px;
  font-weight: 600;
  transition: color 0.15s;
  flex-shrink: 0;
}

.palette-prompt--busy {
  color: #f59e0b;
}

.palette-input-container {
  position: relative;
  flex: 1;
  min-width: 0;
}

.palette-input {
  width: 100%;
  background: transparent;
  border: none;
  outline: none;
  color: #e2e8f0;
  font: inherit;
  caret-color: #22d3ee;
  position: relative;
  z-index: 2;
}

.palette-input::placeholder {
  color: #475569;
}

.palette-input:disabled {
  opacity: 0.5;
}

.palette-placeholder-hint {
  position: absolute;
  left: 0;
  top: 50%;
  transform: translateY(-50%);
  pointer-events: none;
  color: #475569;
  opacity: 0.5;
  white-space: nowrap;
  font: inherit;
  z-index: 1;
  padding-left: var(--typed-text-width, 0);
}

.ghost-complete {
  color: #64748b;
}

.ghost-pending {
  color: #94a3b8;
}

.ghost-sep {
  opacity: 0;
}

/* Helper */
.palette-dropdown {
  border-top: 1px solid #334155;
  max-height: 200px;
  overflow-y: auto;
}

.dropdown-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 14px;
  cursor: pointer;
  transition: background 0.1s;
}

.dropdown-item:hover {
  background: rgba(34, 211, 238, 0.05);
}

.dropdown-item--selected {
  background: rgba(34, 211, 238, 0.1);
}

.dropdown-item--selected .dropdown-label {
  color: #22d3ee;
}

.dropdown-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
}

.dropdown-text {
  display: flex;
  flex-direction: column;
  gap: 2px;
  flex: 1;
  min-width: 0;
}

.dropdown-label {
  font-weight: 500;
  color: #e2e8f0;
  font-size: 13px;
  min-width: 100px;
}

.dropdown-desc {
  color: #64748b;
  font-size: 12px;
  flex: 1;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.dropdown-item kbd {
  font-size: 10px;
  padding: 2px 8px;
  background: rgba(34, 211, 238, 0.15);
  border: 1px solid rgba(34, 211, 238, 0.3);
  border-radius: 4px;
  color: #22d3ee;
  margin-left: auto;
}

.palette-helper {
  display: flex;
  align-items: center;
  padding: 8px 14px;
  border-top: 1px solid rgba(51, 65, 85, 0.5);
  font-size: 11px;
  color: #64748b;
  gap: 12px;
}

.palette-helper kbd {
  display: inline-block;
  background: rgba(255, 255, 255, 0.06);
  padding: 2px 6px;
  border-radius: 3px;
  margin-right: 4px;
  font-family: inherit;
  font-size: 10px;
}

.palette-stage {
  padding: 3px 10px;
  background: rgba(34, 211, 238, 0.1);
  border: 1px solid rgba(34, 211, 238, 0.25);
  border-radius: 4px;
  color: #22d3ee;
  font-weight: 600;
  font-size: 10px;
  text-transform: uppercase;
}

.palette-keys {
  display: flex;
  gap: 16px;
  margin-left: auto;
}

.palette-skeleton {
  padding: 10px 14px 8px;
  border-top: 1px solid #334155;
  background: rgba(34, 211, 238, 0.04);
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.skeleton-row {
  font-family: 'JetBrains Mono', 'Fira Code', monospace;
  color: #cbd5e1;
  font-size: 13px;
}

.skeleton-pointer {
  display: flex;
  align-items: center;
  gap: 6px;
  color: #94a3b8;
  font-size: 11px;
}

.skeleton-arrow {
  color: #22d3ee;
}

.skeleton-flags {
  display: flex;
  gap: 6px;
  flex-wrap: wrap;
}

.flag-chip {
  border: 1px solid rgba(34, 211, 238, 0.3);
  background: rgba(34, 211, 238, 0.08);
  color: #e2e8f0;
  border-radius: 8px;
  padding: 6px 8px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  gap: 4px;
  font-size: 12px;
  transition: all 0.12s;
}

.flag-chip:hover {
  border-color: rgba(34, 211, 238, 0.5);
  background: rgba(34, 211, 238, 0.14);
}

.flag-value {
  color: #22d3ee;
}

.flag-source {
  color: #fbbf24;
}

.flag-loading {
  color: #94a3b8;
  font-size: 10px;
}

.skeleton-status {
  display: flex;
  gap: 12px;
  font-size: 11px;
  color: #94a3b8;
}

.status-optional {
  color: #64748b;
}

.status-hint {
  color: #f59e0b;
  margin-left: auto;
}

.palette-context {
  padding: 8px 14px 12px;
  border-top: 1px solid #334155;
  background: rgba(34, 211, 238, 0.04);
}

.palette-context__title {
  font-size: 12px;
  color: #94a3b8;
  margin-bottom: 6px;
}

.palette-context__chips {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
}

.palette-context__chip {
  border: 1px solid rgba(34, 211, 238, 0.3);
  background: rgba(34, 211, 238, 0.08);
  color: #e2e8f0;
  border-radius: 8px;
  padding: 8px 10px;
  cursor: pointer;
  display: inline-flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 2px;
  transition: all 0.15s;
}

.palette-context__chip:hover {
  border-color: rgba(34, 211, 238, 0.5);
  background: rgba(34, 211, 238, 0.14);
}

.palette-context__label {
  font-weight: 600;
}

.palette-context__meta {
  font-size: 11px;
  color: #94a3b8;
}

/* Helper suggestions (inline) */

/* Loading indicator */
.palette-loading {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-left: 12px;
  color: #f59e0b;
  font-size: 13px;
}

.palette-spinner {
  width: 14px;
  height: 14px;
  border: 2px solid rgba(34, 211, 238, 0.2);
  border-top-color: #22d3ee;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.palette-loading-text {
  color: #22d3ee;
  font-size: 12px;
}

/* Semantic formatting classes */
.fmt-success {
  color: #10b981;
}

.fmt-error {
  color: #f43f5e;
}

.fmt-warning {
  color: #f59e0b;
}

.fmt-accent {
  color: #22d3ee;
}

.fmt-primary {
  color: #6366f1;
}

.fmt-secondary {
  color: #64748b;
}

.fmt-dim {
  opacity: 0.5;
}

.fmt-code {
  background: rgba(34, 211, 238, 0.1);
  padding: 2px 6px;
  border-radius: 4px;
  font-family: inherit;
  font-size: 13px;
}

.fmt-link {
  color: #22d3ee;
  text-decoration: none;
  border-bottom: 1px dotted #22d3ee;
  cursor: pointer;
}

.fmt-link:hover {
  text-decoration: underline;
  border-bottom-style: solid;
}

/* Quick Actions Sidebar */
.palette-sidebar {
  width: 260px;
  background: #1e293b;
  border-left: 1px solid #334155;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
}

.sidebar-header {
  padding: 12px 14px;
  font-size: 12px;
  font-weight: 600;
  color: #64748b;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-bottom: 1px solid #334155;
}

.sidebar-debug {
  display: block;
  font-size: 10px;
  color: #fbbf24;
  text-transform: none;
  margin-top: 4px;
  font-weight: normal;
}

.sidebar-actions {
  flex: 1;
  overflow-y: auto;
  padding: 8px;
}

.sidebar-action {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px 12px;
  margin-bottom: 6px;
  background: rgba(34, 211, 238, 0.05);
  border: 1px solid rgba(34, 211, 238, 0.2);
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s;
}

.sidebar-action:hover {
  background: rgba(34, 211, 238, 0.1);
  border-color: rgba(34, 211, 238, 0.3);
}

.sidebar-action--disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

.sidebar-action--disabled:hover {
  background: rgba(34, 211, 238, 0.05);
  border-color: rgba(34, 211, 238, 0.2);
}

.action-key {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  background: rgba(34, 211, 238, 0.2);
  color: #22d3ee;
  border-radius: 4px;
  font-weight: 600;
  font-size: 13px;
  flex-shrink: 0;
}

.action-label {
  flex: 1;
  color: #e2e8f0;
  font-size: 12px;
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.sidebar-hint {
  padding: 12px 14px;
  border-top: 1px solid #334155;
  font-size: 11px;
  color: #64748b;
  line-height: 1.5;
}

.hint-small {
  font-size: 10px;
  opacity: 0.7;
}

/* Sub-Prompt Modal */
.subprompt-backdrop {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 10000;
  display: flex;
  align-items: center;
  justify-content: center;
}

.subprompt-modal {
  width: 480px;
  max-width: calc(100vw - 40px);
  background: #1e293b;
  border: 1px solid #334155;
  border-radius: 8px;
  box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
  font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', 'Consolas', monospace;
}

.subprompt-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 16px 18px;
  border-bottom: 1px solid #334155;
}

.subprompt-title {
  font-size: 14px;
  font-weight: 600;
  color: #e2e8f0;
}

.subprompt-close {
  width: 28px;
  height: 28px;
  background: transparent;
  border: none;
  color: #64748b;
  font-size: 18px;
  cursor: pointer;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
}

.subprompt-close:hover {
  background: rgba(255, 255, 255, 0.1);
  color: #e2e8f0;
}

.subprompt-body {
  padding: 20px 18px;
}

.subprompt-prompt {
  margin: 0 0 14px 0;
  font-size: 13px;
  color: #94a3b8;
  line-height: 1.5;
}

.subprompt-input {
  width: 100%;
  padding: 12px 14px;
  background: #0f172a;
  border: 1px solid #334155;
  border-radius: 6px;
  color: #e2e8f0;
  font-family: inherit;
  font-size: 14px;
  outline: none;
  transition: border-color 0.15s;
}

.subprompt-input:focus {
  border-color: #22d3ee;
}

.subprompt-input::placeholder {
  color: #475569;
}

.subprompt-footer {
  display: flex;
  gap: 10px;
  padding: 16px 18px;
  border-top: 1px solid #334155;
  justify-content: flex-end;
}

.subprompt-btn {
  padding: 8px 16px;
  font-family: inherit;
  font-size: 13px;
  font-weight: 500;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s;
  border: none;
}

.subprompt-btn--cancel {
  background: transparent;
  color: #64748b;
  border: 1px solid #334155;
}

.subprompt-btn--cancel:hover {
  background: rgba(255, 255, 255, 0.05);
  color: #94a3b8;
}

.subprompt-btn--confirm {
  background: #22d3ee;
  color: #0f172a;
}

.subprompt-btn--confirm:hover {
  background: #06b6d4;
}
</style>


===== build/resources/js/palette/autocomplete.ts =====
import { GRAMMAR, ENTITY_ICONS, COMMAND_DESCRIPTIONS, resolveEntityShortcut } from './grammar'
import { getPresetShortcuts } from './shortcuts'
import type { Suggestion } from '@/types/palette'

export interface GenerateSuggestionOptions {
  maxResults?: number
  stage?: 'entity' | 'verb'
  entity?: string
  frecencyScores?: Record<string, number>
}

/**
 * Generate command suggestions based on partial input
 */
export function generateSuggestions(input: string, options: GenerateSuggestionOptions = {}): Suggestion[] {
  const maxResults = options.maxResults ?? 8
  const stage = options.stage ?? 'entity'
  const trimmed = input.trim()
  const frecencyScores = options.frecencyScores || {}

  if (!trimmed && stage === 'entity') {
    return getQuickStartSuggestions(frecencyScores).slice(0, maxResults)
  }

  const inputLower = input.toLowerCase()
  const suggestions: Array<Suggestion & { commandKey?: string }> = []

  const targetEntity = options.entity || resolveEntityShortcut(trimmed.split(/\s+/)[0] || '') || ''
  const completions = stage === 'verb'
    ? (targetEntity ? getVerbCompletions(targetEntity) : getEntityCompletions())
    : getEntityCompletions()

  for (const completion of completions) {
    const score = scoreSuggestion(inputLower, completion.value.toLowerCase())
    if (score > 0) {
      const frecencyBoost = completion.commandKey
        ? (frecencyScores[completion.commandKey] || 0) * 50
        : 0
      suggestions.push({ ...completion, score: score + frecencyBoost })
    }
  }

  // Sort by score (higher = better match), then by length (shorter = simpler)
  return suggestions
    .sort((a, b) => {
      if (b.score !== a.score) return b.score! - a.score!
      return a.value.length - b.value.length
    })
    .slice(0, maxResults)
}

/**
 * Quick start suggestions when input is empty
 */
function getQuickStartSuggestions(frecencyScores: Record<string, number>): Suggestion[] {
  const topFrequent = Object.entries(frecencyScores)
    .sort((a, b) => b[1] - a[1])
    .slice(0, 3)
    .map(([command]) => ({
      type: 'history' as const,
      value: `${command} `,
      label: command,
      description: 'Recent favorite',
      icon: '‚è±',
    }))

  const presets = getPresetShortcuts()
  const shortcutPicks = Object.entries(presets).slice(0, 3).map(([shortcut, cmd]) => ({
    type: 'command' as const,
    value: `${cmd.entity} ${cmd.verb} `,
    label: `${cmd.entity} ${cmd.verb}`,
    description: `Shortcut: ${shortcut}`,
    icon: ENTITY_ICONS[cmd.entity] || '‚å®Ô∏è',
  }))

  return [
    ...topFrequent,
    ...shortcutPicks,
    {
      type: 'command',
      value: 'company list',
      label: 'company list',
      description: 'View all companies',
      icon: ENTITY_ICONS.company,
    },
    {
      type: 'command',
      value: 'user invite ',
      label: 'user invite',
      description: 'Invite a new user',
      icon: ENTITY_ICONS.user,
    },
    {
      type: 'command',
      value: 'user list',
      label: 'user list',
      description: 'View all users',
      icon: ENTITY_ICONS.user,
    },
    {
      type: 'command',
      value: 'help',
      label: 'help',
      description: 'Show all commands',
      icon: '‚ùì',
    },
  ]
}

/**
 * Score how well input matches a completion
 * Higher score = better match
 */
function scoreSuggestion(input: string, completion: string): number {
  // Exact prefix match - highest score
  if (completion.startsWith(input)) {
    return 100 + (input.length / completion.length) * 50
  }

  // Match after the dot (e.g., "list" matches "company.list")
  const dotIndex = completion.indexOf('.')
  if (dotIndex > 0) {
    const afterDot = completion.substring(dotIndex + 1)
    if (afterDot.startsWith(input)) {
      return 80 + (input.length / afterDot.length) * 30
    }
  }

  // Fuzzy match - each character in order
  let inputIdx = 0
  let score = 0
  for (let i = 0; i < completion.length && inputIdx < input.length; i++) {
    if (completion[i] === input[inputIdx]) {
      // Bonus for consecutive matches
      score += (i === 0 || completion[i - 1] === '.' || completion[i - 1] === ' ') ? 10 : 5
      inputIdx++
    }
  }

  // Only return score if all input chars were found
  return inputIdx === input.length ? score : 0
}

function getEntityCompletions(): Array<Suggestion & { commandKey?: string }> {
  const completions: Array<Suggestion & { commandKey?: string }> = []

  for (const [entityName, entity] of Object.entries(GRAMMAR)) {
    // Entity alone
    completions.push({
      type: 'entity',
      value: `${entityName} `,
      label: entityName,
      description: '',
      icon: ENTITY_ICONS[entityName] || 'üì¶',
      commandKey: `${entityName}.list`,
    })
  }

  // Preset shortcuts as explicit items
  const presets = getPresetShortcuts()
  for (const [shortcut, cmd] of Object.entries(presets)) {
    const commandKey = `${cmd.entity}.${cmd.verb}`
    const description = COMMAND_DESCRIPTIONS[commandKey] || `${cmd.verb} ${cmd.entity}`
    completions.push({
      type: 'command',
      value: `${cmd.entity} ${cmd.verb} `,
      label: `${cmd.entity} ${cmd.verb}`,
      description: `Shortcut: ${shortcut} ‚Äî ${description}`,
      icon: ENTITY_ICONS[cmd.entity] || '‚å®Ô∏è',
      commandKey,
    })
  }

  // Built-in commands
  completions.push({
    type: 'command',
    value: 'help',
    label: 'help',
    description: COMMAND_DESCRIPTIONS['help'] || 'Show help',
    icon: '‚ùì',
    commandKey: 'help',
  })

  completions.push({
    type: 'command',
    value: 'clear',
    label: 'clear',
    description: COMMAND_DESCRIPTIONS['clear'] || 'Clear output',
    icon: 'üóëÔ∏è',
    commandKey: 'clear',
  })

  return completions
}

function getVerbCompletions(entityName: string): Array<Suggestion & { commandKey?: string }> {
  const entity = GRAMMAR[entityName]
  if (!entity) return []

  return entity.verbs.map((verb) => {
    const commandKey = `${entityName}.${verb.name}`
    const description = COMMAND_DESCRIPTIONS[commandKey] || ''
    return {
      type: 'verb' as const,
      value: `${entityName} ${verb.name} `,
      label: `${verb.name}`,
      description,
      icon: ENTITY_ICONS[entityName] || 'üì¶',
      commandKey,
    }
  })
}

/**
 * Get suggestions for flag values (for future use with entity catalogs)
 */
export function getFlagSuggestions(
  entity: string,
  verb: string,
  flag: string,
  partial: string,
  catalog: Record<string, string[]> = {}
): string[] {
  // For now, just return from catalog if available
  const key = `${entity}.${flag}`
  const values = catalog[key] || []

  if (!partial) return values.slice(0, 5)

  const partialLower = partial.toLowerCase()
  return values
    .filter(v => v.toLowerCase().includes(partialLower))
    .slice(0, 5)
}


===== build/resources/js/palette/formatter.ts =====
/**
 * Format text with semantic color tags
 * Supports: {success}, {error}, {warning}, {accent}, {primary}, {secondary}, {link:url}
 */

export function formatText(text: string): string {
  if (!text || typeof text !== 'string') return ''

  let result = escapeHtml(text)

  // Semantic color tags
  result = result.replace(/\{success\}(.*?)\{\/\}/g, '<span class="fmt-success">$1</span>')
  result = result.replace(/\{error\}(.*?)\{\/\}/g, '<span class="fmt-error">$1</span>')
  result = result.replace(/\{warning\}(.*?)\{\/\}/g, '<span class="fmt-warning">$1</span>')
  result = result.replace(/\{accent\}(.*?)\{\/\}/g, '<span class="fmt-accent">$1</span>')
  result = result.replace(/\{primary\}(.*?)\{\/\}/g, '<span class="fmt-primary">$1</span>')
  result = result.replace(/\{secondary\}(.*?)\{\/\}/g, '<span class="fmt-secondary">$1</span>')

  // Text formatting
  result = result.replace(/\{bold\}(.*?)\{\/\}/g, '<strong>$1</strong>')
  result = result.replace(/\{dim\}(.*?)\{\/\}/g, '<span class="fmt-dim">$1</span>')
  result = result.replace(/\{code\}(.*?)\{\/\}/g, '<code class="fmt-code">$1</code>')

  // Links - sanitize URLs
  result = result.replace(/\{link:(.*?)\}(.*?)\{\/\}/g, (match, url, text) => {
    const sanitizedUrl = sanitizeUrl(url)
    return `<a href="${sanitizedUrl}" class="fmt-link" target="_blank" rel="noopener noreferrer">${text}</a>`
  })

  return result
}

/**
 * Basic HTML escape to prevent XSS
 */
function escapeHtml(text: string): string {
  const div = document.createElement('div')
  div.textContent = text
  return div.innerHTML
}

/**
 * Sanitize URL to prevent javascript: and data: URLs
 */
function sanitizeUrl(url: string): string {
  const trimmed = url.trim().toLowerCase()

  // Block dangerous protocols
  if (
    trimmed.startsWith('javascript:') ||
    trimmed.startsWith('data:') ||
    trimmed.startsWith('vbscript:')
  ) {
    return '#'
  }

  // Allow http, https, mailto, relative paths
  if (
    trimmed.startsWith('http://') ||
    trimmed.startsWith('https://') ||
    trimmed.startsWith('mailto:') ||
    trimmed.startsWith('/') ||
    trimmed.startsWith('./')
  ) {
    return url
  }

  // Default to relative path
  return `/${url}`
}

/**
 * Helper to format money
 */
export function formatMoney(amount: number | string, currency = 'USD'): string {
  const num = typeof amount === 'string' ? parseFloat(amount) : amount
  if (isNaN(num)) return String(amount)

  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency,
  }).format(num)
}

/**
 * Helper to format date
 */
export function formatDate(date: string | Date): string {
  const d = typeof date === 'string' ? new Date(date) : date
  if (isNaN(d.getTime())) return String(date)

  return new Intl.DateTimeFormat('en-US', {
    year: 'numeric',
    month: 'short',
    day: 'numeric',
  }).format(d)
}


===== build/resources/js/palette/frecency.ts =====
export interface FrecencyEntry {
  command: string
  count: number
  lastUsed: number
}

const STORAGE_KEY = 'palette-frecency-v1'

function load(): Record<string, FrecencyEntry> {
  try {
    const raw = localStorage.getItem(STORAGE_KEY)
    return raw ? JSON.parse(raw) : {}
  } catch {
    return {}
  }
}

function save(entries: Record<string, FrecencyEntry>) {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(entries))
  } catch {
    /* ignore storage errors */
  }
}

export function recordCommandUse(command: string): void {
  const entries = load()
  const key = command.trim()
  if (!key) return

  const existing = entries[key] || { command: key, count: 0, lastUsed: Date.now() }
  entries[key] = {
    command: key,
    count: existing.count + 1,
    lastUsed: Date.now(),
  }

  save(entries)
}

export function getFrecencyScores(): Record<string, number> {
  const now = Date.now()
  const entries = load()
  const scores: Record<string, number> = {}

  Object.values(entries).forEach((entry) => {
    const daysSince = (now - entry.lastUsed) / (1000 * 60 * 60 * 24)
    const recencyWeight = Math.max(0.2, 1 - daysSince / 7) // decays over 7 days
    scores[entry.command] = entry.count * recencyWeight
  })

  return scores
}


===== build/resources/js/palette/grammar.ts =====
import type { EntityDefinition } from '@/types/palette'

/**
 * Entity icons
 */
export const ENTITY_ICONS: Record<string, string> = {
  company: 'üè¢',
  user: 'üë§',
  role: 'üîë',
  customer: 'üë•',
  invoice: 'üìÑ',
  payment: 'üí∞',
  account: 'üìí',
  journal: 'üìî',
}

/**
 * Command descriptions
 */
export const COMMAND_DESCRIPTIONS: Record<string, string> = {
  'company.create': 'Create a new company',
  'company.list': 'Show all companies you have access to',
  'company.view': 'View company details',
  'company.switch': 'Switch to a different company',
  'company.delete': 'Delete a company (cannot be undone)',

  'user.invite': 'Invite a new user to the company',
  'user.list': 'Show all users in the company',
  'user.view': 'View user details',
  'user.assign-role': 'Assign a role to a user',
  'user.remove-role': 'Remove a role from a user',
  'user.deactivate': 'Deactivate a user account',
  'user.activate': 'Activate a deactivated user',
  'user.delete': 'Delete a user (cannot be undone)',

  'role.list': 'Show all available roles',
  'role.view': 'View role details and permissions',
  'role.assign': 'Assign a permission to a role',
  'role.revoke': 'Revoke a permission from a role',

  // Customer
  'customer.create': 'Create a new customer',
  'customer.list': 'List all customers',
  'customer.view': 'View customer details and stats',
  'customer.update': 'Update customer information',
  'customer.delete': 'Deactivate a customer',
  'customer.restore': 'Restore a deactivated customer',

  // Invoice
  'invoice.create': 'Create a new invoice',
  'invoice.list': 'List invoices (filter by status, customer)',
  'invoice.view': 'View invoice details and payments',
  'invoice.send': 'Mark as sent / email to customer',
  'invoice.void': 'Void an invoice',
  'invoice.duplicate': 'Create a copy of an invoice',

  // Payment
  'payment.create': 'Record a payment on an invoice',
  'payment.list': 'List payment history',
  'payment.void': 'Void/reverse a payment',

  // Accounting
  'account.list': 'Chart of accounts',
  'account.view': 'View account details',
  'account.create': 'Create a new account',

  'journal.create': 'Create a journal entry',
  'journal.list': 'List journal entries',
  'journal.view': 'View journal entry',

  'help': 'Show available commands',
  'clear': 'Clear output history',
}

/**
 * Command grammar definitions
 *
 * Each entity defines:
 * - name: canonical name
 * - shortcuts: short aliases (e.g., "co" for "company")
 * - defaultVerb: verb used when only entity is specified
 * - verbs: available operations with their flags
 */
export const GRAMMAR: Record<string, EntityDefinition> = {
  company: {
    name: 'company',
    shortcuts: ['co', 'comp'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'create',
        aliases: ['new', 'add'],
        requiresSubject: true,
        flags: [
          { name: 'name', type: 'string', required: true },
          { name: 'currency', type: 'string', required: true },
          { name: 'industry', type: 'string', required: false },
          { name: 'country', type: 'string', required: false },
        ],
      },
      {
        name: 'list',
        aliases: ['ls', 'all', 'show'],
        requiresSubject: false,
        flags: [],
      },
      {
        name: 'view',
        aliases: ['get', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'slug', type: 'string', required: true },
        ],
      },
      {
        name: 'switch',
        aliases: ['sw', 'use', 'select'],
        requiresSubject: true,
        flags: [
          { name: 'slug', type: 'string', required: true },
        ],
      },
      {
        name: 'delete',
        aliases: ['del', 'rm', 'remove'],
        requiresSubject: true,
        flags: [
          { name: 'slug', type: 'string', required: true },
        ],
      },
    ],
  },

  user: {
    name: 'user',
    shortcuts: ['u', 'usr'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'invite',
        aliases: ['add', 'new'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
          { name: 'role', type: 'string', required: false, default: 'member' },
          { name: 'name', type: 'string', required: false },
        ],
      },
      {
        name: 'list',
        aliases: ['ls', 'all', 'show'],
        requiresSubject: false,
        flags: [],
      },
      {
        name: 'view',
        aliases: ['get', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
      {
        name: 'assign-role',
        aliases: ['assign', 'grant'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
      {
        name: 'remove-role',
        aliases: ['revoke', 'unassign'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
      {
        name: 'deactivate',
        aliases: ['disable', 'suspend'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
      {
        name: 'activate',
        aliases: ['enable', 'restore'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
      {
        name: 'delete',
        aliases: ['del', 'rm', 'remove'],
        requiresSubject: true,
        flags: [
          { name: 'email', type: 'string', required: true },
        ],
      },
    ],
  },

  role: {
    name: 'role',
    shortcuts: ['r'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'list',
        aliases: ['ls', 'all', 'show'],
        requiresSubject: false,
        flags: [],
      },
      {
        name: 'view',
        aliases: ['get', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'name', type: 'string', required: true },
        ],
      },
      {
        name: 'assign',
        aliases: ['grant', 'give'],
        requiresSubject: true,
        flags: [
          { name: 'permission', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
      {
        name: 'revoke',
        aliases: ['remove', 'take'],
        requiresSubject: true,
        flags: [
          { name: 'permission', type: 'string', required: true },
          { name: 'role', type: 'string', required: true },
        ],
      },
    ],
  },

  customer: {
    name: 'customer',
    shortcuts: ['cust', 'c'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'create',
        aliases: ['new', 'add'],
        requiresSubject: true,
        flags: [
          { name: 'name', type: 'string', required: true },
          { name: 'email', type: 'string', required: false },
          { name: 'phone', type: 'string', required: false },
          { name: 'currency', type: 'string', required: false },
          { name: 'payment_terms', shorthand: 't', type: 'number', required: false },
        ],
      },
      {
        name: 'list',
        aliases: ['ls', 'all'],
        requiresSubject: false,
        flags: [
          { name: 'search', shorthand: 's', type: 'string', required: false },
          { name: 'inactive', type: 'boolean', required: false },
          { name: 'limit', type: 'number', required: false },
        ],
      },
      {
        name: 'view',
        aliases: ['get', 'show', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
        ],
      },
      {
        name: 'update',
        aliases: ['edit', 'modify'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
          { name: 'name', type: 'string', required: false },
          { name: 'email', type: 'string', required: false },
          { name: 'phone', type: 'string', required: false },
          { name: 'currency', type: 'string', required: false },
          { name: 'payment_terms', shorthand: 't', type: 'number', required: false },
        ],
      },
      {
        name: 'delete',
        aliases: ['del', 'rm', 'remove'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
        ],
      },
      {
        name: 'restore',
        aliases: ['undelete', 'reactivate'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
        ],
      },
    ],
  },

  invoice: {
    name: 'invoice',
    shortcuts: ['inv', 'i'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'create',
        aliases: ['new', 'add'],
        requiresSubject: true,
        flags: [
          { name: 'customer', shorthand: 'c', type: 'string', required: true },
          { name: 'amount', shorthand: 'a', type: 'number', required: true },
          { name: 'currency', shorthand: null, type: 'string', required: true },
          { name: 'due', shorthand: 'd', type: 'string', required: false },
          { name: 'description', type: 'string', required: false },
          { name: 'reference', shorthand: 'r', type: 'string', required: false },
          { name: 'draft', type: 'boolean', required: false },
        ],
      },
      {
        name: 'list',
        aliases: ['ls', 'all'],
        requiresSubject: false,
        flags: [
          { name: 'status', shorthand: 's', type: 'string', required: false },
          { name: 'customer', shorthand: 'c', type: 'string', required: false },
          { name: 'unpaid', type: 'boolean', required: false },
          { name: 'overdue', type: 'boolean', required: false },
          { name: 'from', type: 'string', required: false },
          { name: 'to', type: 'string', required: false },
          { name: 'limit', type: 'number', required: false },
        ],
      },
      {
        name: 'view',
        aliases: ['get', 'show', 'info'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
        ],
      },
      {
        name: 'send',
        aliases: ['email', 'deliver'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
          { name: 'email', type: 'boolean', required: false },
          { name: 'to', type: 'string', required: false },
        ],
      },
      {
        name: 'void',
        aliases: ['cancel'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
          { name: 'reason', type: 'string', required: false },
        ],
      },
      {
        name: 'duplicate',
        aliases: ['dup', 'copy', 'clone'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
          { name: 'customer', shorthand: 'c', type: 'string', required: false },
          { name: 'draft', type: 'boolean', required: false },
        ],
      },
    ],
  },

  payment: {
    name: 'payment',
    shortcuts: ['pay', 'p'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'create',
        aliases: ['new', 'add', 'record'],
        requiresSubject: true,
        flags: [
          { name: 'invoice', shorthand: 'i', type: 'string', required: true },
          { name: 'amount', shorthand: 'a', type: 'number', required: true },
          { name: 'method', shorthand: 'm', type: 'string', required: false },
          { name: 'date', shorthand: 'd', type: 'string', required: false },
          { name: 'reference', shorthand: 'r', type: 'string', required: false },
          { name: 'notes', type: 'string', required: false },
        ],
      },
      {
        name: 'list',
        aliases: ['ls', 'all'],
        requiresSubject: false,
        flags: [
          { name: 'invoice', shorthand: 'i', type: 'string', required: false },
          { name: 'customer', shorthand: 'c', type: 'string', required: false },
          { name: 'method', shorthand: 'm', type: 'string', required: false },
          { name: 'from', type: 'string', required: false },
          { name: 'to', type: 'string', required: false },
          { name: 'limit', type: 'number', required: false },
        ],
      },
      {
        name: 'void',
        aliases: ['cancel', 'reverse'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
          { name: 'reason', type: 'string', required: false },
        ],
      },
    ],
  },

  account: {
    name: 'account',
    shortcuts: ['coa', 'acct'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'list',
        aliases: ['ls', 'all', 'chart'],
        requiresSubject: false,
        flags: [],
      },
      {
        name: 'view',
        aliases: ['get', 'show'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
        ],
      },
      {
        name: 'create',
        aliases: ['new', 'add'],
        requiresSubject: true,
        flags: [
          { name: 'name', type: 'string', required: true },
          { name: 'code', type: 'string', required: true },
          { name: 'type', type: 'string', required: true },
        ],
      },
    ],
  },

  journal: {
    name: 'journal',
    shortcuts: ['jr', 'jnl'],
    defaultVerb: 'list',
    verbs: [
      {
        name: 'create',
        aliases: ['new', 'add'],
        requiresSubject: true,
        flags: [
          { name: 'date', type: 'string', required: false },
          { name: 'reference', type: 'string', required: false },
        ],
      },
      {
        name: 'list',
        aliases: ['ls', 'all'],
        requiresSubject: false,
        flags: [
          { name: 'from', type: 'string', required: false },
          { name: 'to', type: 'string', required: false },
        ],
      },
      {
        name: 'view',
        aliases: ['get', 'show'],
        requiresSubject: true,
        flags: [
          { name: 'id', type: 'string', required: true },
        ],
      },
    ],
  },
}

/**
 * Resolve entity shortcut to canonical name
 */
export function resolveEntityShortcut(shortcut: string): string | null {
  const normalized = shortcut.toLowerCase()
  
  for (const [entity, def] of Object.entries(GRAMMAR)) {
    if (entity === normalized || def.shortcuts.includes(normalized)) {
      return entity
    }
  }
  
  return null
}

/**
 * Resolve verb alias to canonical name
 */
export function resolveVerbAlias(entity: string, verb: string): string | null {
  const entityDef = GRAMMAR[entity]
  if (!entityDef) return null
  
  const normalized = verb.toLowerCase()
  
  for (const verbDef of entityDef.verbs) {
    if (verbDef.name === normalized || verbDef.aliases.includes(normalized)) {
      return verbDef.name
    }
  }
  
  return null
}

/**
 * Check if verb is valid for entity
 */
export function isValidVerb(entity: string, verb: string): boolean {
  return resolveVerbAlias(entity, verb) !== null
}

/**
 * Get full verb definition
 */
export function getVerbDefinition(entity: string, verb: string) {
  const entityDef = GRAMMAR[entity]
  if (!entityDef) return null
  
  const resolvedVerb = resolveVerbAlias(entity, verb)
  if (!resolvedVerb) return null
  
  return entityDef.verbs.find(v => v.name === resolvedVerb) || null
}

/**
 * Get all entities
 */
export function getEntities(): string[] {
  return Object.keys(GRAMMAR)
}

/**
 * Get all verbs for an entity
 */
export function getVerbs(entity: string): string[] {
  const entityDef = GRAMMAR[entity]
  if (!entityDef) return []
  return entityDef.verbs.map(v => v.name)
}

/**
 * Command examples for inline placeholder hints
 */
export const COMMAND_EXAMPLES: Record<string, string> = {
  'company.create': 'company create Acme Inc USD',
  'company.list': 'company list',
  'company.view': 'company view acme-corp',
  'company.switch': 'company switch acme-corp',
  'company.delete': 'company delete acme-corp',

  // Customer
  'customer.create': 'customer create "Acme Corp" --email=team@acme.com --currency=USD',
  'customer.list': 'customer list',
  'customer.view': 'customer view "Acme Corp"',
  'customer.update': 'customer update "Acme Corp" --email=new@acme.com',
  'customer.delete': 'customer delete "Acme Corp"',
  'customer.restore': 'customer restore "Acme Corp"',

  'user.invite': 'user invite john@example.com',
  'user.list': 'user list',
  'user.view': 'user view john@example.com',
  'user.assign-role': 'user assign-role john@example.com admin',
  'user.remove-role': 'user remove-role john@example.com admin',
  'user.deactivate': 'user deactivate john@example.com',
  'user.activate': 'user activate john@example.com',
  'user.delete': 'user delete john@example.com',

  // Invoice
  'invoice.create': 'invoice create "Acme Corp" --amount=1200 --currency=USD',
  'invoice.list': 'invoice list --status=sent',
  'invoice.view': 'invoice view INV-1001',
  'invoice.send': 'invoice send INV-1001',
  'invoice.void': 'invoice void INV-1001',
  'invoice.duplicate': 'invoice duplicate INV-1001',

  'role.list': 'role list',
  'role.view': 'role view admin',
  'role.assign': 'role assign users:create admin',
  'role.revoke': 'role revoke users:create admin',

  // Accounting
  'account.list': 'account list',
  'account.create': 'account create 1200 --name="Cash" --type=asset',
  'journal.create': 'journal create --reference=JV-1001',
  'journal.list': 'journal list --from=2024-01-01 --to=2024-01-31',
}

/**
 * Get command example for inline placeholder
 */
export function getCommandExample(entity: string, verb: string): string {
  const key = `${entity}.${verb}`
  return COMMAND_EXAMPLES[key] || ''
}


===== build/resources/js/palette/help.ts =====
import { GRAMMAR } from './grammar'

const MODULE_GROUPS: Record<string, string[]> = {
  sales: ['customer', 'invoice', 'payment'],
  purchases: [],
  accounting: ['account', 'journal'],
  settings: ['company', 'user', 'role'],
}

/**
 * Get help text for a topic
 */
export function getHelp(topic?: string): string {
  if (!topic) {
    return getGeneralHelp()
  }

  const topicLower = topic.toLowerCase()

  if (topicLower === '?' || topicLower === 'help') {
    return getGroupedHelp()
  }

  if (topicLower.startsWith('?')) {
    const group = topicLower.replace('?', '').trim()
    return getGroupedHelp(group)
  }

  if (MODULE_GROUPS[topicLower]) {
    return getGroupedHelp(topicLower)
  }

  // Help for specific entity
  if (GRAMMAR[topicLower]) {
    return getEntityHelp(topicLower)
  }

  // Help for entity.verb
  if (topicLower.includes('.')) {
    const [entity, verb] = topicLower.split('.')
    if (GRAMMAR[entity]) {
      return getVerbHelp(entity, verb)
    }
  }

  // Try to find entity by shortcut
  for (const [entityName, entityDef] of Object.entries(GRAMMAR)) {
    if (entityDef.shortcuts.includes(topicLower)) {
      return getEntityHelp(entityName)
    }
  }

  // Topic not found
  return `Unknown topic: ${topic}\n\nAvailable: ${Object.keys(GRAMMAR).join(', ')}, or type 'help' for overview.`
}

/**
 * General help - list all commands
 */
function getGeneralHelp(): string {
  const lines: string[] = [
    'COMMAND PALETTE',
    '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê',
    '',
    'Usage: entity verb [arguments] [--flags]',
    '',
    'AVAILABLE ENTITIES:',
    '',
  ]

  for (const [entityName, entity] of Object.entries(GRAMMAR)) {
    const shortcuts = entity.shortcuts.length > 0 
      ? ` (${entity.shortcuts.join(', ')})` 
      : ''
    const verbs = entity.verbs.map(v => v.name).join(', ')
    lines.push(`  ${entityName}${shortcuts}`)
    lines.push(`    verbs: ${verbs}`)
    lines.push('')
  }

  lines.push('BUILT-IN COMMANDS:')
  lines.push('')
  lines.push('  help [topic]     Show help (e.g., help company)')
  lines.push("  ? [group]        List namespaces by group (e.g., '? sales')")
  lines.push('  clear            Clear output')
  lines.push('')
  lines.push('SHORTCUTS:')
  lines.push('')
  lines.push('  ‚Üë/‚Üì              Navigate history')
  lines.push('  Tab              Accept suggestion')
  lines.push('  Ctrl+L           Clear output')
  lines.push('  Ctrl+U           Clear input')
  lines.push('  Esc              Close palette')
  lines.push('')
  lines.push('EXAMPLES:')
  lines.push('')
  lines.push('  company.list                    List all companies')
  lines.push('  co.create "Acme Corp" USD       Create company')
  lines.push('  user.invite john@example.com    Invite user')
  lines.push('')
  lines.push('Type "help <entity>" for detailed help (e.g., help company)')

  return lines.join('\n')
}

function getGroupedHelp(group?: string): string {
  const lines: string[] = ['COMMAND CATALOG', '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', '']

  if (!group) {
    lines.push('Groups: sales, purchases, accounting, settings')
    lines.push("Type '? sales' to filter to that group.")
    lines.push('')
  }

  const targetGroups = group ? [group] : Object.keys(MODULE_GROUPS)

  for (const groupName of targetGroups) {
    const entities = MODULE_GROUPS[groupName]
    const hasEntities = entities && entities.length > 0
    if (!hasEntities) {
      if (group) {
        lines.push(`${groupName.toUpperCase()}`)
        lines.push('  (no commands yet)')
        lines.push('')
      }
      continue
    }

    lines.push(`${groupName.toUpperCase()}`)
    lines.push('‚îÄ'.repeat(groupName.length))

    entities.forEach((entityName) => {
      const entity = GRAMMAR[entityName]
      if (!entity) return
      const verbs = entity.verbs.map((v) => v.name).join(', ')
      lines.push(`  ${entityName} (${verbs})`)
    })

    lines.push('')
  }

  return lines.join('\n')
}

/**
 * Help for a specific entity
 */
function getEntityHelp(entityName: string): string {
  const entity = GRAMMAR[entityName]
  if (!entity) return `Unknown entity: ${entityName}`

  const lines: string[] = [
    `${entityName.toUpperCase()}`,
    '‚ïê'.repeat(entityName.length),
    '',
  ]

  if (entity.shortcuts.length > 0) {
    lines.push(`Shortcuts: ${entity.shortcuts.join(', ')}`)
    lines.push('')
  }

  lines.push('COMMANDS:')
  lines.push('')

  for (const verb of entity.verbs) {
    const aliases = verb.aliases.length > 0 
      ? ` (aliases: ${verb.aliases.join(', ')})` 
      : ''
    lines.push(`  ${entityName} ${verb.name}${aliases}`)

    // Show flags
    if (verb.flags.length > 0) {
      for (const flag of verb.flags) {
        const required = flag.required ? ' (required)' : ''
        const shorthand = flag.shorthand ? ` (-${flag.shorthand})` : ''
        const defaultVal = flag.default !== undefined ? ` [default: ${flag.default}]` : ''
        lines.push(`    --${flag.name}${shorthand}: ${flag.type}${required}${defaultVal}`)
      }
    } else {
      lines.push('    (no flags)')
    }

    // Example using canonical entity and verb
    lines.push(`    Example: ${buildExample(entityName, verb)}`)
    lines.push('')
  }

  lines.push('EXAMPLES:')
  lines.push('')
  lines.push(...getEntityExamples(entityName))

  return lines.join('\n')
}

/**
 * Help for a specific verb
 */
function getVerbHelp(entityName: string, verbName: string): string {
  const entity = GRAMMAR[entityName]
  if (!entity) return `Unknown entity: ${entityName}`

  const verb = entity.verbs.find(v => 
    v.name === verbName || v.aliases.includes(verbName)
  )
  if (!verb) return `Unknown verb: ${entityName}.${verbName}`

  const lines: string[] = [
    `${entityName.toUpperCase()} ${verb.name.toUpperCase()}`,
    '‚ïê'.repeat(entityName.length + verb.name.length + 1),
    '',
  ]

  if (verb.aliases.length > 0) {
    lines.push(`Aliases: ${verb.aliases.join(', ')}`)
    lines.push('')
  }

  lines.push('FLAGS:')
  lines.push('')

  if (verb.flags.length > 0) {
    for (const flag of verb.flags) {
      const required = flag.required ? ' (required)' : ''
      const shorthand = flag.shorthand ? `, -${flag.shorthand}` : ''
      const defaultVal = flag.default !== undefined ? `\n      Default: ${flag.default}` : ''
      lines.push(`  --${flag.name}${shorthand}`)
      lines.push(`      Type: ${flag.type}${required}${defaultVal}`)
      lines.push('')
    }
  } else {
    lines.push('  (no flags)')
    lines.push('')
  }

  lines.push('EXAMPLES:')
  lines.push('')
  lines.push(`  ${buildExample(entityName, verb)}`)
  lines.push(...getVerbExamples(entityName, verb.name))

  return lines.join('\n')
}

/**
 * Get example commands for an entity
 */
function getEntityExamples(entityName: string): string[] {
  const examples: Record<string, string[]> = {
    company: [
      '  company list',
      '  company create "Acme Corp" USD',
      '  co create "My Company" USD --industry=tech',
      '  company switch acme-corp',
      '  company delete acme-corp',
    ],
    user: [
      '  user list',
      '  user invite john@example.com',
      '  user invite jane@example.com --role=admin',
      '  user assign-role john@example.com --role=accountant',
      '  user deactivate john@example.com',
    ],
    role: [
      '  role list',
      '  role assign --permission=invoice:create --role=accountant',
      '  role revoke --permission=invoice:delete --role=member',
    ],
  }

  return examples[entityName] || ['  (no examples available)']
}

/**
 * Get example commands for a specific verb
 */
function getVerbExamples(entityName: string, verbName: string): string[] {
  const key = `${entityName}.${verbName}`
  const examples: Record<string, string[]> = {
    'company.list': [
      '  company list',
      '  co list',
    ],
    'company.create': [
      '  company create "Acme Corp" USD',
      '  co create "My Company" CAD',
      '  company create --name="Big Corp" --currency=EUR --industry=finance',
    ],
    'company.switch': [
      '  company switch acme-corp',
      '  co switch my-company',
    ],
    'company.delete': [
      '  company delete acme-corp',
      '  co delete old-company',
    ],
    'user.list': [
      '  user list',
      '  u list',
    ],
    'user.invite': [
      '  user invite john@example.com',
      '  user invite jane@example.com --role=admin',
      '  u invite test@test.com --name="John Doe"',
    ],
    'user.assign-role': [
      '  user assign-role john@example.com --role=admin',
      '  user assign --email=jane@example.com --role=accountant',
    ],
    'user.deactivate': [
      '  user deactivate john@example.com',
      '  user disable --email=test@test.com',
    ],
    'role.list': [
      '  role list',
      '  r list',
    ],
  }

  return examples[key] || ['  (no examples available)']
}

function buildExample(
  entityName: string,
  verb: { name: string; flags: Array<{ name: string; required: boolean }>; requiresSubject: boolean }
): string {
  const base = `${entityName}.${verb.name}`
  const requiredFlags = verb.flags
    .filter(f => f.required)
    .map(f => `--${f.name}=<${f.name}>`)
    .join(' ')

  const subjectHint = verb.requiresSubject ? '<value>' : ''
  return [base, subjectHint, requiredFlags].filter(Boolean).join(' ').trim()
}


===== build/resources/js/palette/parser.ts =====
import type { ParsedCommand } from '@/types/palette'
import { GRAMMAR, resolveEntityShortcut, resolveVerbAlias, getVerbDefinition } from './grammar'
import { expandPresetShortcut } from './shortcuts'

/**
 * Parse a command string into a structured ParsedCommand
 */
export function parse(input: string): ParsedCommand {
  const normalizedInput = expandPresetShortcut(input)
  const result: ParsedCommand = {
    raw: normalizedInput.trim(),
    entity: '',
    verb: '',
    flags: {},
    complete: false,
    confidence: 0,
    errors: [],
    idemKey: '',
  }

  if (!result.raw) {
    result.errors.push('Empty command')
    return result
  }

  const tokens = tokenize(result.raw)
  
  if (tokens.length === 0) {
    result.errors.push('No tokens found')
    return result
  }

  const first = tokens[0]
  let rest = tokens.slice(1)

  // Parse entity.verb
  const entityVerb = parseEntityVerb(first, rest)
  if (entityVerb) {
    result.entity = entityVerb.entity
    result.verb = entityVerb.verb
    if (entityVerb.consumed > 1) {
      rest = rest.slice(entityVerb.consumed - 1)
    }
  } else {
    result.errors.push(`Unknown command: ${first}`)
    return result
  }

  // Extract flags and remaining positional args
  const { flags, remaining, flagErrors } = extractFlags(rest, result.entity, result.verb)
  result.flags = flags
  result.errors.push(...flagErrors)

  // Set subject from remaining tokens
  if (remaining.length > 0) {
    result.subject = remaining.join(' ')
  }

  // Infer flags from subject (smart parsing)
  inferFromSubject(result)

  // Calculate completion status
  result.complete = isComplete(result)
  result.confidence = calculateConfidence(result)
  result.idemKey = generateIdemKey(result)

  return result
}

/**
 * Parse entity.verb from tokens
 */
function parseEntityVerb(
  token: string, 
  remainingTokens: string[]
): { entity: string; verb: string; consumed: number } | null {
  
  // Handle "entity.verb" format
  if (token.includes('.')) {
    const [entityPart, verbPart] = token.split('.')
    const entity = resolveEntityShortcut(entityPart)
    if (!entity) return null
    
    const verb = resolveVerbAlias(entity, verbPart)
    if (!verb) return null
    
    return { entity, verb, consumed: 1 }
  }

  // Handle "entity verb" format (space separated)
  const entity = resolveEntityShortcut(token)
  if (entity) {
    if (remainingTokens.length > 0) {
      const candidateVerb = resolveVerbAlias(entity, remainingTokens[0])
      if (candidateVerb) {
        return { entity, verb: candidateVerb, consumed: 2 }
      }
    }
    // Use default verb
    return { entity, verb: GRAMMAR[entity].defaultVerb, consumed: 1 }
  }

  return null
}

/**
 * Tokenize input, respecting quotes
 */
function tokenize(input: string): string[] {
  const tokens: string[] = []
  let current = ''
  let inQuotes = false
  let quoteChar = ''

  for (const char of input) {
    if ((char === '"' || char === "'") && !inQuotes) {
      inQuotes = true
      quoteChar = char
    } else if (char === quoteChar && inQuotes) {
      inQuotes = false
      quoteChar = ''
    } else if (char === ' ' && !inQuotes) {
      if (current) {
        tokens.push(current)
        current = ''
      }
    } else {
      current += char
    }
  }

  if (current) tokens.push(current)
  return tokens
}

/**
 * Extract flags from tokens
 */
function extractFlags(
  tokens: string[],
  entity: string,
  verb: string
): { flags: Record<string, unknown>; remaining: string[]; flagErrors: string[] } {
  const flags: Record<string, unknown> = {}
  const remaining: string[] = []
  const errors: string[] = []

  const verbDef = getVerbDefinition(entity, verb)
  if (!verbDef) {
    return { flags, remaining: tokens, flagErrors: errors }
  }

  let i = 0
  while (i < tokens.length) {
    const token = tokens[i]

    if (token.startsWith('--')) {
      const { name, value, consumed, error } = parseLongFlag(token, tokens[i + 1], verbDef.flags)
      if (error) errors.push(error)
      else if (name) flags[name] = value
      i += consumed
    } else if (token.startsWith('-') && token.length === 2) {
      const { name, value, consumed, error } = parseShortFlag(token, tokens[i + 1], verbDef.flags)
      if (error) errors.push(error)
      else if (name) flags[name] = value
      i += consumed
    } else {
      remaining.push(token)
      i++
    }
  }

  return { flags, remaining, flagErrors: errors }
}

/**
 * Parse --flag or --flag=value
 */
function parseLongFlag(
  token: string,
  nextToken: string | undefined,
  flagDefs: Array<{ name: string; shorthand?: string; type: string; required: boolean; default?: unknown }>
): { name: string | null; value: unknown; consumed: number; error: string | null } {
  const withoutDashes = token.substring(2)
  
  // Handle --flag=value
  if (withoutDashes.includes('=')) {
    const [name, ...valueParts] = withoutDashes.split('=')
    const value = valueParts.join('=')
    const flagDef = flagDefs.find(f => f.name === name)
    
    if (!flagDef) {
      return { name: null, value: null, consumed: 1, error: `Unknown flag: --${name}` }
    }
    
    return { name, value: coerceValue(value, flagDef.type), consumed: 1, error: null }
  }

  // Handle --flag value or --flag (boolean)
  const flagDef = flagDefs.find(f => f.name === withoutDashes)
  
  if (!flagDef) {
    return { name: null, value: null, consumed: 1, error: `Unknown flag: --${withoutDashes}` }
  }

  if (flagDef.type === 'boolean') {
    return { name: withoutDashes, value: true, consumed: 1, error: null }
  }

  if (!nextToken || nextToken.startsWith('-')) {
    return { name: null, value: null, consumed: 1, error: `Flag --${withoutDashes} requires a value` }
  }

  return { name: withoutDashes, value: coerceValue(nextToken, flagDef.type), consumed: 2, error: null }
}

/**
 * Parse -f or -f value
 */
function parseShortFlag(
  token: string,
  nextToken: string | undefined,
  flagDefs: Array<{ name: string; shorthand?: string; type: string; required: boolean }>
): { name: string | null; value: unknown; consumed: number; error: string | null } {
  const shorthand = token[1]
  const flagDef = flagDefs.find(f => f.shorthand === shorthand)
  
  if (!flagDef) {
    return { name: null, value: null, consumed: 1, error: `Unknown flag: -${shorthand}` }
  }

  if (flagDef.type === 'boolean') {
    return { name: flagDef.name, value: true, consumed: 1, error: null }
  }

  if (!nextToken || nextToken.startsWith('-')) {
    return { name: null, value: null, consumed: 1, error: `Flag -${shorthand} requires a value` }
  }

  return { name: flagDef.name, value: coerceValue(nextToken, flagDef.type), consumed: 2, error: null }
}

/**
 * Coerce string value to appropriate type
 */
function coerceValue(value: string, type: string): unknown {
  if (type === 'number') {
    const num = parseFloat(value)
    return isNaN(num) ? value : num
  }
  
  if (type === 'boolean') {
    return value.toLowerCase() === 'true' || value === '1'
  }
  
  return value
}

/**
 * Infer flag values from positional subject
 */
function inferFromSubject(result: ParsedCommand): void {
  if (!result.subject) return

  const words = result.subject.split(/\s+/)

  // Customer create: accept positional name [email] [currency]
  if (result.entity === 'customer' && result.verb === 'create') {
    let email: string | undefined
    let currency: string | undefined

    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    const parts: string[] = []

    for (const word of words) {
      if (!email && emailRegex.test(word)) {
        email = word
        continue
      }
      if (
        !currency &&
        word.length === 3 &&
        /^[A-Za-z]{3}$/.test(word)
      ) {
        currency = word.toUpperCase()
        continue
      }
      parts.push(word)
    }

    if (!result.flags.email && email) {
      result.flags.email = email
    }
    if (!result.flags.currency && currency) {
      result.flags.currency = currency
    }
    if (!result.flags.name) {
      const name = parts.join(' ').trim()
      if (name) {
        result.flags.name = name
      }
    }
  }

  // Invoice create: positional customer, amount, currency
  if (result.entity === 'invoice' && result.verb === 'create') {
    let amount: number | undefined
    let currency: string | undefined
    const parts: string[] = []

    for (const word of words) {
      if (!amount && /^\$?[\d,]+\.?\d*$/.test(word)) {
        const num = parseFloat(word.replace(/[,$]/g, ''))
        if (!isNaN(num)) {
          amount = num
          continue
        }
      }

      if (!currency && /^[A-Za-z]{3}$/.test(word)) {
        currency = word.toUpperCase()
        continue
      }

      parts.push(word)
    }

    if (!result.flags.amount && amount !== undefined) {
      result.flags.amount = amount
    }
    if (!result.flags.currency && currency) {
      result.flags.currency = currency
    }
    if (!result.flags.customer) {
      const name = parts.join(' ').trim()
      if (name) {
        result.flags.customer = name
      }
    }
  }

  // Payment create: positional invoice, amount
  if (result.entity === 'payment' && result.verb === 'create') {
    let amount: number | undefined
    const parts: string[] = []

    for (const word of words) {
      if (!amount && /^\$?[\d,]+\.?\d*$/.test(word)) {
        const num = parseFloat(word.replace(/[,$]/g, ''))
        if (!isNaN(num)) {
          amount = num
          continue
        }
      }
      parts.push(word)
    }

    if (!result.flags.amount && amount !== undefined) {
      result.flags.amount = amount
    }
    if (!result.flags.invoice) {
      const invoiceToken = parts.join(' ').trim()
      if (invoiceToken) {
        result.flags.invoice = invoiceToken
      }
    }
  }

  // Company create: "company.create Acme Corp USD"
  if (result.entity === 'company' && result.verb === 'create') {
    if (!result.flags.name && words.length > 0) {
      // Find currency (3 uppercase letters at the end)
      const lastWord = words[words.length - 1]
      if (lastWord && lastWord.length === 3 && lastWord.toUpperCase() === lastWord) {
        result.flags.currency = lastWord.toUpperCase()
        result.flags.name = words.slice(0, -1).join(' ')
      } else {
        // No currency found, entire subject is name
        result.flags.name = result.subject
      }
    }
  }

  // Company switch/delete: "company.switch acme-corp"
  if (result.entity === 'company' && ['switch', 'delete', 'view'].includes(result.verb)) {
    if (!result.flags.slug && words.length > 0) {
      result.flags.slug = words.join('-').toLowerCase()
    }
  }

  // User invite: "user.invite john@example.com"
  if (result.entity === 'user' && result.verb === 'invite') {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    const emailWord = words.find(w => emailRegex.test(w))
    
    if (emailWord && !result.flags.email) {
      result.flags.email = emailWord
      // Remaining words could be name
      const nameWords = words.filter(w => w !== emailWord)
      if (nameWords.length > 0 && !result.flags.name) {
        result.flags.name = nameWords.join(' ')
      }
    }
  }

  // User operations with email: deactivate, delete, assign-role
  if (result.entity === 'user' && ['deactivate', 'delete', 'assign-role', 'remove-role'].includes(result.verb)) {
    if (!result.flags.email && words.length > 0) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
      const emailWord = words.find(w => emailRegex.test(w))
      if (emailWord) {
        result.flags.email = emailWord
      }
    }
  }
}

/**
 * Check if command has all required flags
 */
function isComplete(result: ParsedCommand): boolean {
  if (result.errors.length > 0) return false
  if (!result.entity || !result.verb) return false

  const verbDef = getVerbDefinition(result.entity, result.verb)
  if (!verbDef) return false

  const requiredFlags = verbDef.flags.filter(f => f.required)
  for (const flag of requiredFlags) {
    if (!(flag.name in result.flags)) {
      return false
    }
  }

  return true
}

/**
 * Calculate confidence score (0-1)
 */
function calculateConfidence(result: ParsedCommand): number {
  if (!result.entity || !result.verb) return 0
  if (result.errors.length > 0) return 0.3

  const verbDef = getVerbDefinition(result.entity, result.verb)
  if (!verbDef) return 0

  const totalFlags = verbDef.flags.length
  const providedFlags = Object.keys(result.flags).length

  if (totalFlags === 0) return 1

  const flagScore = providedFlags / totalFlags
  return result.complete ? 1 : Math.min(0.9, flagScore)
}

/**
 * Generate idempotency key for the command
 */
function generateIdemKey(result: ParsedCommand): string {
  if (!result.complete) return ''
  
  const parts = [
    result.entity,
    result.verb,
    ...Object.entries(result.flags)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => `${k}=${v}`),
  ]
  
  return btoa(parts.join('|')).substring(0, 32)
}


===== build/resources/js/palette/quick-actions.ts =====
import type { QuickAction, TableState } from '@/types/palette'

/**
 * Quick Actions System
 *
 * Provides numbered shortcuts for common actions after list commands.
 * Actions are context-aware and can be row-specific.
 */

/**
 * Get quick actions for a given entity/verb combination
 */
export function getQuickActions(entity: string, verb: string): QuickAction[] {
  const key = `${entity}.${verb}`

  switch (key) {
    case 'company.list':
      return [
        {
          key: '1',
          label: 'Switch to company',
          command: 'company switch {slug}',
          needsRow: true,
        },
        {
          key: '2',
          label: 'View details',
          command: 'company view {slug}',
          needsRow: true,
        },
        {
          key: '3',
          label: 'Assign user',
          command: 'user invite',
          needsRow: true,
          prompt: 'Enter user email (optionally add role, e.g., jane@x.com --role owner)',
        },
        {
          key: '4',
          label: 'Create new company',
          command: 'company create',
          needsRow: false,
          prompt: 'Enter company name and currency (e.g., Acme Inc USD)',
        },
        {
          key: '0',
          label: 'Delete company',
          command: 'company delete {slug}',
          needsRow: true,
        },
      ]

    case 'user.list':
      return [
        {
          key: '1',
          label: 'View user',
          command: 'user view {email}',
          needsRow: true,
        },
        {
          key: '2',
          label: 'Assign role',
          command: 'user assign-role {email}',
          needsRow: true,
          prompt: 'Enter role name',
        },
        {
          key: '3',
          label: 'Deactivate user',
          command: 'user deactivate {email}',
          needsRow: true,
        },
        {
          key: '4',
          label: 'Invite new user',
          command: 'user invite',
          needsRow: false,
          prompt: 'Enter email address',
        },
      ]

    case 'role.list':
      return [
        {
          key: '1',
          label: 'View role',
          command: 'role view {name}',
          needsRow: true,
        },
        {
          key: '2',
          label: 'Assign permission',
          command: 'role assign',
          needsRow: true,
          prompt: 'Enter permission name',
        },
        {
          key: '3',
          label: 'Revoke permission',
          command: 'role revoke',
          needsRow: true,
          prompt: 'Enter permission name',
        },
      ]

    default:
      return []
  }
}

/**
 * Check if entity.verb combination supports quick actions
 */
export function hasQuickActions(entity: string, verb: string): boolean {
  return getQuickActions(entity, verb).length > 0
}

/**
 * Resolve command template with row data
 *
 * @param template - Command template with {field} placeholders
 * @param tableState - Current table state
 * @returns Resolved command string
 */
export function resolveQuickActionCommand(
  template: string,
  tableState: TableState | null
): string | null {
  if (!template) return null

  // If template has no placeholders, return as-is
  if (!template.includes('{')) {
    return template
  }

  // Need table state to resolve placeholders
  if (!tableState) return null

  const { headers, rows, selectedRowIndex } = tableState

  // Need a selected row
  if (selectedRowIndex < 0 || selectedRowIndex >= rows.length) {
    return null
  }

  const selectedRow = rows[selectedRowIndex]
  let resolved = template

  // Replace {field} placeholders with row values
  // Match headers to find the right column
  headers.forEach((header, index) => {
    const value = selectedRow[index] || ''
    const normalizedHeader = header.toLowerCase().replace(/\s+/g, '')

    // Try to match common patterns
    const patterns = [
      `{${normalizedHeader}}`,
      `{${header.toLowerCase()}}`,
      `{${header}}`,
    ]

    patterns.forEach(pattern => {
      resolved = resolved.replace(new RegExp(pattern.replace(/[{}]/g, '\\$&'), 'g'), value)
    })
  })

  // Handle common field name mappings
  const mappings: Record<string, string[]> = {
    slug: ['slug', 'id', 'name', 'company'],
    email: ['email', 'user', 'emailaddress'],
    name: ['name', 'rolename', 'role'],
  }

  Object.entries(mappings).forEach(([placeholder, possibleHeaders]) => {
    const pattern = `{${placeholder}}`
    if (resolved.includes(pattern)) {
      // Find matching header
      for (const possibleHeader of possibleHeaders) {
        const headerIndex = headers.findIndex(h =>
          h.toLowerCase().replace(/\s+/g, '') === possibleHeader
        )
        if (headerIndex >= 0) {
          const value = selectedRow[headerIndex] || ''
          resolved = resolved.replace(new RegExp(pattern.replace(/[{}]/g, '\\$&'), 'g'), value)
          break
        }
      }
    }
  })

  // If still has unresolved placeholders, return null
  if (resolved.includes('{')) {
    return null
  }

  return resolved.trim()
}

/**
 * Get display label with row data
 *
 * @param action - Quick action
 * @param tableState - Current table state
 * @returns Display label with context
 */
export function getQuickActionLabel(
  action: QuickAction,
  tableState: TableState | null
): string {
  if (!action.needsRow || !tableState) {
    return action.label
  }

  const { headers, rows, selectedRowIndex } = tableState

  if (selectedRowIndex < 0 || selectedRowIndex >= rows.length) {
    return action.label
  }

  const selectedRow = rows[selectedRowIndex]

  // Try to find a meaningful identifier from the row
  // Priority: name/slug/email -> first column -> generic
  const identifierHeaders = ['name', 'slug', 'email', 'company']
  let identifier = ''

  for (const headerName of identifierHeaders) {
    const headerIndex = headers.findIndex(h =>
      h.toLowerCase().replace(/\s+/g, '') === headerName
    )
    if (headerIndex >= 0 && selectedRow[headerIndex]) {
      identifier = selectedRow[headerIndex]
      break
    }
  }

  // Fallback to first column
  if (!identifier && selectedRow.length > 0) {
    identifier = selectedRow[0]
  }

  if (!identifier) {
    return action.label
  }

  // Append identifier to label
  return `${action.label}: ${identifier}`
}


===== build/resources/js/palette/scaffold.ts =====
import type { ParsedCommand } from '@/types/palette'
import type { CommandSchema } from './schemas'

export interface ScaffoldState {
  skeleton: string
  pointerLabel: string
  currentArg?: string
  requiredRemaining: string[]
  optionalFlags: Array<{ name: string; value?: string; source?: string; loading?: boolean }>
  ghosts: Array<{ label: string; completed: boolean }>
}

export function buildScaffold(
  parsed: ParsedCommand,
  schema: CommandSchema | null,
  context: { companyName?: string; companyCurrency?: string; defaults?: Record<string, { value: string; source?: string }> }
  ,
  activeArg?: string
): ScaffoldState | null {
  if (!schema) return null

  const tokens: string[] = []
  const requiredRemaining: string[] = []
  const ghosts: Array<{ label: string; completed: boolean }> = []

  schema.args.forEach(arg => {
    const hasValue = Boolean(parsed.flags?.[arg.name] || parsed.subject)
    if (arg.required && !hasValue) {
      requiredRemaining.push(arg.name)
    }
    tokens.push(arg.required ? `<${arg.name}>` : `[${arg.name}]`)
    ghosts.push({ label: arg.name, completed: hasValue })
  })

  const flagChips = schema.flags.map(flag => {
    const def = context.defaults?.[flag.name]
    const value = (parsed.flags?.[flag.name] as string) || def?.value
    const source = parsed.flags?.[flag.name] ? 'user' : def?.source
    return { name: flag.name, value, source }
  })

  const skeleton = `${schema.entity} ${schema.verb} ${tokens.join(' ')}`
  const currentArg = activeArg || requiredRemaining[0]
  const pointerLabel = currentArg
    ? `${currentArg}${schema.args.find(a => a.name === currentArg)?.hint ? ` (${schema.args.find(a => a.name === currentArg)?.hint})` : ''}`
    : 'Ready'

  return {
    skeleton,
    pointerLabel,
    currentArg,
    requiredRemaining,
    optionalFlags: flagChips,
    ghosts,
  }
}


===== build/resources/js/palette/schemas.ts =====
export type ArgDefinition = {
  name: string
  type: 'string' | 'number' | 'date' | 'currency' | 'reference'
  required: boolean
  hint?: string
}

export type FlagDefinition = {
  name: string
  short?: string | null
  type: 'string' | 'number' | 'date' | 'currency' | 'enum' | 'boolean'
  required?: boolean
  hint?: string
  defaultSource?: string
  values?: string[]
}

export type CommandSchema = {
  entity: string
  verb: string
  description?: string
  args: ArgDefinition[]
  flags: FlagDefinition[]
}

const SCHEMAS: Record<string, CommandSchema> = {}

function register(schema: CommandSchema) {
  SCHEMAS[`${schema.entity}.${schema.verb}`] = schema
}

register({
  entity: 'invoice',
  verb: 'create',
  description: 'Create a new invoice',
  args: [
    { name: 'customer', type: 'reference', required: true, hint: 'Customer name or ID' },
    { name: 'amount', type: 'currency', required: true, hint: 'Invoice amount' },
    { name: 'currency', type: 'currency', required: true, hint: 'ISO currency (e.g., USD)' },
  ],
  flags: [
    { name: 'due', short: 'd', type: 'date', hint: 'Due date (YYYY-MM-DD or +30d)', defaultSource: 'customer.payment_terms' },
    { name: 'reference', short: 'r', type: 'string', hint: 'PO number or reference' },
    { name: 'description', type: 'string', hint: 'Description / memo' },
    { name: 'draft', type: 'boolean', hint: 'Save as draft' },
  ],
})

register({
  entity: 'invoice',
  verb: 'list',
  description: 'List invoices',
  args: [],
  flags: [
    { name: 'status', short: 's', type: 'enum', values: ['draft', 'sent', 'posted', 'overdue', 'paid', 'cancelled'], hint: 'Status filter' },
    { name: 'customer', short: 'c', type: 'string', hint: 'Customer filter' },
    { name: 'unpaid', type: 'boolean', hint: 'Unpaid only' },
    { name: 'overdue', type: 'boolean', hint: 'Overdue only' },
    { name: 'from', type: 'date', hint: 'Start date' },
    { name: 'to', type: 'date', hint: 'End date' },
  ],
})

register({
  entity: 'invoice',
  verb: 'view',
  description: 'View an invoice',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Invoice ID or number' },
  ],
  flags: [],
})

register({
  entity: 'invoice',
  verb: 'send',
  description: 'Send an invoice',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Invoice ID or number' },
  ],
  flags: [
    { name: 'email', type: 'boolean', hint: 'Send via email' },
    { name: 'to', type: 'string', hint: 'Recipient email' },
  ],
})

register({
  entity: 'invoice',
  verb: 'void',
  description: 'Void an invoice',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Invoice ID or number' },
  ],
  flags: [
    { name: 'reason', type: 'string', hint: 'Reason' },
  ],
})

register({
  entity: 'invoice',
  verb: 'duplicate',
  description: 'Duplicate an invoice',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Invoice ID or number' },
  ],
  flags: [],
})

register({
  entity: 'payment',
  verb: 'create',
  description: 'Record a payment',
  args: [
    { name: 'invoice', type: 'reference', required: true, hint: 'Invoice number or ID' },
    { name: 'amount', type: 'currency', required: true, hint: 'Payment amount' },
  ],
  flags: [
    { name: 'method', short: 'm', type: 'enum', values: ['cash', 'check', 'card', 'bank_transfer', 'other'], defaultSource: 'user.pref.method' },
    { name: 'reference', short: 'r', type: 'string', hint: 'Reference or note' },
    { name: 'date', short: 'd', type: 'date', hint: 'Payment date', defaultSource: 'system.today' },
  ],
})

register({
  entity: 'payment',
  verb: 'list',
  description: 'List payments',
  args: [],
  flags: [
    { name: 'invoice', type: 'string', hint: 'Invoice filter' },
    { name: 'customer', type: 'string', hint: 'Customer filter' },
    { name: 'method', type: 'enum', values: ['cash', 'check', 'card', 'bank_transfer', 'other'], hint: 'Method filter' },
    { name: 'from', type: 'date', hint: 'Start date' },
    { name: 'to', type: 'date', hint: 'End date' },
  ],
})

register({
  entity: 'payment',
  verb: 'void',
  description: 'Void a payment',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Payment ID or number' },
  ],
  flags: [
    { name: 'reason', type: 'string', hint: 'Reason' },
  ],
})

register({
  entity: 'customer',
  verb: 'create',
  description: 'Create a customer',
  args: [
    { name: 'name', type: 'string', required: true, hint: 'Customer name' },
    { name: 'email', type: 'string', required: false, hint: 'Email' },
    { name: 'currency', type: 'currency', required: false, hint: 'ISO currency' },
  ],
  flags: [
    { name: 'phone', type: 'string', hint: 'Phone' },
    { name: 'payment_terms', short: 't', type: 'number', hint: 'Payment terms (days)' },
  ],
})

register({
  entity: 'customer',
  verb: 'list',
  description: 'List customers',
  args: [],
  flags: [
    { name: 'search', type: 'string', hint: 'Search' },
    { name: 'inactive', type: 'boolean', hint: 'Include inactive' },
    { name: 'limit', type: 'number', hint: 'Limit results' },
  ],
})

register({
  entity: 'customer',
  verb: 'view',
  description: 'View customer',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Customer ID or name' },
  ],
  flags: [],
})

register({
  entity: 'customer',
  verb: 'update',
  description: 'Update customer',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Customer ID or name' },
  ],
  flags: [
    { name: 'email', type: 'string', hint: 'Email' },
    { name: 'phone', type: 'string', hint: 'Phone' },
    { name: 'payment_terms', type: 'number', hint: 'Payment terms' },
    { name: 'currency', type: 'currency', hint: 'Currency' },
  ],
})

register({
  entity: 'customer',
  verb: 'delete',
  description: 'Delete customer',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Customer ID or name' },
  ],
  flags: [],
})

register({
  entity: 'customer',
  verb: 'restore',
  description: 'Restore customer',
  args: [
    { name: 'id', type: 'string', required: true, hint: 'Customer ID or name' },
  ],
  flags: [],
})

register({
  entity: 'company',
  verb: 'create',
  description: 'Create a company',
  args: [
    { name: 'name', type: 'string', required: true, hint: 'Company name' },
    { name: 'currency', type: 'currency', required: true, hint: 'Base currency (ISO)' },
  ],
  flags: [
    { name: 'industry', type: 'string', hint: 'Industry' },
    { name: 'country', type: 'string', hint: 'Country code' },
  ],
})

export function getSchema(entity?: string | null, verb?: string | null): CommandSchema | null {
  if (!entity || !verb) return null
  return SCHEMAS[`${entity}.${verb}`] ?? null
}


===== build/resources/js/palette/shortcuts.ts =====
/**
 * Preset shortcuts (non-configurable)
 *
 * Examples:
 *  ic -> invoice create
 *  il -> invoice list
 */
const PRESET_SHORTCUTS: Record<string, { entity: string; verb: string }> = {
  ic: { entity: 'invoice', verb: 'create' },
  il: { entity: 'invoice', verb: 'list' },
  pc: { entity: 'payment', verb: 'create' },
  pl: { entity: 'payment', verb: 'list' },
  cc: { entity: 'customer', verb: 'create' },
  cl: { entity: 'customer', verb: 'list' },
  jc: { entity: 'journal', verb: 'create' },
}

/**
 * Expand preset shortcut to canonical "entity verb" string.
 * Unknown shortcuts return the original input unchanged.
 */
export function expandPresetShortcut(raw: string): string {
  const trimmed = raw.trim()
  if (!trimmed) return trimmed

  const [first, ...rest] = trimmed.split(/\s+/)
  const preset = PRESET_SHORTCUTS[first.toLowerCase()]
  if (!preset) return trimmed

  const tail = rest.join(' ')
  const expanded = `${preset.entity} ${preset.verb}`.trim()
  return tail ? `${expanded} ${tail}` : `${expanded} `
}

/**
 * Check if token is a preset shortcut.
 */
export function isPresetShortcut(token: string): boolean {
  return Boolean(PRESET_SHORTCUTS[token.toLowerCase()])
}

/**
 * Expose preset map (read-only) for suggestion displays.
 */
export function getPresetShortcuts(): Record<string, { entity: string; verb: string }> {
  return { ...PRESET_SHORTCUTS }
}


===== build/resources/js/palette/table.ts =====
/**
 * Format data as an ASCII table
 */
export function formatTable(
  rows: string[][],
  headers?: string[],
  footer?: string
): string {
  if (rows.length === 0 && !headers) {
    return '(no results)'
  }

  // Calculate column widths
  const allRows = headers ? [headers, ...rows] : rows
  const colCount = Math.max(...allRows.map(r => r.length))
  const colWidths: number[] = []

  for (let col = 0; col < colCount; col++) {
    let maxWidth = 0
    for (const row of allRows) {
      const cell = stripAnsi(row[col] || '')
      maxWidth = Math.max(maxWidth, cell.length)
    }
    // Cap column width at 40 chars
    colWidths.push(Math.min(maxWidth, 40))
  }

  const lines: string[] = []

  // Top border
  lines.push(formatBorder(colWidths, '‚îå', '‚î¨', '‚îê'))

  // Header
  if (headers) {
    lines.push(formatRow(headers, colWidths))
    lines.push(formatBorder(colWidths, '‚îú', '‚îº', '‚î§'))
  }

  // Rows
  for (let i = 0; i < rows.length; i++) {
    lines.push(formatRow(rows[i], colWidths))
  }

  // Bottom border
  lines.push(formatBorder(colWidths, '‚îî', '‚î¥', '‚îò'))

  // Footer
  if (footer) {
    lines.push('')
    lines.push(footer)
  }

  return lines.join('\n')
}

/**
 * Format a single row
 */
function formatRow(cells: string[], widths: number[]): string {
  const parts: string[] = []

  for (let i = 0; i < widths.length; i++) {
    const cell = cells[i] || ''
    const stripped = stripAnsi(cell)
    const padded = stripped.padEnd(widths[i])
    // Truncate if too long
    const final = padded.length > widths[i] 
      ? padded.substring(0, widths[i] - 1) + '‚Ä¶'
      : padded
    parts.push(final)
  }

  return '‚îÇ ' + parts.join(' ‚îÇ ') + ' ‚îÇ'
}

/**
 * Format a border line
 */
function formatBorder(widths: number[], left: string, mid: string, right: string): string {
  const segments = widths.map(w => '‚îÄ'.repeat(w + 2))
  return left + segments.join(mid) + right
}

/**
 * Strip ANSI codes and our custom tags from text
 */
function stripAnsi(text: string): string {
  // Remove ANSI escape codes
  let result = text.replace(/\x1b\[[0-9;]*m/g, '')
  // Remove our {tag}...{/} format
  result = result.replace(/\{[^}]+\}/g, '')
  return result
}

/**
 * Simple table format (no borders) for compact output
 */
export function formatSimpleTable(
  rows: string[][],
  headers?: string[]
): string {
  if (rows.length === 0) return '(no results)'

  const allRows = headers ? [headers, ...rows] : rows
  const colCount = Math.max(...allRows.map(r => r.length))
  const colWidths: number[] = []

  for (let col = 0; col < colCount; col++) {
    let maxWidth = 0
    for (const row of allRows) {
      const cell = stripAnsi(row[col] || '')
      maxWidth = Math.max(maxWidth, cell.length)
    }
    colWidths.push(Math.min(maxWidth, 40))
  }

  const lines: string[] = []

  if (headers) {
    lines.push(formatSimpleRow(headers, colWidths))
    lines.push(colWidths.map(w => '‚îÄ'.repeat(w)).join('  '))
  }

  for (const row of rows) {
    lines.push(formatSimpleRow(row, colWidths))
  }

  return lines.join('\n')
}

function formatSimpleRow(cells: string[], widths: number[]): string {
  return cells
    .map((cell, i) => {
      const stripped = stripAnsi(cell || '')
      return stripped.padEnd(widths[i] || 0)
    })
    .join('  ')
}

/**
 * Format key-value pairs (for single record display)
 */
export function formatKeyValue(data: Record<string, unknown>): string {
  const maxKeyLen = Math.max(...Object.keys(data).map(k => k.length))

  return Object.entries(data)
    .map(([key, value]) => {
      const paddedKey = key.padEnd(maxKeyLen)
      const displayValue = formatValue(value)
      return `${paddedKey}  ${displayValue}`
    })
    .join('\n')
}

function formatValue(value: unknown): string {
  if (value === null || value === undefined) return '‚Äî'
  if (typeof value === 'boolean') return value ? 'Yes' : 'No'
  if (typeof value === 'number') return value.toLocaleString()
  if (value instanceof Date) return value.toLocaleDateString()
  if (Array.isArray(value)) return value.join(', ')
  return String(value)
}


===== build/resources/js/types/palette.ts =====
/**
 * Palette TypeScript Types
 */

// ============================================================================
// Command Types
// ============================================================================

export interface ParsedCommand {
  /** Original input string */
  raw: string
  /** Resolved entity name (e.g., "company") */
  entity: string
  /** Resolved verb name (e.g., "create") */
  verb: string
  /** Parsed flag values */
  flags: Record<string, unknown>
  /** Unparsed positional arguments */
  subject?: string
  /** Whether all required flags are present */
  complete: boolean
  /** Confidence score 0-1 */
  confidence: number
  /** Parse errors */
  errors: string[]
  /** Generated idempotency key */
  idemKey: string
}

export interface CommandResponse {
  /** Success indicator */
  ok: boolean
  /** Error code (on failure) */
  code?: string
  /** Human-readable message */
  message?: string
  /** Response data (table, record, etc.) */
  data?: TableData | Record<string, unknown>
  /** Additional metadata */
  meta?: Record<string, unknown>
  /** URL to redirect to */
  redirect?: string
  /** Undo action info */
  undo?: UndoAction
  /** Validation errors by field */
  errors?: Record<string, string[]>
  /** Whether this is a replayed idempotent response */
  replayed?: boolean
  /** HTTP status code */
  status?: number
}

export interface UndoAction {
  /** Action identifier */
  action: string
  /** Parameters to reverse the action */
  params: Record<string, unknown>
  /** Unix timestamp when undo expires */
  expiresAt: number
  /** Description of what will be undone */
  message: string
}

// ============================================================================
// Grammar Types
// ============================================================================

export interface EntityDefinition {
  /** Canonical entity name */
  name: string
  /** Short aliases (e.g., ["co", "comp"] for "company") */
  shortcuts: string[]
  /** Available operations */
  verbs: VerbDefinition[]
  /** Default verb when only entity is specified */
  defaultVerb: string
}

export interface VerbDefinition {
  /** Canonical verb name */
  name: string
  /** Alternative names (e.g., ["new", "add"] for "create") */
  aliases: string[]
  /** Flag definitions */
  flags: FlagDefinition[]
  /** Whether positional subject is expected */
  requiresSubject: boolean
}

export interface FlagDefinition {
  /** Flag name (used with --name) */
  name: string
  /** Short form (used with -n) */
  shorthand?: string
  /** Value type */
  type: 'boolean' | 'string' | 'number'
  /** Whether flag must be provided */
  required: boolean
  /** Default value if not provided */
  default?: unknown
}

// ============================================================================
// Output Types
// ============================================================================

export type OutputType = 'input' | 'output' | 'error' | 'success' | 'warning' | 'table'

export interface OutputLine {
  /** Line type for styling */
  type: OutputType
  /** Text content or table data */
  content: string | string[][]
  /** Table headers (if type is 'table') */
  headers?: string[]
  /** Table footer (if type is 'table') */
  footer?: string
}

export interface TableData {
  /** Column headers */
  headers: string[]
  /** Row data (array of cell arrays) */
  rows: string[][]
  /** Footer text */
  footer?: string
}

// ============================================================================
// Suggestion Types
// ============================================================================

export interface Suggestion {
  /** Suggestion category */
  type: 'command' | 'entity' | 'verb' | 'flag' | 'value' | 'history'
  /** Value to insert */
  value: string
  /** Display label */
  label: string
  /** Optional description */
  description?: string
  /** Optional icon */
  icon?: string
  /** Match score for sorting */
  score?: number
  /** Category for grouping */
  category?: string
}

// ============================================================================
// Quick Actions Types
// ============================================================================

export interface QuickAction {
  /** Number key to activate (0-9) */
  key: string
  /** Display label */
  label: string
  /** Command template (e.g., "company switch {slug}") */
  command: string
  /** Does this action need selected row data? */
  needsRow: boolean
  /** Sub-prompt text if additional input needed */
  prompt?: string
}

export interface TableState {
  /** Column headers */
  headers: string[]
  /** Row data */
  rows: string[][]
  /** Currently selected row index */
  selectedRowIndex: number
  /** Which entity this table represents */
  entity: string
  /** Which verb produced this table */
  verb: string
}


