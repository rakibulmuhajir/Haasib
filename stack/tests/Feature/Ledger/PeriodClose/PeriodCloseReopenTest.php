<?php

namespace Tests\Feature\Ledger\PeriodClose;

use App\Models\Company;
use App\Models\User;
use Illuminate\Support\Facades\Event;
use Modules\Accounting\Domain\AccountingPeriod\Models\AccountingPeriod;
use Modules\Ledger\Domain\PeriodClose\Models\PeriodClose;
use Tests\TestCase;

class PeriodCloseReopenTest extends TestCase
{
    private User $user;

    private User $cfoUser;

    private Company $company;

    private AccountingPeriod $period;

    private PeriodClose $periodClose;

    protected function setUp(): void
    {
        parent::setUp();

        $this->user = User::factory()->create();
        $this->cfoUser = User::factory()->create();
        $this->company = Company::factory()->create();

        // Give users permissions
        $this->user->givePermissionTo('period-close.view');
        $this->cfoUser->givePermissionTo('period-close.view');
        $this->cfoUser->givePermissionTo('period-close.reopen');

        // Add users to company
        $this->company->users()->attach($this->user->id, ['role' => 'accountant']);
        $this->company->users()->attach($this->cfoUser->id, ['role' => 'cfo']);

        $this->actingAs($this->cfoUser);
        $this->withHeader('X-Company-Id', $this->company->id);
    }

    protected function createClosedPeriod(): void
    {
        $this->period = AccountingPeriod::factory()->create([
            'company_id' => $this->company->id,
            'status' => 'closed',
            'start_date' => now()->subMonth()->startOfMonth(),
            'end_date' => now()->subMonth()->endOfMonth(),
        ]);

        $this->periodClose = PeriodClose::factory()->create([
            'company_id' => $this->company->id,
            'accounting_period_id' => $this->period->id,
            'status' => 'closed',
            'closed_at' => now()->subDays(5),
            'closed_by' => $this->user->id,
            'completed_at' => now()->subDays(5),
            'completed_by' => $this->user->id,
        ]);
    }

    /** @test */
    public function it_can_reopen_a_closed_period_with_proper_authorization()
    {
        $this->createClosedPeriod();

        $reopenData = [
            'reason' => 'Audit adjustment required for Q3',
            'reopen_until' => now()->addDays(7)->toDateString(),
            'notes' => 'Auditor identified adjustment needed for revenue recognition',
        ];

        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", $reopenData);

        $response->assertStatus(200)
            ->assertJson([
                'message' => 'Period reopened successfully',
                'data' => [
                    'id' => $this->periodClose->id,
                    'status' => 'reopened',
                    'reopened_by' => $this->cfoUser->id,
                    'reopened_at' => now()->toISOString(),
                    'reopen_reason' => $reopenData['reason'],
                    'reopen_until' => $reopenData['reopen_until'],
                ],
            ]);

        // Verify database changes
        $this->assertDatabaseHas('acct.accounting_periods', [
            'id' => $this->period->id,
            'status' => 'reopened',
            'reopened_by' => $this->cfoUser->id,
            'reopened_at' => now()->toDateTimeString(),
        ]);

        $this->assertDatabaseHas('ledger.period_closes', [
            'id' => $this->periodClose->id,
            'status' => 'reopened',
            'reopened_by' => $this->cfoUser->id,
            'reopened_at' => now()->toDateTimeString(),
        ]);
    }

    /** @test */
    public function it_validates_required_reopen_fields()
    {
        $this->createClosedPeriod();

        // Test missing reason
        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reopen_until' => now()->addDays(7)->toDateString(),
        ]);

        $response->assertStatus(422)
            ->assertJsonValidationErrors(['reason']);

        // Test missing reopen_until
        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Test reason',
        ]);

        $response->assertStatus(422)
            ->assertJsonValidationErrors(['reopen_until']);
    }

    /** @test */
    public function it_validates_reopen_until_date_is_in_future()
    {
        $this->createClosedPeriod();

        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Test reason',
            'reopen_until' => now()->subDays(1)->toDateString(), // Past date
        ]);

        $response->assertStatus(422)
            ->assertJsonValidationErrors(['reopen_until']);
    }

    /** @test */
    public function it_prevents_reopening_non_closed_periods()
    {
        $period = AccountingPeriod::factory()->create([
            'company_id' => $this->company->id,
            'status' => 'open', // Not closed
        ]);

        $periodClose = PeriodClose::factory()->create([
            'company_id' => $this->company->id,
            'accounting_period_id' => $period->id,
            'status' => 'in_review', // Not closed
        ]);

        $response = $this->postJson("/api/v1/ledger/periods/{$period->id}/close/reopen", [
            'reason' => 'Test reason',
            'reopen_until' => now()->addDays(7)->toDateString(),
        ]);

        $response->assertStatus(422)
            ->assertJson([
                'message' => 'Only closed periods can be reopened',
            ]);
    }

    /** @test */
    public function it_requires_reopen_permission()
    {
        $this->createClosedPeriod();

        // Act as regular user without reopen permission
        $this->actingAs($this->user);

        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Test reason',
            'reopen_until' => now()->addDays(7)->toDateString(),
        ]);

        $response->assertStatus(403)
            ->assertJson([
                'message' => 'Insufficient permissions to reopen period',
            ]);
    }

    /** @test */
    public function it_records_audit_trail_for_reopen_operation()
    {
        $this->createClosedPeriod();
        Event::fake();

        $reopenData = [
            'reason' => 'Audit adjustment required',
            'reopen_until' => now()->addDays(7)->toDateString(),
            'notes' => 'Auditor identified adjustment needed',
        ];

        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", $reopenData);

        $response->assertStatus(200);

        // Verify audit event was dispatched
        Event::assertDispatched('ledger.period.close.reopened', function ($event) use ($reopenData) {
            return $event->periodClose->id === $this->periodClose->id
                && $event->user->id === $this->cfoUser->id
                && $event->reason === $reopenData['reason']
                && $event->reopenUntil->toDateString() === $reopenData['reopen_until'];
        });
    }

    /** @test */
    public function it_prevents_reopening_periods_that_were_recently_reopened()
    {
        $this->createClosedPeriod();

        // First reopen
        $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'First reopen',
            'reopen_until' => now()->addDays(7)->toDateString(),
        ]);

        // Try to reopen again immediately
        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Second reopen',
            'reopen_until' => now()->addDays(14)->toDateString(),
        ]);

        $response->assertStatus(422)
            ->assertJson([
                'message' => 'Period is already reopened',
            ]);
    }

    /** @test */
    public function it_validates_company_scoping_for_reopen_operation()
    {
        $otherCompany = Company::factory()->create();
        $otherUser = User::factory()->create();

        $otherCompany->users()->attach($otherUser->id, ['role' => 'cfo']);
        $otherUser->givePermissionTo('period-close.reopen');

        $this->createClosedPeriod();

        // Try to reopen period from different company
        $this->actingAs($otherUser);
        $this->withHeader('X-Company-Id', $otherCompany->id);

        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Test reason',
            'reopen_until' => now()->addDays(7)->toDateString(),
        ]);

        $response->assertStatus(404);
    }

    /** @test */
    public function it_allows_journal_entries_in_reopened_period()
    {
        $this->createClosedPeriod();

        // Reopen the period
        $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Need to post adjustment',
            'reopen_until' => now()->addDays(7)->toDateString(),
        ]);

        // Create a journal entry for the reopened period
        $account = \Modules\Accounting\Domain\Account\Models\Account::factory()->create([
            'company_id' => $this->company->id,
        ]);

        $journalEntryData = [
            'reference' => 'ADJ-001',
            'description' => 'Adjustment entry',
            'date' => now()->toDateString(),
            'lines' => [
                [
                    'account_id' => $account->id,
                    'debit' => 100.00,
                    'credit' => 0.00,
                    'description' => 'Adjustment debit',
                ],
                [
                    'account_id' => $account->id,
                    'debit' => 0.00,
                    'credit' => 100.00,
                    'description' => 'Adjustment credit',
                ],
            ],
        ];

        $response = $this->postJson('/api/v1/ledger/journal-entries', $journalEntryData);

        $response->assertStatus(201);
    }

    /** @test */
    public function it_prevents_journal_entries_after_reopen_window_expires()
    {
        $this->createClosedPeriod();

        // Reopen the period with a short window
        $yesterday = now()->subDay()->toDateString();

        $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Need to post adjustment',
            'reopen_until' => $yesterday,
        ]);

        // Try to create a journal entry after the window has expired
        $account = \Modules\Accounting\Domain\Account\Models\Account::factory()->create([
            'company_id' => $this->company->id,
        ]);

        $journalEntryData = [
            'reference' => 'ADJ-001',
            'description' => 'Adjustment entry',
            'date' => now()->toDateString(),
            'lines' => [
                [
                    'account_id' => $account->id,
                    'debit' => 100.00,
                    'credit' => 0.00,
                    'description' => 'Adjustment debit',
                ],
                [
                    'account_id' => $account->id,
                    'debit' => 0.00,
                    'credit' => 100.00,
                    'description' => 'Adjustment credit',
                ],
            ],
        ];

        $response = $this->postJson('/api/v1/ledger/journal-entries', $journalEntryData);

        $response->assertStatus(422)
            ->assertJson([
                'message' => 'Cannot create journal entries for reopened periods after the reopen window has expired',
            ]);
    }

    /** @test */
    public function it_provides_reopen_history_and_tracking()
    {
        $this->createClosedPeriod();

        $reopenData = [
            'reason' => 'Audit adjustment required',
            'reopen_until' => now()->addDays(7)->toDateString(),
        ];

        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", $reopenData);

        $response->assertStatus(200);

        // Check that the response includes reopen history
        $this->assertArrayHasKey('reopen_history', $response->json('data'));
        $this->assertArrayHasKey('original_close_date', $response->json('data'));
        $this->assertArrayHasKey('reopened_times', $response->json('data'));
    }

    /** @test */
    public function it_handles_extended_reopen_windows_for_major_adjustments()
    {
        $this->createClosedPeriod();

        // Request extended reopen window (30 days instead of default 7)
        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Major restatement required - revenue recognition policy change',
            'reopen_until' => now()->addDays(30)->toDateString(),
            'notes' => 'Requires extensive adjustments across multiple periods',
            'justification' => 'Auditor requirement for material restatement',
        ]);

        $response->assertStatus(200);

        // Verify extended window was granted
        $expectedUntil = now()->addDays(30)->toDateString();
        $this->assertEquals($expectedUntil, $response->json('data.reopen_until'));
    }

    /** @test */
    public function it_sends_notifications_to_stakeholders_when_period_is_reopened()
    {
        $this->createClosedPeriod();
        Event::fake();

        $response = $this->postJson("/api/v1/ledger/periods/{$this->period->id}/close/reopen", [
            'reason' => 'Audit adjustment required',
            'reopen_until' => now()->addDays(7)->toDateString(),
        ]);

        $response->assertStatus(200);

        // Verify notification events were dispatched
        Event::assertDispatched('ledger.period.close.reopen_notification');
    }
}
