
=== File: Account.php ===
Path: Account.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Account extends Model
{
    protected $fillable = [
        'company_id',
        'account_group_id',
        'code',
        'name',
        'description',
        'normal_balance',
        'account_type',
        'active',
        'allow_manual_entries',
        'currency',
        'opening_balance',
        'opening_balance_date',
        'current_balance',
        'parent_id',
    ];

    protected $casts = [
        'active' => 'boolean',
        'allow_manual_entries' => 'boolean',
        'opening_balance' => 'decimal:2',
        'opening_balance_date' => 'date',
        'current_balance' => 'decimal:2',
        'last_updated_at' => 'datetime',
    ];

    /**
     * Get the company that owns the account.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    /**
     * Get the account group that contains the account.
     */
    public function accountGroup(): BelongsTo
    {
        return $this->belongsTo(AccountGroup::class);
    }

    /**
     * Get the parent account.
     */
    public function parent(): BelongsTo
    {
        return $this->belongsTo(Account::class, 'parent_id');
    }
}

---- File Content End ----


=== File: AccountClass.php ===
Path: AccountClass.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\HasMany;

class AccountClass extends Model
{
    use HasFactory, HasUuids;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'acct.account_classes';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'name',
        'normal_balance',
        'type',
        'order',
        'is_active',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'order' => 'integer',
            'is_active' => 'boolean',
        ];
    }

    /**
     * Get the account groups for the class.
     */
    public function accountGroups(): HasMany
    {
        return $this->hasMany(AccountGroup::class);
    }

    /**
     * Get the accounts for the class.
     */
    public function accounts(): HasMany
    {
        return $this->hasMany(ChartOfAccount::class);
    }

    /**
     * Scope a query to only include active classes.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\AccountClassFactory::new();
    }
}

---- File Content End ----


=== File: AccountGroup.php ===
Path: AccountGroup.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class AccountGroup extends Model
{
    use HasFactory, HasUuids;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'acct.account_groups';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'account_class_id',
        'name',
        'code',
        'order',
        'is_active',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'order' => 'integer',
            'is_active' => 'boolean',
            'account_class_id' => 'string',
        ];
    }

    /**
     * Get the account class for the group.
     */
    public function accountClass(): BelongsTo
    {
        return $this->belongsTo(AccountClass::class);
    }

    /**
     * Get the accounts for the group.
     */
    public function accounts(): HasMany
    {
        return $this->hasMany(ChartOfAccount::class);
    }

    /**
     * Scope a query to only include active groups.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\AccountGroupFactory::new();
    }
}

---- File Content End ----


=== File: AccountingPeriod.php ===
Path: AccountingPeriod.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;
use Illuminate\Database\Eloquent\Relations\HasOne;

class AccountingPeriod extends Model
{
    use HasFactory, HasUuids;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'acct.accounting_periods';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'fiscal_year_id',
        'name',
        'start_date',
        'end_date',
        'period_type',
        'period_number',
        'status',
        'closed_by',
        'closed_at',
        'closing_notes',
        'reopened_by',
        'reopened_at',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'start_date' => 'date',
            'end_date' => 'date',
            'closed_at' => 'datetime',
            'reopened_at' => 'datetime',
            'period_number' => 'integer',
            'fiscal_year_id' => 'string',
            'closed_by' => 'string',
            'reopened_by' => 'string',
        ];
    }

    /**
     * Get the fiscal year for the period.
     */
    public function fiscalYear(): BelongsTo
    {
        return $this->belongsTo(FiscalYear::class);
    }

    /**
     * Get the user who closed the period.
     */
    public function closer(): BelongsTo
    {
        return $this->belongsTo(User::class, 'closed_by');
    }

    /**
     * Get the journal entries for the period.
     */
    public function journalEntries(): HasMany
    {
        return $this->hasMany(JournalEntry::class);
    }

    /**
     * Get the period close record for this period.
     */
    public function periodClose(): HasOne
    {
        return $this->hasOne(\Modules\Ledger\Domain\PeriodClose\Models\PeriodClose::class, 'accounting_period_id');
    }

    /**
     * Scope a query to only include open periods.
     */
    public function scopeOpen($query)
    {
        return $query->where('status', 'open');
    }

    /**
     * Scope a query to only include closed periods.
     */
    public function scopeClosed($query)
    {
        return $query->where('status', 'closed');
    }

    /**
     * Scope a query to only include closing periods.
     */
    public function scopeClosing($query)
    {
        return $query->where('status', 'closing');
    }

    /**
     * Scope a query to only include reopened periods.
     */
    public function scopeReopened($query)
    {
        return $query->where('status', 'reopened');
    }

    /**
     * Check if the period is currently active.
     */
    public function isCurrent(): bool
    {
        $now = now();

        return $this->status === 'open' && $this->start_date <= $now && $this->end_date >= $now;
    }

    /**
     * Check if the period can be closed.
     */
    public function canBeClosed(): bool
    {
        return in_array($this->status, ['open', 'reopened']);
    }

    /**
     * Check if the period is closed.
     */
    public function isClosed(): bool
    {
        return $this->status === 'closed';
    }

    /**
     * Check if the period is closing.
     */
    public function isClosing(): bool
    {
        return $this->status === 'closing';
    }

    /**
     * Check if the period has been reopened.
     */
    public function isReopened(): bool
    {
        return $this->status === 'reopened';
    }

    /**
     * Close the period.
     */
    public function close(User $user, ?string $summary = null): void
    {
        $this->status = 'closed';
        $this->closed_at = now();
        $this->closed_by = $user->id;
        if ($summary) {
            $this->closing_notes = $summary;
        }
        $this->save();
    }

    /**
     * Reopen the period.
     */
    public function reopen(User $user): void
    {
        $this->status = 'reopened';
        $this->reopened_at = now();
        $this->reopened_by = $user->id;
        $this->save();
    }

    /**
     * Start closing the period.
     */
    public function startClosing(): void
    {
        $this->status = 'closing';
        $this->save();
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\AccountingPeriodFactory::new();
    }
}

---- File Content End ----


=== File: AuditEntry.php ===
Path: AuditEntry.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Concerns\HasUuids;
use Illuminate\Database\Eloquent\Factories\Factory;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class AuditEntry extends Model
{
    use HasFactory, HasUuids;

    public $incrementing = false;

    protected $keyType = 'string';

    /**
     * The table associated with the model.
     *
     * @var string
     */
    protected $table = 'audit.entries';

    /**
     * The attributes that are mass assignable.
     *
     * @var list<string>
     */
    protected $fillable = [
        'company_id',
        'user_id',
        'event',
        'model_type',
        'model_id',
        'old_values',
        'new_values',
        'ip_address',
        'user_agent',
        'tags',
        'metadata',
    ];

    /**
     * Get the attributes that should be cast.
     *
     * @return array<string, string>
     */
    protected function casts(): array
    {
        return [
            'old_values' => 'array',
            'new_values' => 'array',
            'tags' => 'array',
            'metadata' => 'array',
            'company_id' => 'string',
            'user_id' => 'string',
            'model_id' => 'string',
        ];
    }

    /**
     * The attributes that should be hidden for serialization.
     *
     * @var list<string>
     */
    protected $hidden = [
        'ip_address',
        'user_agent',
    ];

    /**
     * Get the company that owns the audit entry.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    /**
     * Get the user that performed the action.
     */
    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    /**
     * Get the audited model instance.
     */
    public function getModel()
    {
        if (! $this->model_type || ! $this->model_id) {
            return null;
        }

        return $this->model_type::find($this->model_id);
    }

    /**
     * Scope a query to only include entries for a specific event.
     */
    public function scopeForEvent($query, string $event)
    {
        return $query->where('event', $event);
    }

    /**
     * Scope a query to only include entries for a specific model.
     */
    public function scopeForModel($query, string $modelType)
    {
        return $query->where('model_type', $modelType);
    }

    /**
     * Scope a query to only include entries with a specific tag.
     */
    public function scopeWithTag($query, string $tag)
    {
        return $query->whereJsonContains('tags', $tag);
    }

    /**
     * Scope a query to only include entries within a date range.
     */
    public function scopeBetweenDates($query, $startDate, $endDate)
    {
        return $query->whereBetween('created_at', [$startDate, $endDate]);
    }

    /**
     * Check if the audit entry is for a creation event.
     */
    public function isCreation(): bool
    {
        return $this->event === 'created';
    }

    /**
     * Check if the audit entry is for an update event.
     */
    public function isUpdate(): bool
    {
        return $this->event === 'updated';
    }

    /**
     * Check if the audit entry is for a deletion event.
     */
    public function isDeletion(): bool
    {
        return $this->event === 'deleted';
    }

    /**
     * Check if the audit entry has specific changes.
     */
    public function hasAttributeChange(string $attribute): bool
    {
        return array_key_exists($attribute, $this->old_values ?? [])
            || array_key_exists($attribute, $this->new_values ?? []);
    }

    /**
     * Get the old value of a specific attribute.
     */
    public function getOldValue(string $attribute, mixed $default = null): mixed
    {
        return data_get($this->old_values, $attribute, $default);
    }

    /**
     * Get the new value of a specific attribute.
     */
    public function getNewValue(string $attribute, mixed $default = null): mixed
    {
        return data_get($this->new_values, $attribute, $default);
    }

    /**
     * Get the diff between old and new values.
     */
    public function getDiff(): array
    {
        $diff = [];

        $allKeys = array_unique(array_merge(
            array_keys($this->old_values ?? []),
            array_keys($this->new_values ?? [])
        ));

        foreach ($allKeys as $key) {
            $old = $this->getOldValue($key);
            $new = $this->getNewValue($key);

            if ($old !== $new) {
                $diff[$key] = [
                    'old' => $old,
                    'new' => $new,
                ];
            }
        }

        return $diff;
    }

    /**
     * Create a new factory instance for the model.
     */
    protected static function newFactory(): Factory
    {
        return \Database\Factories\AuditEntryFactory::new();
    }
}

---- File Content End ----


=== File: ChartOfAccount.php ===
Path: ChartOfAccount.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Factories\HasFactory;

class ChartOfAccount extends Model
{
    use HasFactory;

    /**
     * The table associated with the model.
     */
    protected $table = 'accounting.chart_of_accounts';

    /**
     * The primary key associated with the table.
     */
    protected $primaryKey = 'account_code';

    /**
     * Indicates if the model's ID is auto-incrementing.
     */
    public $incrementing = false;

    /**
     * The data type of the primary key.
     */
    protected $keyType = 'string';

    /**
     * The attributes that are mass assignable.
     */
    protected $fillable = [
        'account_code',
        'account_name',
        'account_type',
        'account_category',
        'is_active',
        'description',
        'parent_account_code',
        'company_id',
        'created_at',
        'updated_at',
    ];

    /**
     * The attributes that should be cast.
     */
    protected $casts = [
        'is_active' => 'boolean',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * Get the company that owns the chart of account.
     */
    public function company()
    {
        return $this->belongsTo(Company::class, 'company_id');
    }

    /**
     * Get the parent account.
     */
    public function parentAccount()
    {
        return $this->belongsTo(ChartOfAccount::class, 'parent_account_code', 'account_code');
    }

    /**
     * Get the child accounts.
     */
    public function childAccounts()
    {
        return $this->hasMany(ChartOfAccount::class, 'parent_account_code', 'account_code');
    }

    /**
     * Get the journal entries for this account.
     */
    public function journalEntries()
    {
        return $this->hasMany(JournalEntry::class, 'account_code', 'account_code');
    }

    /**
     * Scope to get active accounts.
     */
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    /**
     * Scope to get accounts by type.
     */
    public function scopeByType($query, string $accountType)
    {
        return $query->where('account_type', $accountType);
    }

    /**
     * Scope to get accounts by category.
     */
    public function scopeByCategory($query, string $accountCategory)
    {
        return $query->where('account_category', $accountCategory);
    }

    /**
     * Get the account type label.
     */
    public function getAccountTypeLabelAttribute(): string
    {
        $labels = [
            'asset' => 'Asset',
            'liability' => 'Liability',
            'equity' => 'Equity',
            'revenue' => 'Revenue',
            'expense' => 'Expense',
        ];

        return $labels[$this->account_type] ?? $this->account_type;
    }

    /**
     * Get the account category label.
     */
    public function getAccountCategoryLabelAttribute(): string
    {
        $labels = [
            'current_assets' => 'Current Assets',
            'fixed_assets' => 'Fixed Assets',
            'current_liabilities' => 'Current Liabilities',
            'long_term_liabilities' => 'Long-term Liabilities',
            'owner_equity' => 'Owner Equity',
            'operating_revenue' => 'Operating Revenue',
            'non_operating_revenue' => 'Non-operating Revenue',
            'operating_expenses' => 'Operating Expenses',
            'non_operating_expenses' => 'Non-operating Expenses',
        ];

        return $labels[$this->account_category] ?? $this->account_category;
    }
}
---- File Content End ----


=== File: Command.php ===
Path: Command.php
---- File Content Start ----
<?php

namespace App\Models;

use App\Models\Scopes\CommandPerformanceScope;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Command extends Model
{
    protected $fillable = [
        'company_id',
        'name',
        'description',
        'category',
        'parameters',
        'required_permissions',
        'execution_handler',
        'is_active',
    ];

    protected $casts = [
        'parameters' => 'array',
        'required_permissions' => 'array',
        'is_active' => 'boolean',
    ];

    /**
     * The "booted" method of the model.
     */
    protected static function booted(): void
    {
        static::addGlobalScope(new CommandPerformanceScope);
    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function commandTemplates(): HasMany
    {
        return $this->hasMany(CommandTemplate::class);
    }

    public function commandExecutions(): HasMany
    {
        return $this->hasMany(CommandExecution::class);
    }

    public function commandHistory(): HasMany
    {
        return $this->hasMany(CommandHistory::class);
    }

    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }

    public function scopeForCompany($query, $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    public function userHasPermission(?User $user): bool
    {
        if (! $user) {
            return false;
        }

        return $user->hasAnyPermission($this->required_permissions);
    }
}

---- File Content End ----


=== File: CommandExecution.php ===
Path: CommandExecution.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CommandExecution extends Model
{
    protected $fillable = [
        'command_id',
        'user_id',
        'company_id',
        'idempotency_key',
        'status',
        'started_at',
        'completed_at',
        'parameters',
        'result',
        'error_message',
        'audit_reference',
    ];

    protected $casts = [
        'started_at' => 'datetime',
        'completed_at' => 'datetime',
        'parameters' => 'array',
        'result' => 'array',
    ];

    public function command(): BelongsTo
    {
        return $this->belongsTo(Command::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function scopePending($query)
    {
        return $query->where('status', 'pending');
    }

    public function scopeRunning($query)
    {
        return $query->where('status', 'running');
    }

    public function scopeCompleted($query)
    {
        return $query->where('status', 'completed');
    }

    public function scopeFailed($query)
    {
        return $query->where('status', 'failed');
    }

    public function scopeForCompany($query, $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    public function isSuccessful(): bool
    {
        return $this->status === 'completed';
    }

    public function isFailed(): bool
    {
        return $this->status === 'failed';
    }

    public function getDuration(): ?float
    {
        if (! $this->started_at || ! $this->completed_at) {
            return null;
        }

        return $this->started_at->diffInSeconds($this->completed_at);
    }
}

---- File Content End ----


=== File: CommandHistory.php ===
Path: CommandHistory.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CommandHistory extends Model
{
    protected $fillable = [
        'user_id',
        'command_id',
        'company_id',
        'executed_at',
        'input_text',
        'parameters_used',
        'execution_status',
        'result_summary',
        'audit_reference',
    ];

    protected $casts = [
        'executed_at' => 'datetime',
        'parameters_used' => 'array',
    ];

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function command(): BelongsTo
    {
        return $this->belongsTo(Command::class);
    }

    public function company(): BelongsTo
    {
        return $this->belongsTo(Company::class);
    }

    public function scopeForUser($query, $userId)
    {
        return $query->where('user_id', $userId);
    }

    public function scopeForCompany($query, $companyId)
    {
        return $query->where('company_id', $companyId);
    }

    public function scopeSuccessful($query)
    {
        return $query->where('execution_status', 'success');
    }

    public function scopeFailed($query)
    {
        return $query->where('execution_status', 'failed');
    }

    public function scopeRecent($query, int $days = 7)
    {
        return $query->where('executed_at', '>=', now()->subDays($days));
    }

    public function isSuccessful(): bool
    {
        return $this->execution_status === 'success';
    }

    public function isFailed(): bool
    {
        return $this->execution_status === 'failed';
    }
}

---- File Content End ----


=== File: CommandTemplate.php ===
Path: CommandTemplate.php
---- File Content Start ----
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class CommandTemplate extends Model
{
    protected $fillable = [
        'command_id',
        'user_id',
        'name',
        'parameter_values',
        'is_shared',
    ];

    protected $casts = [
        'parameter_values' => 'array',
        'is_shared' => 'boolean',
    ];

    public function command(): BelongsTo
    {
        return $this->belongsTo(Command::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }

    public function scopeShared($query)
    {
        return $query->where('is_shared', true);
    }

    public function scopePrivate($query)
    {
        return $query->where('is_shared', false);
    }

    public function scopeForUser($query, $userId)
    {
        return $query->where('user_id', $userId);
    }

    public function scopeAccessibleBy($query, User $user)
    {
        return $query->where(function ($q) use ($user) {
            $q->where('user_id', $user->id)
                ->orWhere('is_shared', true);
        });
    }

    public function isAccessibleBy(User $user): bool
    {
        return $this->user_id === $user->id || $this->is_shared;
    }
}

---- File Content End ----

