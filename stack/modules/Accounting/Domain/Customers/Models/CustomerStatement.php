<?php

namespace Modules\Accounting\Domain\Customers\Models;

use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

/**
 * Customer Statement Model
 *
 * Represents generated customer statements with period-based financial summaries.
 */
class CustomerStatement extends Model
{
    use HasFactory;

    protected $table = 'acct.customer_statements';

    protected $fillable = [
        'customer_id',
        'company_id',
        'period_start',
        'period_end',
        'generated_at',
        'generated_by_user_id',
        'opening_balance',
        'total_invoiced',
        'total_paid',
        'total_credit_notes',
        'closing_balance',
        'aging_bucket_summary',
        'document_path',
        'checksum',
    ];

    protected $casts = [
        'period_start' => 'date',
        'period_end' => 'date',
        'generated_at' => 'datetime',
        'opening_balance' => 'decimal:15,2',
        'total_invoiced' => 'decimal:15,2',
        'total_paid' => 'decimal:15,2',
        'total_credit_notes' => 'decimal:15,2',
        'closing_balance' => 'decimal:15,2',
        'aging_bucket_summary' => 'array',
        'created_at' => 'datetime',
        'updated_at' => 'datetime',
    ];

    /**
     * Get the customer that owns the statement.
     */
    public function customer(): BelongsTo
    {
        return $this->belongsTo(Customer::class);
    }

    /**
     * Get the company that owns the statement.
     */
    public function company(): BelongsTo
    {
        return $this->belongsTo(\App\Models\Company::class);
    }

    /**
     * Get the user who generated the statement.
     */
    public function generatedBy(): BelongsTo
    {
        return $this->belongsTo(\App\Models\User::class, 'foreign_key', 'generated_by_user_id');
    }

    /**
     * Scope statements by period start date.
     */
    public function scopePeriodStart(Builder $query, $date): Builder
    {
        return $query->where('period_start', $date);
    }

    /**
     * Scope statements by period end date.
     */
    public function scopePeriodEnd(Builder $query, $date): Builder
    {
        return $query->where('period_end', $date);
    }

    /**
     * Scope statements within a period range.
     */
    public function scopePeriodBetween(Builder $query, $startDate, $endDate): Builder
    {
        return $query->where('period_start', '>=', $startDate)
            ->where('period_end', '<=', $endDate);
    }

    /**
     * Scope statements generated by a specific user.
     */
    public function scopeGeneratedBy(Builder $query, $userId): Builder
    {
        return $query->where('generated_by_user_id', $userId);
    }

    /**
     * Scope statements generated on or after a specific date.
     */
    public function scopeGeneratedAfter(Builder $query, $date): Builder
    {
        return $query->where('generated_at', '>=', $date);
    }

    /**
     * Scope statements generated before a specific date.
     */
    public function scopeGeneratedBefore(Builder $query, $date): Builder
    {
        return $query->where('generated_at', '<=', $date);
    }

    /**
     * Get the period duration in days.
     */
    public function getPeriodDurationAttribute(): int
    {
        return $this->period_start->diffInDays($this->period_end) + 1;
    }

    /**
     * Get the formatted period range.
     */
    public function getPeriodRangeAttribute(): string
    {
        return $this->period_start->format('M j, Y').' - '.$this->period_end->format('M j, Y');
    }

    /**
     * Check if the statement is for the current month.
     */
    public function isCurrentMonth(): bool
    {
        $now = now();

        return $this->period_start->month === $now->month &&
               $this->period_start->year === $now->year &&
               $this->period_end->month === $now->month &&
               $this->period_end->year === $now->year;
    }

    /**
     * Check if the statement is overdue (older than 3 months).
     */
    public function isOverdue(): bool
    {
        return $this->period_end->lt(now()->subMonths(3));
    }

    /**
     * Get the document file name.
     */
    public function getDocumentFilenameAttribute(): string
    {
        if ($this->document_path) {
            return basename($this->document_path);
        }

        return 'statement-'.$this->customer_id.'-'.$this->period_start->format('Y-m-d').'.pdf';
    }

    /**
     * Get the document URL.
     */
    public function getDocumentUrlAttribute(): ?string
    {
        if ($this->document_path && \Storage::exists($this->document_path)) {
            return \Storage::url($this->document_path);
        }

        return null;
    }

    /**
     * Verify the statement checksum.
     */
    public function verifyChecksum(): bool
    {
        if (! $this->checksum) {
            return false;
        }

        $expectedData = [
            'customer_id' => $this->customer_id,
            'period_start' => $this->period_start->format('Y-m-d'),
            'period_end' => $this->period_end->format('Y-m-d'),
            'opening_balance' => $this->opening_balance,
            'total_invoiced' => $this->total_invoiced,
            'total_paid' => $this->total_paid,
            'total_credit_notes' => $this->total_credit_notes,
            'closing_balance' => $this->closing_balance,
            'generated_at' => $this->generated_at->format('Y-m-d H:i:s'),
        ];

        $expectedChecksum = hash('sha256', json_encode($expectedData));

        return hash_equals($this->checksum, $expectedChecksum);
    }

    /**
     * Get the aging risk level based on the aging summary.
     */
    public function getAgingRiskLevelAttribute(): string
    {
        if (! $this->aging_bucket_summary) {
            return 'low';
        }

        $total = $this->aging_bucket_summary['bucket_current'] ?? 0 +
                   $this->aging_bucket_summary['bucket_1_30'] ?? 0 +
                   $this->aging_bucket_summary['bucket_31_60'] ?? 0 +
                   $this->aging_bucket_summary['bucket_61_90'] ?? 0 +
                   $this->aging_bucket_summary['bucket_90_plus'] ?? 0;

        if ($total === 0) {
            return 'none';
        }

        $percentage90Plus = ($this->aging_bucket_summary['bucket_90_plus'] / $total) * 100;
        $percentage61Plus = (($this->aging_bucket_summary['bucket_61_90'] + $this->aging_bucket_summary['bucket_90_plus']) / $total) * 100;

        if ($percentage90Plus > 50) {
            return 'critical';
        } elseif ($percentage61Plus > 30) {
            return 'high';
        } elseif ($percentage90Plus > 0) {
            return 'elevated';
        } elseif ($percentage61Plus > 0) {
            return 'moderate';
        } else {
            return 'low';
        }
    }

    /**
     * Scope statements by aging risk level.
     */
    public function scopeByAgingRiskLevel(Builder $query, string $riskLevel): Builder
    {
        return $query->whereHas('customer', function ($customerQuery) use ($riskLevel) {
            $customerQuery->whereHas('agingSnapshots', function ($snapshotQuery) use ($riskLevel) {
                $snapshotQuery->where('snapshot_date', $this->period_end)
                    ->whereRaw('((bucket_90_plus / (bucket_current + bucket_1_30 + bucket_31_60 + bucket_61_90 + bucket_90_plus)) * 100 '.$this->getRiskLevelOperator($riskLevel));
            });
        });
    }

    /**
     * Get the risk level operator for the query.
     */
    private function getRiskLevelOperator(string $riskLevel): string
    {
        return match ($riskLevel) {
            'critical' => '> 50',
            'high' => '> 30',
            'elevated' => '> 0',
            'moderate' => '> 0',
            default => '> 0'
        };
    }
}
