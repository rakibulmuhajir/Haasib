<?php

namespace Database\Factories;

use App\Models\Company;
use App\Models\Currency;
use App\Models\Customer;
use Illuminate\Database\Eloquent\Factories\Factory;

/**
 * @extends \Illuminate\Database\Eloquent\Factories\Factory<\App\Models\Payment>
 */
class PaymentFactory extends Factory
{
    protected $model = \App\Models\Payment::class;

    public function definition(): array
    {
        $company = Company::inRandomOrder()->first() ?? Company::factory()->create();
        $customer = Customer::factory()->create(['company_id' => $company->id]);
        $currency = Currency::where('code', 'USD')->first() ?? Currency::factory()->create(['code' => 'USD']);

        $paymentMethods = [
            'cash', 'check', 'bank_transfer', 'credit_card', 'debit_card',
            'paypal', 'stripe', 'other',
        ];

        $statuses = ['pending', 'completed', 'failed', 'cancelled'];
        $status = fake()->randomElement($statuses);

        $paymentDate = fake()->dateTimeBetween('-6 months', 'now');
        $amount = fake()->randomFloat(2, 50, 10000);

        return [
            'id' => fake()->uuid(),
            'company_id' => $company->id,
            'customer_id' => $customer->id,
            'payment_method' => fake()->randomElement($paymentMethods),
            'payment_reference' => null, // Will be generated by the model
            'amount' => $amount,
            'currency_id' => $currency->id,
            'exchange_rate' => 1.0,
            'status' => $status,
            'payment_date' => $paymentDate,
            'notes' => fake()->optional()->sentence(),
            'metadata' => [
                'created_by' => 'factory',
                'source' => 'test',
                'payment_method_details' => fake()->optional()->sentence(),
            ],
        ];
    }

    public function pending(): static
    {
        return $this->state(fn (array $attributes) => [
            'status' => 'pending',
            'metadata' => array_merge($attributes['metadata'] ?? [], ['pending_reason' => 'awaiting_processing']),
        ]);
    }

    public function completed(): static
    {
        return $this->state(fn (array $attributes) => [
            'status' => 'completed',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'completed_at' => now()->toISOString(),
                'processor_reference' => fake()->uuid(),
            ]),
        ]);
    }

    public function failed(): static
    {
        return $this->state(fn (array $attributes) => [
            'status' => 'failed',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'failed_at' => now()->toISOString(),
                'failure_reason' => fake()->randomElement([
                    'insufficient_funds',
                    'invalid_card',
                    'bank_declined',
                    'network_error',
                    'fraud_detected',
                ]),
            ]),
        ]);
    }

    public function cancelled(): static
    {
        return $this->state(fn (array $attributes) => [
            'status' => 'cancelled',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'cancelled_at' => now()->toISOString(),
                'cancellation_reason' => fake()->randomElement([
                    'customer_request',
                    'duplicate_payment',
                    'system_error',
                    'fraud_prevention',
                ]),
            ]),
        ]);
    }

    public function cash(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_method' => 'cash',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'cash_receipt_number' => 'CR'.fake()->numerify('######'),
            ]),
        ]);
    }

    public function check(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_method' => 'check',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'check_number' => fake()->numerify('########'),
                'bank_name' => fake()->company().' Bank',
            ]),
        ]);
    }

    public function bankTransfer(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_method' => 'bank_transfer',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'bank_reference' => 'BT'.fake()->numerify('########'),
                'from_account' => fake()->bankAccountNumber(),
                'to_account' => fake()->bankAccountNumber(),
            ]),
        ]);
    }

    public function creditCard(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_method' => 'credit_card',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'card_type' => fake()->randomElement(['visa', 'mastercard', 'amex', 'discover']),
                'last_four' => fake()->numerify('####'),
                'authorization_code' => fake()->numerify('######'),
            ]),
        ]);
    }

    public function debitCard(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_method' => 'debit_card',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'card_type' => fake()->randomElement(['visa', 'mastercard']),
                'last_four' => fake()->numerify('####'),
                'bank_name' => fake()->company().' Bank',
            ]),
        ]);
    }

    public function paypal(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_method' => 'paypal',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'paypal_transaction_id' => fake()->numerify('################'),
                'paypal_email' => fake()->email(),
            ]),
        ]);
    }

    public function stripe(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_method' => 'stripe',
            'metadata' => array_merge($attributes['metadata'] ?? [], [
                'stripe_charge_id' => 'ch_'.fake()->numerify('##################'),
                'stripe_payment_intent_id' => 'pi_'.fake()->numerify('##################'),
            ]),
        ]);
    }

    public function highValue(): static
    {
        return $this->state(fn (array $attributes) => [
            'amount' => fake()->randomFloat(2, 5000, 100000),
        ]);
    }

    public function lowValue(): static
    {
        return $this->state(fn (array $attributes) => [
            'amount' => fake()->randomFloat(2, 1, 100),
        ]);
    }

    public function recent(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_date' => fake()->dateTimeBetween('-7 days', 'now'),
        ]);
    }

    public function old(): static
    {
        return $this->state(fn (array $attributes) => [
            'payment_date' => fake()->dateTimeBetween('-6 months', '-3 months'),
        ]);
    }

    public function withExchangeRate(float $rate): static
    {
        return $this->state(fn (array $attributes) => [
            'exchange_rate' => $rate,
        ]);
    }

    public function forCompany(Company $company): static
    {
        return $this->state(fn (array $attributes) => [
            'company_id' => $company->id,
            'customer_id' => Customer::factory()->create(['company_id' => $company->id])->id,
        ]);
    }

    public function forCustomer(Customer $customer): static
    {
        return $this->state(fn (array $attributes) => [
            'company_id' => $customer->company_id,
            'customer_id' => $customer->id,
        ]);
    }

    public function withAllocations(int $count = 1): static
    {
        return $this->afterCreating(function ($payment) use ($count) {
            $invoices = Invoice::where('customer_id', $payment->customer_id)
                ->where('company_id', $payment->company_id)
                ->where('balance_due', '>', 0)
                ->take($count)
                ->get();

            if ($invoices->isEmpty()) {
                $invoices = collect([Invoice::factory()->create([
                    'company_id' => $payment->company_id,
                    'customer_id' => $payment->customer_id,
                    'total_amount' => $payment->amount,
                    'balance_due' => $payment->amount,
                ])]);
            }

            $allocationAmount = $payment->amount / $invoices->count();

            foreach ($invoices as $invoice) {
                PaymentAllocation::factory()->create([
                    'payment_id' => $payment->id,
                    'invoice_id' => $invoice->id,
                    'amount' => min($allocationAmount, $invoice->balance_due),
                ]);
            }
        });
    }

    public function fullyAllocated(): static
    {
        return $this->afterCreating(function ($payment) {
            $invoice = Invoice::factory()->create([
                'company_id' => $payment->company_id,
                'customer_id' => $payment->customer_id,
                'total_amount' => $payment->amount,
                'balance_due' => $payment->amount,
            ]);

            PaymentAllocation::factory()->create([
                'payment_id' => $payment->id,
                'invoice_id' => $invoice->id,
                'amount' => $payment->amount,
            ]);
        });
    }

    public function partiallyAllocated(): static
    {
        return $this->afterCreating(function ($payment) {
            $invoice = Invoice::factory()->create([
                'company_id' => $payment->company_id,
                'customer_id' => $payment->customer_id,
                'total_amount' => $payment->amount * 2,
                'balance_due' => $payment->amount * 2,
            ]);

            PaymentAllocation::factory()->create([
                'payment_id' => $payment->id,
                'invoice_id' => $invoice->id,
                'amount' => $payment->amount * 0.7,
            ]);
        });
    }
}
