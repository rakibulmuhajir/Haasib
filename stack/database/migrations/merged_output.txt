
=== File: 2025_10_14_130000_command_palette_rollback.php ===
Path: 2025_10_14_130000_command_palette_rollback.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;

return new class
{
    /**
     * Run the rollback of Command Palette migrations.
     * This should be called in the down() method of the last migration.
     */
    public static function rollbackCommandPalette(): void
    {
        $migrations = [
            '2025_10_14_120200_add_command_performance_indexes',
            '2025_10_14_120100_create_command_analytics_table',
            '2025_10_14_120000_create_command_configurations_table',
            '2025_10_13_165756_create_command_templates_table',
            '2025_10_13_165756_create_command_history_table',
            '2025_10_13_165755_create_command_executions_table',
            '2025_10_13_165707_create_commands_table',
        ];

        // Rollback in reverse order
        foreach (array_reverse($migrations) as $migration) {
            try {
                DB::table('migrations')
                    ->where('migration', $migration)
                    ->delete();

                echo "Rolled back migration: {$migration}\n";
            } catch (\Exception $e) {
                echo "Failed to rollback migration {$migration}: {$e->getMessage()}\n";
            }
        }

        // Drop tables in correct order (respecting foreign keys)
        $tables = [
            'command_analytics',
            'command_configurations',
            'command_templates',
            'command_history',
            'command_executions',
            'commands',
        ];

        foreach ($tables as $table) {
            try {
                if (DB::getSchemaBuilder()->hasTable($table)) {
                    DB::getSchemaBuilder()->drop($table);
                    echo "Dropped table: {$table}\n";
                }
            } catch (\Exception $e) {
                echo "Failed to drop table {$table}: {$e->getMessage()}\n";
            }
        }
    }
};

---- File Content End ----


=== File: 2025_10_05_100001_create_auth_schema.php ===
Path: 2025_10_05_100001_create_auth_schema.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Drop all tables in auth schema to ensure clean state (drop entire schema and recreate)
        DB::statement('DROP SCHEMA IF EXISTS auth CASCADE');

        // Drop any functions in auth schema
        DB::statement('DROP FUNCTION IF EXISTS auth.set_updated_by() CASCADE');

        // Create auth schema if it doesn't exist
        DB::statement('CREATE SCHEMA IF NOT EXISTS auth');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop all tables in auth schema before dropping schema
        $tables = DB::select("SELECT tablename FROM pg_tables WHERE schemaname = 'auth'");

        foreach ($tables as $table) {
            Schema::dropIfExists('auth.'.$table->tablename);
        }

        // Drop the schema
        DB::statement('DROP SCHEMA IF EXISTS auth CASCADE');
    }
};

---- File Content End ----


=== File: 2025_01_15_000003_create_unallocated_cash_table.php ===
Path: 2025_01_15_000003_create_unallocated_cash_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades.Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.unallocated_cash', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('payment_id');
            $table->uuid('customer_id');
            $table->uuid('company_id');
            $table->decimal('amount', 18, 2);
            $table->string('currency', 3);
            $table->string('status', 20)->default('available');
            $table->decimal('allocated_amount', 18, 2)->default(0);
            $table->text('notes')->nullable();
            $table->json('metadata')->nullable();
            $table->timestamps();
            $table->softDeletes();

            // Indexes
            $table->index(['company_id', 'customer_id']);
            $table->index(['company_id', 'status']);
            $table->index(['company_id', 'currency']);
            $table->index(['payment_id']);
            $table->index(['customer_id']);
            $table->index(['status']);
            $table->index(['created_at']);

            // Foreign keys
            $table->foreign('payment_id')
                  ->references('id')
                  ->on('acct.payments')
                  ->onDelete('cascade');

            $table->foreign('customer_id')
                  ->references('id')
                  ->on('acct.customers')
                  ->onDelete('cascade');

            $table->foreign('company_id')
                  ->references('id')
                  ->on('auth.companies')
                  ->onDelete('cascade');

            // Unique constraint to prevent duplicate unallocated cash for same payment
            $table->unique(['payment_id'], 'unallocated_cash_payment_unique');
        });

        // Create trigger for automatic RLS
        DB::unprepared("
            CREATE TRIGGER unallocated_cash_rls_trigger
            BEFORE INSERT ON acct.unallocated_cash
            FOR EACH ROW
            EXECUTE FUNCTION set_current_company_id();
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('acct.unallocated_cash');
    }
};

---- File Content End ----


=== File: 2025_10_13_133632_create_payments_table.php ===
Path: 2025_10_13_133632_create_payments_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.payments', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->uuid('customer_id');
            $table->string('payment_number', 50);
            $table->date('payment_date');
            $table->string('payment_method', 50);
            $table->string('reference_number', 100)->nullable();
            $table->decimal('amount', 15, 2);
            $table->string('currency', 3);
            $table->string('status', 20)->default('pending'); // pending, completed, failed, cancelled
            $table->text('notes')->nullable();
            $table->uuid('paymentable_id')->nullable(); // For backward compatibility
            $table->string('paymentable_type')->nullable(); // For backward compatibility
            $table->uuid('created_by_user_id');
            $table->timestamps();

            // Foreign keys
            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->foreign('customer_id')->references('id')->on('acct.customers')->onDelete('cascade');
            $table->foreign('created_by_user_id')->references('id')->on('auth.users')->onDelete('restrict');

            // Indexes
            $table->unique(['company_id', 'payment_number']);
            $table->index(['company_id']);
            $table->index(['customer_id']);
            $table->index(['company_id', 'customer_id']);
            $table->index(['company_id', 'payment_date']);
            $table->index(['company_id', 'status']);
            $table->index(['company_id', 'payment_method']);
        });

        // Add soft deletes
        Schema::table('acct.payments', function (Blueprint $table) {
            $table->softDeletes();
        });

        DB::statement('
            ALTER TABLE acct.payments
            ADD CONSTRAINT payments_amount_positive
            CHECK (amount >= 0)
        ');

        // Enforce tenant isolation
        DB::statement('ALTER TABLE acct.payments ENABLE ROW LEVEL SECURITY');
        DB::statement("
            CREATE POLICY payments_company_policy
            ON acct.payments
            FOR ALL
            USING (
                company_id = current_setting('app.current_company_id')::uuid
            )
            WITH CHECK (
                company_id = current_setting('app.current_company_id')::uuid
            )
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::statement('DROP POLICY IF EXISTS payments_company_policy ON acct.payments');
        DB::statement('ALTER TABLE acct.payments DISABLE ROW LEVEL SECURITY');
        Schema::dropIfExists('acct.payments');
    }
};

---- File Content End ----


=== File: 2025_10_15_120130_create_customer_communications_table.php ===
Path: 2025_10_15_120130_create_customer_communications_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.customer_communications', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('customer_id');
            $table->uuid('company_id');
            $table->uuid('contact_id')->nullable();
            $table->enum('channel', ['email', 'phone', 'meeting', 'note']);
            $table->enum('direction', ['inbound', 'outbound', 'internal']);
            $table->string('subject', 255)->nullable();
            $table->text('body');
            $table->uuid('logged_by_user_id');
            $table->timestamp('occurred_at');
            $table->jsonb('attachments')->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('cascade');

            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('contact_id')
                ->references('id')
                ->on('acct.customer_contacts')
                ->onDelete('set null');

            $table->foreign('logged_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('cascade');

            // Indexes
            $table->index(['customer_id', 'company_id']);
            $table->index(['company_id', 'channel']);
            $table->index(['company_id', 'direction']);
            $table->index(['customer_id', 'occurred_at']);
            $table->index(['logged_by_user_id', 'occurred_at']);
            $table->index(['contact_id', 'occurred_at']);
        });

        // Enable RLS (Row Level Security)
        DB::statement('ALTER TABLE acct.customer_communications ENABLE ROW LEVEL SECURITY');

        // Create RLS policy to enforce tenancy
        DB::statement('
            CREATE POLICY customer_communications_company_policy 
            ON acct.customer_communications 
            FOR ALL 
            TO authenticated_user 
            USING (company_id = current_setting(\'app.current_company_id\')::uuid)
        ');

        // Create audit trigger for communication logs
        DB::statement('
            CREATE OR REPLACE FUNCTION acct.customer_communications_audit_trigger()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = \'INSERT\' THEN
                    PERFORM audit_log(
                        \'customer_communication_logged\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'customer_id\', NEW.customer_id,
                            \'company_id\', NEW.company_id,
                            \'contact_id\', NEW.contact_id,
                            \'channel\', NEW.channel,
                            \'direction\', NEW.direction,
                            \'subject\', NEW.subject,
                            \'occurred_at\', NEW.occurred_at,
                            \'logged_by_user_id\', NEW.logged_by_user_id
                        ),
                        NEW.logged_by_user_id
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'UPDATE\' THEN
                    PERFORM audit_log(
                        \'customer_communication_updated\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'customer_id\', NEW.customer_id,
                            \'company_id\', NEW.company_id,
                            \'old_subject\', OLD.subject,
                            \'new_subject\', NEW.subject,
                            \'old_body\', OLD.body,
                            \'new_body\', NEW.body
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'DELETE\' THEN
                    PERFORM audit_log(
                        \'customer_communication_deleted\',
                        json_build_object(
                            \'id\', OLD.id,
                            \'customer_id\', OLD.customer_id,
                            \'company_id\', OLD.company_id,
                            \'channel\', OLD.channel,
                            \'direction\', OLD.direction,
                            \'occurred_at\', OLD.occurred_at
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN OLD;
                END IF;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        ');

        // Attach the trigger
        DB::statement('
            CREATE TRIGGER customer_communications_audit_trigger
            AFTER INSERT OR UPDATE OR DELETE
            ON acct.customer_communications
            FOR EACH ROW EXECUTE FUNCTION acct.customer_communications_audit_trigger()
        ');

        // Create function to get communication timeline for a customer
        DB::statement('
            CREATE OR REPLACE FUNCTION acct.get_customer_communication_timeline(
                p_customer_id UUID,
                p_company_id UUID,
                p_limit INTEGER DEFAULT 50,
                p_offset INTEGER DEFAULT 0
            )
            RETURNS TABLE (
                id UUID,
                channel TEXT,
                direction TEXT,
                subject TEXT,
                body TEXT,
                occurred_at TIMESTAMP,
                logged_by_user_id UUID,
                logged_by_user_name TEXT,
                contact_id UUID,
                contact_name TEXT,
                attachments JSONB
            ) AS $$
            BEGIN
                RETURN QUERY
                SELECT 
                    comm.id,
                    comm.channel::TEXT,
                    comm.direction::TEXT,
                    comm.subject,
                    comm.body,
                    comm.occurred_at,
                    comm.logged_by_user_id,
                    CONCAT(u.first_name, \' \', u.last_name) as logged_by_user_name,
                    comm.contact_id,
                    CASE 
                        WHEN comm.contact_id IS NOT NULL THEN 
                            CONCAT(cc.first_name, \' \', cc.last_name)
                        ELSE NULL
                    END as contact_name,
                    comm.attachments
                FROM acct.customer_communications comm
                LEFT JOIN auth.users u ON u.id = comm.logged_by_user_id
                LEFT JOIN acct.customer_contacts cc ON cc.id = comm.contact_id
                WHERE comm.customer_id = p_customer_id 
                  AND comm.company_id = p_company_id
                ORDER BY comm.occurred_at DESC
                LIMIT p_limit OFFSET p_offset;
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER;
        ');

        // Grant execute permission to authenticated users
        DB::statement('GRANT EXECUTE ON FUNCTION acct.get_customer_communication_timeline TO authenticated_user');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop function and permissions
        DB::statement('REVOKE EXECUTE ON FUNCTION acct.get_customer_communication_timeline FROM authenticated_user');
        DB::statement('DROP FUNCTION IF EXISTS acct.get_customer_communication_timeline');

        // Drop trigger and function
        DB::statement('DROP TRIGGER IF EXISTS customer_communications_audit_trigger ON acct.customer_communications');
        DB::statement('DROP FUNCTION IF EXISTS acct.customer_communications_audit_trigger()');

        // Drop RLS policy
        DB::statement('DROP POLICY IF EXISTS customer_communications_company_policy ON acct.customer_communications');

        Schema::dropIfExists('acct.customer_communications');
    }
};

---- File Content End ----


=== File: 2025_10_13_125002_create_payment_allocations_table.php ===
Path: 2025_10_13_125002_create_payment_allocations_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.payment_allocations', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->uuid('payment_id');
            $table->uuid('invoice_id');
            $table->decimal('allocated_amount', 15, 2);
            $table->timestamp('allocation_date');
            $table->string('allocation_method', 50)->default('manual'); // manual, automatic, fifo, proportional
            $table->string('allocation_strategy', 50)->nullable(); // fifo, due_date, amount, custom
            $table->text('notes')->nullable();
            $table->timestamp('reversed_at')->nullable();
            $table->text('reversal_reason')->nullable();
            $table->uuid('reversed_by_user_id')->nullable();
            $table->uuid('created_by_user_id');
            $table->timestamps();

            // Foreign keys
            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->foreign('payment_id')->references('id')->on('acct.payments')->onDelete('cascade');
            $table->foreign('invoice_id')->references('id')->on('acct.invoices')->onDelete('cascade');
            $table->foreign('created_by_user_id')->references('id')->on('auth.users')->onDelete('restrict');
            $table->foreign('reversed_by_user_id')->references('id')->on('auth.users')->onDelete('set null');

            // Indexes
            $table->index(['company_id']);
            $table->index(['payment_id']);
            $table->index(['invoice_id']);
            $table->index(['company_id', 'payment_id']);
            $table->index(['company_id', 'invoice_id']);
            $table->index(['allocation_date']);
            $table->index(['allocation_method']);
            $table->index(['allocation_strategy']);
            $table->index(['reversed_at']);
        });

        // Add soft deletes
        Schema::table('acct.payment_allocations', function (Blueprint $table) {
            $table->softDeletes();
        });

        DB::statement('
            CREATE UNIQUE INDEX payment_allocations_unique_active
            ON acct.payment_allocations (payment_id, invoice_id)
            WHERE reversed_at IS NULL
        ');

        DB::statement('
            ALTER TABLE acct.payment_allocations
            ADD CONSTRAINT payment_allocations_amount_positive
            CHECK (allocated_amount >= 0)
        ');

        DB::statement('ALTER TABLE acct.payment_allocations ENABLE ROW LEVEL SECURITY');
        DB::statement("
            CREATE POLICY payment_allocations_company_policy
            ON acct.payment_allocations
            FOR ALL
            USING (
                company_id = current_setting('app.current_company_id')::uuid
            )
            WITH CHECK (
                company_id = current_setting('app.current_company_id')::uuid
            )
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::statement('DROP POLICY IF EXISTS payment_allocations_company_policy ON acct.payment_allocations');
        DB::statement('ALTER TABLE acct.payment_allocations DISABLE ROW LEVEL SECURITY');
        Schema::dropIfExists('acct.payment_allocations');
    }
};

---- File Content End ----


=== File: 2025_10_12_134703_create_invoice_templates_table.php ===
Path: 2025_10_12_134703_create_invoice_templates_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades.DB;
use Illuminate\Support\Facades.Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.invoice_templates', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('name', 255);
            $table->text('description')->nullable();
            $table->uuid('customer_id')->nullable();
            $table->string('currency', 3);
            $table->jsonb('template_data');
            $table->jsonb('settings')->nullable();
            $table->boolean('is_active')->default(true);
            $table->uuid('created_by_user_id');
            $table->timestamps();
            $table->softDeletes();

            // Foreign key constraints
            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('set null');

            $table->foreign('created_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('cascade');

            // Indexes for performance
            $table->index(['company_id', 'is_active']);
            $table->index(['company_id', 'customer_id']);
            $table->index(['currency']);
            $table->index(['is_active']);
            $table->index(['created_by_user_id']);
        });

        DB::statement('ALTER TABLE acct.invoice_templates ENABLE ROW LEVEL SECURITY');
        DB::statement("
            CREATE POLICY invoice_templates_company_policy
            ON acct.invoice_templates
            FOR ALL
            USING (
                company_id = current_setting('app.current_company_id')::uuid
            )
            WITH CHECK (
                company_id = current_setting('app.current_company_id')::uuid
            )
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::statement('DROP POLICY IF EXISTS invoice_templates_company_policy ON acct.invoice_templates');
        DB::statement('ALTER TABLE acct.invoice_templates DISABLE ROW LEVEL SECURITY');
        Schema::dropIfExists('acct.invoice_templates');
    }
};

---- File Content End ----


=== File: 2025_10_05_100008_update_companies_rls_policies.php ===
Path: 2025_10_05_100008_update_companies_rls_policies.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Drop existing RLS policies for companies table
        DB::statement('DROP POLICY IF EXISTS companies_select_policy ON auth.companies');
        DB::statement('DROP POLICY IF EXISTS companies_update_policy ON auth.companies');

        // Create updated RLS policies for companies table that reference company_user
        // Policy: Users can see companies they belong to, superadmins can see all
        DB::statement("
            CREATE POLICY companies_select_policy ON auth.companies
            FOR SELECT
            USING (
                id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Users can update companies they own or are admins of, superadmins can update all
        DB::statement("
            CREATE POLICY companies_update_policy ON auth.companies
            FOR UPDATE
            USING (
                id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop updated RLS policies
        DB::statement('DROP POLICY IF EXISTS companies_select_policy ON auth.companies');
        DB::statement('DROP POLICY IF EXISTS companies_update_policy ON auth.companies');

        // Recreate basic RLS policies
        DB::statement("
            CREATE POLICY companies_select_policy ON auth.companies
            FOR SELECT
            USING (
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        DB::statement("
            CREATE POLICY companies_update_policy ON auth.companies
            FOR UPDATE
            USING (
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");
    }
};

---- File Content End ----


=== File: 2025_10_15_124630_update_customers_table_add_customer_lifecycle_fields.php ===
Path: 2025_10_15_124630_update_customers_table_add_customer_lifecycle_fields.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('acct.customers', function (Blueprint $table) {
            // Add legal_name field
            $table->string('legal_name')->nullable()->after('name');

            // Update customer_number to be unique per company
            $table->dropUnique(['customer_number']);
            $table->unique(['company_id', 'customer_number']);

            // Add default_currency field (required)
            $table->char('default_currency', 3)->after('phone');

            // Update credit_limit to be more precise
            $table->decimal('credit_limit', 15, 2)->change();

            // Add credit_limit_effective_at for tracking when limit was set
            $table->timestamp('credit_limit_effective_at')->nullable()->after('credit_limit');

            // Replace is_active with enum status
            $table->dropColumn('is_active');
            $table->enum('status', ['active', 'inactive', 'blocked'])->default('active')->after('email');

            // Add new indexes
            $table->index(['company_id', 'status']);
            $table->index(['company_id', 'email']);

            // Add trigram index for name search (PostgreSQL specific)
            DB::statement('CREATE INDEX customers_name_trigram_idx ON "acct.customers" USING gin(name gin_trgm_ops)');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('acct.customers', function (Blueprint $table) {
            $table->dropColumn(['legal_name', 'default_currency', 'credit_limit_effective_at', 'status']);

            // Restore is_active
            $table->boolean('is_active')->default(true)->after('email');

            // Restore original customer_number uniqueness
            $table->dropUnique(['company_id', 'customer_number']);
            $table->unique(['customer_number']);

            // Restore original credit_limit precision
            $table->decimal('credit_limit', 10, 2)->change();

            // Drop indexes
            $table->dropIndex(['company_id', 'status']);
            $table->dropIndex(['company_id', 'email']);
        });

        // Drop trigram index
        DB::statement('DROP INDEX IF EXISTS customers_name_trigram_idx');
    }
};

---- File Content End ----


=== File: 2025_10_05_100002_create_users_table.php ===
Path: 2025_10_05_100002_create_users_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Create auth schema if it doesn't exist
        DB::statement('CREATE SCHEMA IF NOT EXISTS auth');

        Schema::create('auth.users', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('username')->unique();
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->string('system_role')->default('user')->comment('superadmin, admin, user');
            $table->uuid('created_by_user_id')->nullable();
            $table->boolean('is_active')->default(true);
            $table->json('settings')->nullable();
            $table->rememberToken();
            $table->timestamps();

            // Indexes
            $table->index('email');
            $table->index('username');
            $table->index('system_role');
            $table->index('is_active');
            $table->index('created_by_user_id');
            $table->index(['is_active', 'system_role']);
        });

        // Add foreign key constraint after table creation
        Schema::table('auth.users', function (Blueprint $table) {
            $table->foreign('created_by_user_id')
                ->references('id')->on('auth.users')
                ->onDelete('set null');
        });

        // Add RLS policy for users table
        DB::statement('
            ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;
        ');

        // Create RLS policy - users can see their own record, superadmins can see all
        DB::statement("
            CREATE POLICY users_select_policy ON auth.users
            FOR SELECT
            USING (
                id = current_setting('app.current_user_id', true)::uuid
                OR
                system_role = 'superadmin'
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Create RLS policy for updates - users can update their own record, superadmins can update all
        DB::statement("
            CREATE POLICY users_update_policy ON auth.users
            FOR UPDATE
            USING (
                id = current_setting('app.current_user_id', true)::uuid
                OR
                system_role = 'superadmin'
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Create trigger to set audit fields
        DB::statement('
            CREATE OR REPLACE FUNCTION auth.set_updated_by()
            RETURNS TRIGGER AS $$
            BEGIN
                NEW.updated_at = NOW();
                RETURN NEW;
            END;
            $$ LANGUAGE plpgsql;
        ');

        DB::statement('
            CREATE TRIGGER users_updated_at
                BEFORE UPDATE ON auth.users
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger and function first
        DB::statement('DROP TRIGGER IF EXISTS users_updated_at ON auth.users');
        DB::statement('DROP FUNCTION IF EXISTS auth.set_updated_by()');

        // Drop table
        Schema::dropIfExists('auth.users');
    }
};

---- File Content End ----


=== File: 2025_10_10_105930_create_sessions_table.php ===
Path: 2025_10_10_105930_create_sessions_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('auth.sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('auth.sessions');
    }
};

---- File Content End ----


=== File: 2025_10_15_120200_create_customer_credit_limits_table.php ===
Path: 2025_10_15_120200_create_customer_credit_limits_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.customer_credit_limits', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('customer_id');
            $table->uuid('company_id');
            $table->decimal('limit_amount', 15, 2);
            $table->timestamp('effective_at');
            $table->timestamp('expires_at')->nullable();
            $table->enum('status', ['pending', 'approved', 'revoked'])->default('approved');
            $table->text('reason')->nullable();
            $table->uuid('changed_by_user_id');
            $table->string('approval_reference', 100)->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('cascade');

            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('changed_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('restrict');

            // Indexes for performance
            $table->index(['customer_id', 'effective_at'], 'idx_customer_effective');
            $table->index(['company_id', 'status'], 'idx_company_status');
            $table->index(['expires_at'], 'idx_expires');

            // Ensure only one active limit per customer at any given time
            $table->unique(['customer_id', 'effective_at'], 'uniq_customer_effective');
        });

        // Create trigger for audit logging
        $this->createAuditTrigger();

        // Enable Row Level Security
        $this->enableRLS();

        // Create RLS policies
        $this->createRLSPolicies();
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::statement('DROP POLICY IF EXISTS customer_credit_limits_system_admin ON acct.customer_credit_limits');
        DB::statement('DROP POLICY IF EXISTS customer_credit_limits_manage ON acct.customer_credit_limits');
        DB::statement('DROP POLICY IF EXISTS customer_credit_limits_view_company ON acct.customer_credit_limits');
        DB::statement('ALTER TABLE acct.customer_credit_limits DISABLE ROW LEVEL SECURITY');
        DB::statement('DROP TRIGGER IF EXISTS customer_credit_limits_audit_trigger ON acct.customer_credit_limits');
        Schema::dropIfExists('acct.customer_credit_limits');
    }

    /**
     * Create audit trigger for credit limit changes
     */
    private function createAuditTrigger(): void
    {
        $triggerSql = <<<'SQL'
        CREATE OR REPLACE FUNCTION audit_customer_credit_limits()
        RETURNS TRIGGER AS $$
        BEGIN
            IF TG_OP = 'INSERT' THEN
                INSERT INTO acct.audit_logs (
                    action,
                    subject_type,
                    subject_id,
                    company_id,
                    user_id,
                    old_values,
                    new_values,
                    created_at
                ) VALUES (
                    'credit_limit_created',
                    'App\Models\Customer',
                    NEW.customer_id,
                    NEW.company_id,
                    NEW.changed_by_user_id,
                    jsonb_build_object(),
                    jsonb_build_object(
                        'limit_amount', NEW.limit_amount,
                        'effective_at', NEW.effective_at,
                        'expires_at', NEW.expires_at,
                        'status', NEW.status,
                        'reason', NEW.reason
                    ),
                    NOW()
                );
                RETURN NEW;
            ELSIF TG_OP = 'UPDATE' THEN
                INSERT INTO acct.audit_logs (
                    action,
                    subject_type,
                    subject_id,
                    company_id,
                    user_id,
                    old_values,
                    new_values,
                    created_at
                ) VALUES (
                    'credit_limit_updated',
                    'App\Models\Customer',
                    NEW.customer_id,
                    NEW.company_id,
                    NEW.changed_by_user_id,
                    jsonb_build_object(
                        'limit_amount', OLD.limit_amount,
                        'effective_at', OLD.effective_at,
                        'expires_at', OLD.expires_at,
                        'status', OLD.status,
                        'reason', OLD.reason
                    ),
                    jsonb_build_object(
                        'limit_amount', NEW.limit_amount,
                        'effective_at', NEW.effective_at,
                        'expires_at', NEW.expires_at,
                        'status', NEW.status,
                        'reason', NEW.reason
                    ),
                    NOW()
                );
                RETURN NEW;
            ELSIF TG_OP = 'DELETE' THEN
                INSERT INTO acct.audit_logs (
                    action,
                    subject_type,
                    subject_id,
                    company_id,
                    user_id,
                    old_values,
                    new_values,
                    created_at
                ) VALUES (
                    'credit_limit_deleted',
                    'App\Models\Customer',
                    OLD.customer_id,
                    OLD.company_id,
                    OLD.changed_by_user_id,
                    jsonb_build_object(
                        'limit_amount', OLD.limit_amount,
                        'effective_at', OLD.effective_at,
                        'expires_at', OLD.expires_at,
                        'status', OLD.status,
                        'reason', OLD.reason
                    ),
                    jsonb_build_object(),
                    NOW()
                );
                RETURN OLD;
            END IF;
            RETURN NULL;
        END;
        $$ LANGUAGE plpgsql;

        DROP TRIGGER IF EXISTS customer_credit_limits_audit_trigger ON acct.customer_credit_limits;
        CREATE TRIGGER customer_credit_limits_audit_trigger
            AFTER INSERT OR UPDATE OR DELETE ON acct.customer_credit_limits
            FOR EACH ROW EXECUTE FUNCTION audit_customer_credit_limits();
        SQL;

        DB::unprepared($triggerSql);
    }

    /**
     * Enable Row Level Security
     */
    private function enableRLS(): void
    {
        DB::unprepared('ALTER TABLE acct.customer_credit_limits ENABLE ROW LEVEL SECURITY;');
    }

    /**
     * Create RLS policies
     */
    private function createRLSPolicies(): void
    {
        $policies = [
            // Company users can view credit limits for their company
            'CREATE POLICY customer_credit_limits_view_company ON acct.customer_credit_limits
                FOR SELECT USING (
                    company_id = current_setting(\'app.current_company_id\')::uuid
                );',

            // Users with permission can manage credit limits
            'CREATE POLICY customer_credit_limits_manage ON acct.customer_credit_limits
                FOR ALL USING (
                    company_id = current_setting(\'app.current_company_id\')::uuid AND
                    EXISTS (
                        SELECT 1 FROM user_company_permissions ucp
                        WHERE ucp.user_id = current_setting(\'app.current_user_id\')::uuid
                        AND ucp.company_id = current_setting(\'app.current_company_id\')::uuid
                        AND ucp.permission = \'accounting.customers.manage_credit\'
                    )
                );',

            // System admins can access all
            'CREATE POLICY customer_credit_limits_system_admin ON acct.customer_credit_limits
                FOR ALL USING (
                    EXISTS (
                        SELECT 1 FROM users
                        WHERE id = current_setting(\'app.current_user_id\')::uuid
                        AND is_system_admin = true
                    )
                );',
        ];

        foreach ($policies as $policy) {
            DB::unprepared($policy);
        }
    }
};

---- File Content End ----


=== File: 2025_10_13_165707_create_commands_table.php ===
Path: 2025_10_13_165707_create_commands_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('commands', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('name');
            $table->text('description');
            $table->json('parameters');
            $table->json('required_permissions');
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->index(['company_id', 'is_active']);
            $table->index('name');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('commands');
    }
};

---- File Content End ----


=== File: 2025_10_15_120300_create_customer_statements_table.php ===
Path: 2025_10_15_120300_create_customer_statements_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.customer_statements', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('customer_id');
            $table->uuid('company_id');
            $table->date('period_start');
            $table->date('period_end');
            $table->timestamp('generated_at');
            $table->uuid('generated_by_user_id')->nullable();
            $table->decimal('opening_balance', 15, 2);
            $table->decimal('total_invoiced', 15, 2);
            $table->decimal('total_paid', 15, 2);
            $table->decimal('total_credit_notes', 15, 2);
            $table->decimal('closing_balance', 15, 2);
            $table->jsonb('aging_bucket_summary');
            $table->string('document_path', 255)->nullable();
            $table->string('checksum', 64)->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('cascade');

            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('generated_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('set null');

            // Indexes for performance
            $table->index(['customer_id', 'period_start', 'period_end'], 'idx_customer_period');
            $table->index(['company_id', 'generated_at'], 'idx_company_generated');
            $table->index(['generated_at'], 'idx_generated_at');
            $table->index('checksum', 'idx_checksum');

            // Ensure uniqueness: one statement per customer per period
            $table->unique(['customer_id', 'period_start', 'period_end'], 'uniq_customer_period');
        });

        // Create trigger for audit logging
        $this->createAuditTrigger();

        // Enable Row Level Security
        $this->enableRLS();

        // Create RLS policies
        $this->createRLSPolicies();
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('acct.customer_statements');
    }

    /**
     * Create audit trigger for customer statements.
     */
    private function createAuditTrigger(): void
    {
        $trigger = <<<'SQL'
        CREATE OR REPLACE FUNCTION acct.customer_statements_audit_trigger()
        RETURNS TRIGGER AS $$
        DECLARE
            audit_action TEXT;
            audit_user UUID;
            details JSONB;
        BEGIN
            -- Determine action
            IF TG_OP = 'INSERT' THEN
                audit_action := 'created';
                audit_user := NEW.generated_by_user_id;
                details := jsonb_build_object(
                    'statement_id', NEW.id,
                    'customer_id', NEW.customer_id,
                    'period_start', NEW.period_start,
                    'period_end', NEW.period_end,
                    'opening_balance', NEW.opening_balance,
                    'total_invoiced', NEW.total_invoiced,
                    'total_paid', NEW.total_paid,
                    'total_credit_notes', NEW.total_credit_notes,
                    'closing_balance', NEW.closing_balance,
                    'document_path', NEW.document_path
                );
                INSERT INTO acct.audit_logs (
                    table_name, 
                    record_id, 
                    action, 
                    details, 
                    user_id, 
                    company_id, 
                    created_at
                ) VALUES (
                    'customer_statements',
                    NEW.id,
                    audit_action,
                    details,
                    audit_user,
                    NEW.company_id,
                    NOW()
                );
                RETURN NEW;
            
            ELSIF TG_OP = 'UPDATE' THEN
                audit_action := 'updated';
                audit_user := COALESCE(NEW.generated_by_user_id, OLD.generated_by_user_id);
                details := jsonb_build_object(
                    'statement_id', NEW.id,
                    'customer_id', NEW.customer_id,
                    'changes', jsonb_build_object(
                        'document_path', CASE WHEN OLD.document_path IS DISTINCT FROM NEW.document_path THEN NEW.document_path ELSE NULL END,
                        'checksum', CASE WHEN OLD.checksum IS DISTINCT FROM NEW.checksum THEN NEW.checksum ELSE NULL END
                    )
                );
                INSERT INTO acct.audit_logs (
                    table_name, 
                    record_id, 
                    action, 
                    details, 
                    user_id, 
                    company_id, 
                    created_at
                ) VALUES (
                    'customer_statements',
                    NEW.id,
                    audit_action,
                    details,
                    audit_user,
                    NEW.company_id,
                    NOW()
                );
                RETURN NEW;
            
            ELSIF TG_OP = 'DELETE' THEN
                audit_action := 'deleted';
                details := jsonb_build_object(
                    'statement_id', OLD.id,
                    'customer_id', OLD.customer_id,
                    'period_start', OLD.period_start,
                    'period_end', OLD.period_end,
                    'deleted_data', jsonb_build_object(
                        'opening_balance', OLD.opening_balance,
                        'total_invoiced', OLD.total_invoiced,
                        'total_paid', OLD.total_paid,
                        'total_credit_notes', OLD.total_credit_notes,
                        'closing_balance', OLD.closing_balance
                    )
                );
                INSERT INTO acct.audit_logs (
                    table_name, 
                    record_id, 
                    action, 
                    details, 
                    user_id, 
                    company_id, 
                    created_at
                ) VALUES (
                    'customer_statements',
                    OLD.id,
                    audit_action,
                    details,
                    OLD.generated_by_user_id,
                    OLD.company_id,
                    NOW()
                );
                RETURN OLD;
            END IF;
            
            RETURN NULL;
        END;
        $$ LANGUAGE plpgsql;
        SQL;

        // Create trigger function
        DB::unprepared($trigger);

        // Create trigger
        DB::unprepared('
            CREATE TRIGGER customer_statements_audit
                AFTER INSERT OR UPDATE OR DELETE ON acct.customer_statements
                FOR EACH ROW EXECUTE FUNCTION acct.customer_statements_audit_trigger();
        ');
    }

    /**
     * Enable Row Level Security on customer_statements table.
     */
    private function enableRLS(): void
    {
        DB::unprepared('ALTER TABLE acct.customer_statements ENABLE ROW LEVEL SECURITY;');
    }

    /**
     * Create Row Level Security policies for customer_statements.
     */
    private function createRLSPolicies(): void
    {
        $policies = [
            // Company users can view statements for their company
            'CREATE POLICY customer_statements_view_company ON acct.customer_statements
                FOR SELECT USING (
                    company_id = current_setting(\'app.current_company_id\')::uuid
                );',

            // Users with permission can manage statements
            'CREATE POLICY customer_statements_manage ON acct.customer_statements
                FOR ALL USING (
                    company_id = current_setting(\'app.current_company_id\')::uuid AND
                    EXISTS (
                        SELECT 1 FROM user_company_permissions ucp
                        WHERE ucp.user_id = current_setting(\'app.current_user_id\')::uuid
                        AND ucp.company_id = current_setting(\'app.current_company_id\')::uuid
                        AND ucp.permission = \'accounting.customers.generate_statements\'
                    )
                );',

            // System admins can access all statements
            'CREATE POLICY customer_statements_system_admin ON acct.customer_statements
                FOR ALL USING (
                    EXISTS (
                        SELECT 1 FROM users
                        WHERE id = current_setting(\'app.current_user_id\')::uuid
                        AND is_system_admin = true
                    )
                );',
        ];

        foreach ($policies as $policy) {
            DB::unprepared($policy);
        }
    }
};

---- File Content End ----


=== File: 2025_10_05_100005_create_modules_table.php ===
Path: 2025_10_05_100005_create_modules_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Str;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('auth.modules', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('key')->unique();
            $table->text('description')->nullable();
            $table->string('version')->default('1.0.0');
            $table->string('category')->default('general');
            $table->string('icon')->nullable();
            $table->boolean('is_core')->default(false);
            $table->boolean('is_active')->default(true);
            $table->json('dependencies')->nullable()->comment('Array of module keys this module depends on');
            $table->json('settings_schema')->nullable()->comment('JSON schema for module settings');
            $table->json('permissions')->nullable()->comment('Array of permissions this module provides');
            $table->integer('menu_order')->default(999);
            $table->string('developer')->nullable();
            $table->string('documentation_url')->nullable();
            $table->timestamps();

            // Indexes
            $table->index('key');
            $table->index('category');
            $table->index('is_core');
            $table->index('is_active');
            $table->index(['category', 'menu_order']);
            $table->index(['is_active', 'category']);
        });

        // Insert core modules
        DB::table('auth.modules')->insert([
            [
                'id' => Str::uuid(),
                'name' => 'Core Accounting',
                'key' => 'core_accounting',
                'description' => 'Core accounting features including chart of accounts, journal entries, and financial reports',
                'version' => '1.0.0',
                'category' => 'accounting',
                'icon' => 'calculator',
                'is_core' => true,
                'is_active' => true,
                'dependencies' => json_encode([]),
                'permissions' => json_encode([
                    'view_accounts',
                    'manage_accounts',
                    'view_journal_entries',
                    'create_journal_entries',
                    'edit_journal_entries',
                    'delete_journal_entries',
                    'view_reports',
                    'generate_reports',
                ]),
                'menu_order' => 1,
                'developer' => 'Haasib Team',
                'created_at' => now(),
                'updated_at' => now(),
            ],
            [
                'id' => Str::uuid(),
                'name' => 'Invoicing',
                'key' => 'invoicing',
                'description' => 'Create and manage invoices, track payments, and send reminders',
                'version' => '1.0.0',
                'category' => 'sales',
                'icon' => 'file-invoice',
                'is_core' => true,
                'is_active' => true,
                'dependencies' => json_encode(['core_accounting']),
                'permissions' => json_encode([
                    'view_invoices',
                    'create_invoices',
                    'edit_invoices',
                    'delete_invoices',
                    'send_invoices',
                    'record_payments',
                ]),
                'menu_order' => 10,
                'developer' => 'Haasib Team',
                'created_at' => now(),
                'updated_at' => now(),
            ],
            [
                'id' => Str::uuid(),
                'name' => 'Bill Management',
                'key' => 'bill_management',
                'description' => 'Manage vendor bills, expenses, and purchase orders',
                'version' => '1.0.0',
                'category' => 'purchases',
                'icon' => 'file-invoice-dollar',
                'is_core' => true,
                'is_active' => true,
                'dependencies' => json_encode(['core_accounting']),
                'permissions' => json_encode([
                    'view_bills',
                    'create_bills',
                    'edit_bills',
                    'delete_bills',
                    'pay_bills',
                    'manage_vendors',
                ]),
                'menu_order' => 20,
                'developer' => 'Haasib Team',
                'created_at' => now(),
                'updated_at' => now(),
            ],
            [
                'id' => Str::uuid(),
                'name' => 'Banking',
                'key' => 'banking',
                'description' => 'Manage bank accounts, reconcile transactions, and import statements',
                'version' => '1.0.0',
                'category' => 'banking',
                'icon' => 'university',
                'is_core' => true,
                'is_active' => true,
                'dependencies' => json_encode(['core_accounting']),
                'permissions' => json_encode([
                    'view_bank_accounts',
                    'manage_bank_accounts',
                    'reconcile_accounts',
                    'import_transactions',
                ]),
                'menu_order' => 30,
                'developer' => 'Haasib Team',
                'created_at' => now(),
                'updated_at' => now(),
            ],
            [
                'id' => Str::uuid(),
                'name' => 'Reporting Dashboard',
                'key' => 'reporting_dashboard',
                'description' => 'Advanced reporting and analytics dashboard',
                'version' => '1.0.0',
                'category' => 'reporting',
                'icon' => 'chart-line',
                'is_core' => true,
                'is_active' => true,
                'dependencies' => json_encode(['core_accounting']),
                'permissions' => json_encode([
                    'view_dashboard',
                    'export_reports',
                    'schedule_reports',
                ]),
                'menu_order' => 40,
                'developer' => 'Haasib Team',
                'created_at' => now(),
                'updated_at' => now(),
            ],
            [
                'id' => Str::uuid(),
                'name' => 'Multi-Currency',
                'key' => 'multi_currency',
                'description' => 'Handle multiple currencies and automatic exchange rate updates',
                'version' => '1.0.0',
                'category' => 'settings',
                'icon' => 'coins',
                'is_core' => true,
                'is_active' => true,
                'dependencies' => json_encode(['core_accounting']),
                'permissions' => json_encode([
                    'manage_currencies',
                    'update_exchange_rates',
                    'view_currency_reports',
                ]),
                'menu_order' => 50,
                'developer' => 'Haasib Team',
                'created_at' => now(),
                'updated_at' => now(),
            ],
        ]);

        // Create trigger for updated_at
        DB::statement('
            CREATE TRIGGER modules_updated_at
                BEFORE UPDATE ON auth.modules
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger first
        DB::statement('DROP TRIGGER IF EXISTS modules_updated_at ON auth.modules');

        // Drop table
        Schema::dropIfExists('auth.modules');
    }
};

---- File Content End ----


=== File: 2025_10_12_081945_create_customers_table.php ===
Path: 2025_10_12_081945_create_customers_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.customers', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('customer_number')->unique();
            $table->string('name');
            $table->string('email')->nullable();
            $table->string('phone')->nullable();
            $table->text('address')->nullable();
            $table->string('city')->nullable();
            $table->string('state')->nullable();
            $table->string('postal_code')->nullable();
            $table->string('country')->nullable();
            $table->string('tax_id')->nullable();
            $table->string('website')->nullable();
            $table->text('notes')->nullable();
            $table->decimal('credit_limit', 10, 2)->nullable();
            $table->string('payment_terms')->nullable();
            $table->boolean('is_active')->default(true);
            $table->uuid('created_by_user_id')->nullable();
            $table->timestamps();

            // Indexes
            $table->index('company_id');
            $table->index('email');
            $table->index('customer_number');
            $table->index('is_active');
            $table->index(['company_id', 'is_active']);

            // Foreign key constraints
            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('created_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('set null');
        });

        // Add soft deletes
        Schema::table('acct.customers', function (Blueprint $table) {
            $table->softDeletes();
        });

        // Add RLS policies for PostgreSQL
        DB::statement('ALTER TABLE "acct.customers" ENABLE ROW LEVEL SECURITY');

        // Policy: Users can only see customers from their companies
        DB::statement("
            CREATE POLICY customers_select_policy ON \"acct.customers\"
            FOR SELECT
            USING (
                company_id = current_setting('app.current_company_id', true)::uuid
                OR current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company users can insert customers in their company
        DB::statement("
            CREATE POLICY customers_insert_policy ON \"acct.customers\"
            FOR INSERT
            WITH CHECK (
                company_id = current_setting('app.current_company_id', true)::uuid
            );
        ");

        // Policy: Users can update customers from their companies
        DB::statement("
            CREATE POLICY customers_update_policy ON \"acct.customers\"
            FOR UPDATE
            USING (
                company_id = current_setting('app.current_company_id', true)::uuid
            );
        ");

        // Policy: Users can delete customers from their companies
        DB::statement("
            CREATE POLICY customers_delete_policy ON \"acct.customers\"
            FOR DELETE
            USING (
                company_id = current_setting('app.current_company_id', true)::uuid
            );
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop RLS policies
        DB::statement('DROP POLICY IF EXISTS customers_select_policy ON "acct.customers"');
        DB::statement('DROP POLICY IF EXISTS customers_insert_policy ON "acct.customers"');
        DB::statement('DROP POLICY IF EXISTS customers_update_policy ON "acct.customers"');
        DB::statement('DROP POLICY IF EXISTS customers_delete_policy ON "acct.customers"');

        Schema::dropIfExists('acct.customers');
    }
};

---- File Content End ----


=== File: 2025_10_10_122807_fix_sessions_user_id_type.php ===
Path: 2025_10_10_122807_fix_sessions_user_id_type.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Drop existing sessions table
        Schema::dropIfExists('auth.sessions');
        
        // Recreate with UUID user_id
        Schema::create('auth.sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->uuid('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('auth.sessions');
        
        // Recreate original table with foreignId (bigint)
        Schema::create('auth.sessions', function (Blueprint $table) {
            $table->string('id')->primary();
            $table->foreignId('user_id')->nullable()->index();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->longText('payload');
            $table->integer('last_activity')->index();
        });
    }
};

---- File Content End ----


=== File: 2025_10_15_120120_create_customer_groups_tables.php ===
Path: 2025_10_15_120120_create_customer_groups_tables.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Create customer groups table
        Schema::create('acct.customer_groups', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('name', 100);
            $table->text('description')->nullable();
            $table->boolean('is_default')->default(false);
            $table->timestamps();
            $table->timestamp('deleted_at')->nullable();

            // Foreign key
            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            // Indexes
            $table->unique(['company_id', 'name']); // Unique name per company
            $table->index(['company_id', 'is_default']);
        });

        // Enable RLS for customer groups
        DB::statement('ALTER TABLE acct.customer_groups ENABLE ROW LEVEL SECURITY');

        // Create RLS policy for customer groups
        DB::statement('
            CREATE POLICY customer_groups_company_policy 
            ON acct.customer_groups 
            FOR ALL 
            TO authenticated_user 
            USING (company_id = current_setting(\'app.current_company_id\')::uuid)
        ');

        // Create customer group members join table
        Schema::create('acct.customer_group_members', function (Blueprint $table) {
            $table->uuid('customer_id');
            $table->uuid('group_id');
            $table->uuid('company_id');
            $table->timestamp('joined_at')->default(DB::raw('CURRENT_TIMESTAMP'));
            $table->uuid('added_by_user_id')->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('cascade');

            $table->foreign('group_id')
                ->references('id')
                ->on('acct.customer_groups')
                ->onDelete('cascade');

            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('added_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('set null');

            // Primary key and unique constraints
            $table->primary(['customer_id', 'group_id']);
            $table->unique(['customer_id', 'group_id']); // Explicit unique constraint
            $table->index(['group_id', 'company_id']);
            $table->index(['customer_id', 'company_id']);
        });

        // Enable RLS for customer group members
        DB::statement('ALTER TABLE acct.customer_group_members ENABLE ROW LEVEL SECURITY');

        // Create RLS policy for customer group members
        DB::statement('
            CREATE POLICY customer_group_members_company_policy 
            ON acct.customer_group_members 
            FOR ALL 
            TO authenticated_user 
            USING (company_id = current_setting(\'app.current_company_id\')::uuid)
        ');

        // Create audit trigger for customer groups
        DB::statement('
            CREATE OR REPLACE FUNCTION acct.customer_groups_audit_trigger()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = \'INSERT\' THEN
                    PERFORM audit_log(
                        \'customer_group_created\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'company_id\', NEW.company_id,
                            \'name\', NEW.name,
                            \'is_default\', NEW.is_default
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'UPDATE\' THEN
                    PERFORM audit_log(
                        \'customer_group_updated\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'company_id\', NEW.company_id,
                            \'name\', NEW.name,
                            \'old_name\', OLD.name,
                            \'old_description\', OLD.description,
                            \'new_description\', NEW.description
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'DELETE\' THEN
                    PERFORM audit_log(
                        \'customer_group_deleted\',
                        json_build_object(
                            \'id\', OLD.id,
                            \'company_id\', OLD.company_id,
                            \'name\', OLD.name
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN OLD;
                END IF;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        ');

        // Attach the trigger to customer groups
        DB::statement('
            CREATE TRIGGER customer_groups_audit_trigger
            AFTER INSERT OR UPDATE OR DELETE
            ON acct.customer_groups
            FOR EACH ROW EXECUTE FUNCTION acct.customer_groups_audit_trigger()
        ');

        // Create audit trigger for customer group membership changes
        DB::statement('
            CREATE OR REPLACE FUNCTION acct.customer_group_members_audit_trigger()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = \'INSERT\' THEN
                    PERFORM audit_log(
                        \'customer_group_member_added\',
                        json_build_object(
                            \'customer_id\', NEW.customer_id,
                            \'group_id\', NEW.group_id,
                            \'company_id\', NEW.company_id
                        ),
                        NEW.added_by_user_id
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'DELETE\' THEN
                    PERFORM audit_log(
                        \'customer_group_member_removed\',
                        json_build_object(
                            \'customer_id\', OLD.customer_id,
                            \'group_id\', OLD.group_id,
                            \'company_id\', OLD.company_id
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN OLD;
                END IF;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        ');

        // Attach the trigger to customer group members
        DB::statement('
            CREATE TRIGGER customer_group_members_audit_trigger
            AFTER INSERT OR DELETE
            ON acct.customer_group_members
            FOR EACH ROW EXECUTE FUNCTION acct.customer_group_members_audit_trigger()
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop triggers and functions
        DB::statement('DROP TRIGGER IF EXISTS customer_group_members_audit_trigger ON acct.customer_group_members');
        DB::statement('DROP FUNCTION IF EXISTS acct.customer_group_members_audit_trigger()');

        DB::statement('DROP TRIGGER IF EXISTS customer_groups_audit_trigger ON acct.customer_groups');
        DB::statement('DROP FUNCTION IF EXISTS acct.customer_groups_audit_trigger()');

        // Drop RLS policies
        DB::statement('DROP POLICY IF EXISTS customer_group_members_company_policy ON acct.customer_group_members');
        DB::statement('DROP POLICY IF EXISTS customer_groups_company_policy ON acct.customer_groups');

        // Drop tables
        Schema::dropIfExists('acct.customer_group_members');
        Schema::dropIfExists('acct.customer_groups');
    }
};

---- File Content End ----


=== File: 2025_10_15_120310_create_customer_aging_snapshots_table.php ===
Path: 2025_10_15_120310_create_customer_aging_snapshots_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.customer_aging_snapshots', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('customer_id');
            $table->uuid('company_id');
            $table->date('snapshot_date');
            $table->decimal('bucket_current', 15, 2);
            $table->decimal('bucket_1_30', 15, 2);
            $table->decimal('bucket_31_60', 15, 2);
            $table->decimal('bucket_61_90', 15, 2);
            $table->decimal('bucket_90_plus', 15, 2);
            $table->integer('total_invoices');
            $table->enum('generated_via', ['scheduled', 'on_demand']);
            $table->uuid('generated_by_user_id')->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('cascade');

            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('generated_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('set null');

            // Indexes for performance
            $table->index(['customer_id', 'snapshot_date'], 'idx_customer_snapshot_date');
            $table->index(['company_id', 'snapshot_date'], 'idx_company_snapshot_date');
            $table->index(['snapshot_date'], 'idx_snapshot_date');
            $table->index(['generated_via', 'snapshot_date'], 'idx_generated_via_date');

            // Ensure uniqueness: one snapshot per customer per date
            $table->unique(['customer_id', 'snapshot_date'], 'uniq_customer_snapshot_date');
        });

        // Create trigger for audit logging
        $this->createAuditTrigger();

        // Enable Row Level Security
        $this->enableRLS();

        // Create RLS policies
        $this->createRLSPolicies();

        // Create indexes for aging analysis queries
        $this->createAnalysisIndexes();
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('acct.customer_aging_snapshots');
    }

    /**
     * Create audit trigger for customer aging snapshots.
     */
    private function createAuditTrigger(): void
    {
        $trigger = <<<'SQL'
        CREATE OR REPLACE FUNCTION acct.customer_aging_snapshots_audit_trigger()
        RETURNS TRIGGER AS $$
        DECLARE
            audit_action TEXT;
            audit_user UUID;
            details JSONB;
        BEGIN
            -- Determine action
            IF TG_OP = 'INSERT' THEN
                audit_action := 'created';
                audit_user := NEW.generated_by_user_id;
                details := jsonb_build_object(
                    'snapshot_id', NEW.id,
                    'customer_id', NEW.customer_id,
                    'snapshot_date', NEW.snapshot_date,
                    'bucket_current', NEW.bucket_current,
                    'bucket_1_30', NEW.bucket_1_30,
                    'bucket_31_60', NEW.bucket_31_60,
                    'bucket_61_90', NEW.bucket_61_90,
                    'bucket_90_plus', NEW.bucket_90_plus,
                    'total_invoices', NEW.total_invoices,
                    'generated_via', NEW.generated_via,
                    'total_outstanding', NEW.bucket_current + NEW.bucket_1_30 + NEW.bucket_31_60 + NEW.bucket_61_90 + NEW.bucket_90_plus
                );
                INSERT INTO acct.audit_logs (
                    table_name, 
                    record_id, 
                    action, 
                    details, 
                    user_id, 
                    company_id, 
                    created_at
                ) VALUES (
                    'customer_aging_snapshots',
                    NEW.id,
                    audit_action,
                    details,
                    audit_user,
                    NEW.company_id,
                    NOW()
                );
                RETURN NEW;
            
            ELSIF TG_OP = 'UPDATE' THEN
                audit_action := 'updated';
                audit_user := COALESCE(NEW.generated_by_user_id, OLD.generated_by_user_id);
                details := jsonb_build_object(
                    'snapshot_id', NEW.id,
                    'customer_id', NEW.customer_id,
                    'changes', jsonb_build_object(
                        'bucket_current', CASE WHEN OLD.bucket_current IS DISTINCT FROM NEW.bucket_current THEN 
                            jsonb_build_object('old', OLD.bucket_current, 'new', NEW.bucket_current) ELSE NULL END,
                        'bucket_1_30', CASE WHEN OLD.bucket_1_30 IS DISTINCT FROM NEW.bucket_1_30 THEN 
                            jsonb_build_object('old', OLD.bucket_1_30, 'new', NEW.bucket_1_30) ELSE NULL END,
                        'bucket_31_60', CASE WHEN OLD.bucket_31_60 IS DISTINCT FROM NEW.bucket_31_60 THEN 
                            jsonb_build_object('old', OLD.bucket_31_60, 'new', NEW.bucket_31_60) ELSE NULL END,
                        'bucket_61_90', CASE WHEN OLD.bucket_61_90 IS DISTINCT FROM NEW.bucket_61_90 THEN 
                            jsonb_build_object('old', OLD.bucket_61_90, 'new', NEW.bucket_61_90) ELSE NULL END,
                        'bucket_90_plus', CASE WHEN OLD.bucket_90_plus IS DISTINCT FROM NEW.bucket_90_plus THEN 
                            jsonb_build_object('old', OLD.bucket_90_plus, 'new', NEW.bucket_90_plus) ELSE NULL END,
                        'total_invoices', CASE WHEN OLD.total_invoices IS DISTINCT FROM NEW.total_invoices THEN 
                            jsonb_build_object('old', OLD.total_invoices, 'new', NEW.total_invoices) ELSE NULL END
                    )
                );
                INSERT INTO acct.audit_logs (
                    table_name, 
                    record_id, 
                    action, 
                    details, 
                    user_id, 
                    company_id, 
                    created_at
                ) VALUES (
                    'customer_aging_snapshots',
                    NEW.id,
                    audit_action,
                    details,
                    audit_user,
                    NEW.company_id,
                    NOW()
                );
                RETURN NEW;
            
            ELSIF TG_OP = 'DELETE' THEN
                audit_action := 'deleted';
                details := jsonb_build_object(
                    'snapshot_id', OLD.id,
                    'customer_id', OLD.customer_id,
                    'snapshot_date', OLD.snapshot_date,
                    'deleted_data', jsonb_build_object(
                        'bucket_current', OLD.bucket_current,
                        'bucket_1_30', OLD.bucket_1_30,
                        'bucket_31_60', OLD.bucket_31_60,
                        'bucket_61_90', OLD.bucket_61_90,
                        'bucket_90_plus', OLD.bucket_90_plus,
                        'total_invoices', OLD.total_invoices,
                        'generated_via', OLD.generated_via
                    )
                );
                INSERT INTO acct.audit_logs (
                    table_name, 
                    record_id, 
                    action, 
                    details, 
                    user_id, 
                    company_id, 
                    created_at
                ) VALUES (
                    'customer_aging_snapshots',
                    OLD.id,
                    audit_action,
                    details,
                    OLD.generated_by_user_id,
                    OLD.company_id,
                    NOW()
                );
                RETURN OLD;
            END IF;
            
            RETURN NULL;
        END;
        $$ LANGUAGE plpgsql;
        SQL;

        // Create trigger function
        DB::unprepared($trigger);

        // Create trigger
        DB::unprepared('
            CREATE TRIGGER customer_aging_snapshots_audit
                AFTER INSERT OR UPDATE OR DELETE ON acct.customer_aging_snapshots
                FOR EACH ROW EXECUTE FUNCTION acct.customer_aging_snapshots_audit_trigger();
        ');
    }

    /**
     * Enable Row Level Security on customer_aging_snapshots table.
     */
    private function enableRLS(): void
    {
        DB::unprepared('ALTER TABLE acct.customer_aging_snapshots ENABLE ROW LEVEL SECURITY;');
    }

    /**
     * Create Row Level Security policies for customer_aging_snapshots.
     */
    private function createRLSPolicies(): void
    {
        $policies = [
            // Company users can view aging snapshots for their company
            'CREATE POLICY customer_aging_snapshots_view_company ON acct.customer_aging_snapshots
                FOR SELECT USING (
                    company_id = current_setting(\'app.current_company_id\')::uuid
                );',

            // Users with permission can manage aging snapshots
            'CREATE POLICY customer_aging_snapshots_manage ON acct.customer_aging_snapshots
                FOR ALL USING (
                    company_id = current_setting(\'app.current_company_id\')::uuid AND
                    EXISTS (
                        SELECT 1 FROM user_company_permissions ucp
                        WHERE ucp.user_id = current_setting(\'app.current_user_id\')::uuid
                        AND ucp.company_id = current_setting(\'app.current_company_id\')::uuid
                        AND (ucp.permission = \'accounting.customers.generate_statements\' OR ucp.permission = \'accounting.customers.manage_credit\')
                    )
                );',

            // System admins can access all aging snapshots
            'CREATE POLICY customer_aging_snapshots_system_admin ON acct.customer_aging_snapshots
                FOR ALL USING (
                    EXISTS (
                        SELECT 1 FROM users
                        WHERE id = current_setting(\'app.current_user_id\')::uuid
                        AND is_system_admin = true
                    )
                );',
        ];

        foreach ($policies as $policy) {
            DB::unprepared($policy);
        }
    }

    /**
     * Create additional indexes for aging analysis queries.
     */
    private function createAnalysisIndexes(): void
    {
        $indexes = [
            // Index for finding high-risk customers (high 90+ bucket)
            'CREATE INDEX idx_aging_90_plus_risk ON acct.customer_aging_snapshots 
                (company_id, bucket_90_plus DESC NULLS LAST) 
                WHERE bucket_90_plus > 0;',

            // Index for aging trend analysis
            'CREATE INDEX idx_aging_trend_analysis ON acct.customer_aging_snapshots 
                (customer_id, snapshot_date DESC) 
                WHERE snapshot_date >= CURRENT_DATE - INTERVAL \'90 days\';',

            // Index for scheduled vs on-demand comparison
            'CREATE INDEX idx_aging_generation_method ON acct.customer_aging_snapshots 
                (generated_via, snapshot_date DESC);',

            // Partial index for customers with significant outstanding balances
            'CREATE INDEX idx_aging_significant_balance ON acct.customer_aging_snapshots 
                (company_id, (bucket_current + bucket_1_30 + bucket_31_60 + bucket_61_90 + bucket_90_plus) DESC) 
                WHERE (bucket_current + bucket_1_30 + bucket_31_60 + bucket_61_90 + bucket_90_plus) > 1000;',
        ];

        foreach ($indexes as $index) {
            DB::unprepared($index);
        }
    }
};

---- File Content End ----


=== File: 2025_10_05_099999_create_hrm_schema.php ===
Path: 2025_10_05_099999_create_hrm_schema.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Drop all tables in hrm schema to ensure clean state (drop entire schema and recreate)
        DB::statement('DROP SCHEMA IF EXISTS hrm CASCADE');

        // Create hrm schema if it doesn't exist
        DB::statement('CREATE SCHEMA IF NOT EXISTS hrm');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop all tables in hrm schema before dropping schema
        $tables = DB::select("SELECT tablename FROM pg_tables WHERE schemaname = 'hrm'");

        foreach ($tables as $table) {
            Schema::dropIfExists('hrm.'.$table->tablename);
        }

        // Drop the schema
        DB::statement('DROP SCHEMA IF EXISTS hrm CASCADE');
    }
};

---- File Content End ----


=== File: 2025_10_12_062334_add_accountant_role_back_to_rbac_hierarchy.php ===
Path: 2025_10_12_062334_add_accountant_role_back_to_rbac_hierarchy.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Drop existing check constraint
        DB::statement('ALTER TABLE auth.company_user DROP CONSTRAINT IF EXISTS company_user_role_check');

        // Add back accountant role - insert some records for testing if needed
        // For existing managers, we can optionally promote some to accountants based on business logic

        // Add new check constraint with full RBAC hierarchy including accountant
        DB::statement("ALTER TABLE auth.company_user ADD CONSTRAINT company_user_role_check CHECK (role IN ('owner', 'admin', 'manager', 'accountant', 'employee', 'viewer'))");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop existing check constraint
        DB::statement('ALTER TABLE auth.company_user DROP CONSTRAINT IF EXISTS company_user_role_check');

        // Restore previous check constraint without accountant
        DB::statement("ALTER TABLE auth.company_user ADD CONSTRAINT company_user_role_check CHECK (role IN ('owner', 'admin', 'manager', 'employee', 'viewer'))");
    }
};

---- File Content End ----


=== File: 2025_10_13_061039_create_credit_note_items_table.php ===
Path: 2025_10_13_061039_create_credit_note_items_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades.Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.credit_note_items', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('credit_note_id');
            $table->text('description');
            $table->decimal('quantity', 10, 2);
            $table->decimal('unit_price', 15, 2);
            $table->decimal('tax_rate', 5, 2)->default(0);
            $table->decimal('discount_amount', 15, 2)->default(0);
            $table->decimal('total_amount', 15, 2);
            $table->timestamps();

            // Foreign key
            $table->foreign('credit_note_id')->references('id')->on('acct.credit_notes')->onDelete('cascade');

            // Indexes
            $table->index(['credit_note_id']);
        });

        DB::statement('ALTER TABLE acct.credit_note_items ENABLE ROW LEVEL SECURITY');
        DB::statement('
            ALTER TABLE acct.credit_note_items
            ADD CONSTRAINT credit_note_items_amounts_positive
            CHECK (
                quantity >= 0
                AND unit_price >= 0
                AND discount_amount >= 0
                AND total_amount >= 0
            )
        ');
        DB::statement("
            CREATE POLICY credit_note_items_company_policy
            ON acct.credit_note_items
            FOR ALL
            USING (
                EXISTS (
                    SELECT 1
                    FROM acct.credit_notes cn
                    WHERE cn.id = credit_note_id
                      AND cn.company_id = current_setting('app.current_company_id')::uuid
                )
            )
            WITH CHECK (
                EXISTS (
                    SELECT 1
                    FROM acct.credit_notes cn
                    WHERE cn.id = credit_note_id
                      AND cn.company_id = current_setting('app.current_company_id')::uuid
                )
            )
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::statement('DROP POLICY IF EXISTS credit_note_items_company_policy ON acct.credit_note_items');
        DB::statement('ALTER TABLE acct.credit_note_items DISABLE ROW LEVEL SECURITY');
        Schema::dropIfExists('acct.credit_note_items');
    }
};

---- File Content End ----


=== File: 2025_10_05_100000_create_accounting_schema.php ===
Path: 2025_10_05_100000_create_accounting_schema.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Drop all tables in acct schema to ensure clean state (drop entire schema and recreate)
        DB::statement('DROP SCHEMA IF EXISTS acct CASCADE');

        // Create acct schema if it doesn't exist
        DB::statement('CREATE SCHEMA IF NOT EXISTS acct');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop all tables in acct schema before dropping schema
        $tables = DB::select("SELECT tablename FROM pg_tables WHERE schemaname = 'acct'");

        foreach ($tables as $table) {
            Schema::dropIfExists('acct.'.$table->tablename);
        }

        // Drop the schema
        DB::statement('DROP SCHEMA IF EXISTS acct CASCADE');
    }
};

---- File Content End ----


=== File: 2025_10_05_100004_create_company_user_table.php ===
Path: 2025_10_05_100004_create_company_user_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('auth.company_user', function (Blueprint $table) {
            $table->uuid('company_id');
            $table->uuid('user_id');
            $table->string('role')->default('member');
            $table->uuid('invited_by_user_id')->nullable();
            $table->timestamp('joined_at')->nullable();
            $table->timestamp('left_at')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            // Composite primary key
            $table->primary(['company_id', 'user_id']);

            // Indexes
            $table->index(['user_id', 'role']);
            $table->index(['company_id', 'role']);
            $table->index('invited_by_user_id');
            $table->index('is_active');
            $table->index(['company_id', 'user_id', 'is_active']);

            // Foreign key constraints
            $table->foreign('company_id')
                ->references('id')->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('user_id')
                ->references('id')->on('auth.users')
                ->onDelete('cascade');

            $table->foreign('invited_by_user_id')
                ->references('id')->on('auth.users')
                ->onDelete('set null');

            // Add check constraint for valid roles will be added as raw SQL
        });

        // Add check constraint for valid roles
        DB::statement("ALTER TABLE auth.company_user ADD CONSTRAINT company_user_role_check CHECK (role IN ('owner', 'admin', 'accountant', 'viewer', 'member'))");

        // Add RLS policy for company_user table
        DB::statement('
            ALTER TABLE auth.company_user ENABLE ROW LEVEL SECURITY;
        ');

        // Drop existing policies to avoid duplicates
        DB::statement('DROP POLICY IF EXISTS company_user_select_policy ON auth.company_user');
        DB::statement('DROP POLICY IF EXISTS company_user_insert_policy ON auth.company_user');
        DB::statement('DROP POLICY IF EXISTS company_user_update_policy ON auth.company_user');
        DB::statement('DROP POLICY IF EXISTS company_user_delete_policy ON auth.company_user');

        // Policy: Users can see their own company memberships
        DB::statement("
            CREATE POLICY company_user_select_policy ON auth.company_user
            FOR SELECT
            USING (
                user_id = current_setting('app.current_user_id', true)::uuid
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company owners/admins can insert memberships in their company.
        // Allow the creator to seed the first owner record when no privileged members exist yet.
        DB::statement("
            CREATE POLICY company_user_insert_policy ON auth.company_user
            FOR INSERT
            WITH CHECK (
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                (
                    user_id = current_setting('app.current_user_id', true)::uuid
                    AND role = 'owner'
                    AND NOT EXISTS (
                        SELECT 1
                        FROM auth.company_user existing
                        WHERE existing.company_id = company_id
                        AND existing.role IN ('owner', 'admin')
                    )
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company owners/admins can update memberships in their company
        DB::statement("
            CREATE POLICY company_user_update_policy ON auth.company_user
            FOR UPDATE
            USING (
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company owners/admins can delete memberships in their company
        DB::statement("
            CREATE POLICY company_user_delete_policy ON auth.company_user
            FOR DELETE
            USING (
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Create trigger for updated_at
        DB::statement('
            CREATE TRIGGER company_user_updated_at
                BEFORE UPDATE ON auth.company_user
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger first
        DB::statement('DROP TRIGGER IF EXISTS company_user_updated_at ON auth.company_user');

        // Drop table
        Schema::dropIfExists('auth.company_user');
    }
};

---- File Content End ----


=== File: 2025_10_10_144337_create_company_invitations_table.php ===
Path: 2025_10_10_144337_create_company_invitations_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('auth.company_invitations', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('email', 255);
            $table->string('role', 20);
            $table->string('token', 255)->unique();
            $table->uuid('invited_by_user_id');
            $table->uuid('accepted_by_user_id')->nullable();
            $table->string('status', 20)->default('pending');
            $table->timestamp('expires_at');
            $table->timestamp('accepted_at')->nullable();
            $table->timestamps();

            // Foreign key constraints
            $table->foreign('company_id')
                ->references('id')->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('invited_by_user_id')
                ->references('id')->on('auth.users')
                ->onDelete('restrict');

            $table->foreign('accepted_by_user_id')
                ->references('id')->on('auth.users')
                ->onDelete('set null');

            // Indexes
            $table->index('company_id');
            $table->index('email');
            $table->index('token');
            $table->index('status');
            $table->index('expires_at');
            $table->index(['company_id', 'status']);
            $table->index(['email', 'status']);
        });

        // Add check constraints
        DB::statement("
            ALTER TABLE auth.company_invitations 
            ADD CONSTRAINT valid_role 
            CHECK (role IN ('owner', 'admin', 'accountant', 'viewer'))
        ");

        DB::statement("
            ALTER TABLE auth.company_invitations 
            ADD CONSTRAINT valid_status 
            CHECK (status IN ('pending', 'accepted', 'rejected', 'expired'))
        ");

        // Add RLS policy
        DB::statement('
            ALTER TABLE auth.company_invitations ENABLE ROW LEVEL SECURITY;
        ');

        // Policy: Users can see invitations for companies they belong to or invitations sent to them
        DB::statement("
            CREATE POLICY company_invitations_select_policy ON auth.company_invitations
            FOR SELECT
            USING (
                company_id IN (
                    SELECT company_id FROM auth.company_user 
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND is_active = true
                )
                OR
                email = (
                    SELECT email FROM auth.users 
                    WHERE id = current_setting('app.current_user_id', true)::uuid
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company owners/admins can create invitations
        DB::statement("
            CREATE POLICY company_invitations_insert_policy ON auth.company_invitations
            FOR INSERT
            WITH CHECK (
                company_id IN (
                    SELECT company_id FROM auth.company_user 
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                    AND is_active = true
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Users can update their own invitations (accept/reject)
        DB::statement("
            CREATE POLICY company_invitations_update_policy ON auth.company_invitations
            FOR UPDATE
            USING (
                email = (
                    SELECT email FROM auth.users 
                    WHERE id = current_setting('app.current_user_id', true)::uuid
                )
                OR
                company_id IN (
                    SELECT company_id FROM auth.company_user 
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                    AND is_active = true
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company owners/admins can delete invitations
        DB::statement("
            CREATE POLICY company_invitations_delete_policy ON auth.company_invitations
            FOR DELETE
            USING (
                company_id IN (
                    SELECT company_id FROM auth.company_user 
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                    AND is_active = true
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Create trigger for updated_at
        DB::statement('
            CREATE TRIGGER company_invitations_updated_at
                BEFORE UPDATE ON auth.company_invitations
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger first
        DB::statement('DROP TRIGGER IF EXISTS company_invitations_updated_at ON auth.company_invitations');

        // Drop table
        Schema::dropIfExists('auth.company_invitations');
    }
};

---- File Content End ----


=== File: 2025_10_12_055552_update_company_user_roles_to_rbac_hierarchy.php ===
Path: 2025_10_12_055552_update_company_user_roles_to_rbac_hierarchy.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Drop existing check constraint
        DB::statement('ALTER TABLE auth.company_user DROP CONSTRAINT IF EXISTS company_user_role_check');

        // Update existing 'member' roles to 'employee'
        DB::statement("UPDATE auth.company_user SET role = 'employee' WHERE role = 'member'");

        // Update existing 'accountant' roles to 'manager' (since accountant doesn't exist in new hierarchy)
        DB::statement("UPDATE auth.company_user SET role = 'manager' WHERE role = 'accountant'");

        // Add new check constraint with RBAC hierarchy roles
        DB::statement("ALTER TABLE auth.company_user ADD CONSTRAINT company_user_role_check CHECK (role IN ('owner', 'admin', 'manager', 'employee', 'viewer'))");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop existing check constraint
        DB::statement('ALTER TABLE auth.company_user DROP CONSTRAINT IF EXISTS company_user_role_check');

        // Revert 'employee' roles back to 'member'
        DB::statement("UPDATE auth.company_user SET role = 'member' WHERE role = 'employee'");

        // Revert 'manager' roles back to 'accountant'
        DB::statement("UPDATE auth.company_user SET role = 'accountant' WHERE role = 'manager'");

        // Restore old check constraint
        DB::statement("ALTER TABLE auth.company_user ADD CONSTRAINT company_user_role_check CHECK (role IN ('owner', 'admin', 'accountant', 'viewer', 'member'))");
    }
};

---- File Content End ----


=== File: 2025_10_13_061021_create_credit_notes_table.php ===
Path: 2025_10_13_061021_create_credit_notes_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.credit_notes', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->uuid('invoice_id');
            $table->string('credit_note_number', 50);
            $table->text('reason')->nullable();
            $table->decimal('amount', 15, 2);
            $table->decimal('tax_amount', 15, 2)->default(0);
            $table->decimal('total_amount', 15, 2);
            $table->string('currency', 3);
            $table->string('status', 20)->default('draft'); // draft, posted, cancelled
            $table->text('notes')->nullable();
            $table->text('terms')->nullable();
            $table->timestamp('sent_at')->nullable();
            $table->timestamp('posted_at')->nullable();
            $table->timestamp('cancelled_at')->nullable();
            $table->text('cancellation_reason')->nullable();
            $table->uuid('created_by_user_id');
            $table->timestamps();

            // Foreign keys
            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->foreign('invoice_id')->references('id')->on('acct.invoices')->onDelete('cascade');
            $table->foreign('created_by_user_id')->references('id')->on('auth.users')->onDelete('restrict');

            // Indexes
            $table->unique(['company_id', 'credit_note_number']);
            $table->index(['company_id']);
            $table->index(['invoice_id']);
            $table->index(['company_id', 'invoice_id']);
            $table->index(['company_id', 'status']);
            $table->index(['company_id', 'posted_at']);
            $table->index(['company_id', 'created_at']);
        });

        DB::statement('ALTER TABLE acct.credit_notes ENABLE ROW LEVEL SECURITY');
        DB::statement('
            ALTER TABLE acct.credit_notes
            ADD CONSTRAINT credit_notes_amounts_positive
            CHECK (
                amount >= 0
                AND tax_amount >= 0
                AND total_amount >= 0
            )
        ');
        DB::statement("
            CREATE POLICY credit_notes_company_policy
            ON acct.credit_notes
            FOR ALL
            USING (
                company_id = current_setting('app.current_company_id')::uuid
            )
            WITH CHECK (
                company_id = current_setting('app.current_company_id')::uuid
            )
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::statement('DROP POLICY IF EXISTS credit_notes_company_policy ON acct.credit_notes');
        DB::statement('ALTER TABLE acct.credit_notes DISABLE ROW LEVEL SECURITY');
        Schema::dropIfExists('acct.credit_notes');
    }
};

---- File Content End ----


=== File: 2025_10_14_120200_add_command_performance_indexes.php ===
Path: 2025_10_14_120200_add_command_performance_indexes.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('commands', function (Blueprint $table) {
            // Add performance optimization indexes
            $table->index(['company_id', 'category', 'is_active']);
            $table->index(['company_id', 'name', 'is_active']);
            $table->index(['required_permissions']);
            $table->index(['execution_handler']);

            // Add full-text search index for PostgreSQL
            if (DB::connection()->getDriverName() === 'pgsql') {
                DB::statement('CREATE INDEX commands_name_fulltext ON commands USING gin(to_tsvector("english", name))');
                DB::statement('CREATE INDEX commands_description_fulltext ON commands USING gin(to_tsvector("english", description))');
            }
        });

        Schema::table('command_executions', function (Blueprint $table) {
            // Add performance optimization indexes
            $table->index(['company_id', 'executed_at']);
            $table->index(['command_id', 'executed_at']);
            $table->index(['user_id', 'executed_at']);
            $table->index(['status', 'executed_at']);
            $table->index(['execution_time_ms']);
        });

        Schema::table('command_history', function (Blueprint $table) {
            // Add performance optimization indexes
            $table->index(['company_id', 'executed_at']);
            $table->index(['user_id', 'executed_at']);
            $table->index(['execution_status', 'executed_at']);

            // Add full-text search index for PostgreSQL
            if (DB::connection()->getDriverName() === 'pgsql') {
                DB::statement('CREATE INDEX command_history_input_fulltext ON command_history USING gin(to_tsvector("english", input_text))');
                DB::statement('CREATE INDEX command_history_result_fulltext ON command_history USING gin(to_tsvector("english", result_summary))');
            }
        });

        Schema::table('command_templates', function (Blueprint $table) {
            // Add performance optimization indexes
            $table->index(['company_id', 'is_shared']);
            $table->index(['user_id', 'created_at']);
            $table->index(['command_id', 'created_at']);

            // Add full-text search index for PostgreSQL
            if (DB::connection()->getDriverName() === 'pgsql') {
                DB::statement('CREATE INDEX command_templates_name_fulltext ON command_templates USING gin(to_tsvector("english", name))');
                DB::statement('CREATE INDEX command_templates_description_fulltext ON command_templates USING gin(to_tsvector("english", description))');
            }
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('commands', function (Blueprint $table) {
            $table->dropIndex(['company_id', 'category', 'is_active']);
            $table->dropIndex(['company_id', 'name', 'is_active']);
            $table->dropIndex(['required_permissions']);
            $table->dropIndex(['execution_handler']);

            if (DB::connection()->getDriverName() === 'pgsql') {
                $table->raw('DROP INDEX IF EXISTS commands_name_fulltext');
                $table->raw('DROP INDEX IF EXISTS commands_description_fulltext');
            }
        });

        Schema::table('command_executions', function (Blueprint $table) {
            $table->dropIndex(['company_id', 'executed_at']);
            $table->dropIndex(['command_id', 'executed_at']);
            $table->dropIndex(['user_id', 'executed_at']);
            $table->dropIndex(['status', 'executed_at']);
            $table->dropIndex(['execution_time_ms']);
        });

        Schema::table('command_history', function (Blueprint $table) {
            $table->dropIndex(['company_id', 'executed_at']);
            $table->dropIndex(['user_id', 'executed_at']);
            $table->dropIndex(['execution_status', 'executed_at']);

            if (DB::connection()->getDriverName() === 'pgsql') {
                $table->raw('DROP INDEX IF EXISTS command_history_input_fulltext');
                $table->raw('DROP INDEX IF EXISTS command_history_result_fulltext');
            }
        });

        Schema::table('command_templates', function (Blueprint $table) {
            $table->dropIndex(['company_id', 'is_shared']);
            $table->dropIndex(['user_id', 'created_at']);
            $table->dropIndex(['command_id', 'created_at']);

            if (DB::connection()->getDriverName() === 'pgsql') {
                $table->raw('DROP INDEX IF EXISTS command_templates_name_fulltext');
                $table->raw('DROP INDEX IF EXISTS command_templates_description_fulltext');
            }
        });
    }
};

---- File Content End ----


=== File: 2025_10_15_120110_create_customer_addresses_table.php ===
Path: 2025_10_15_120110_create_customer_addresses_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.customer_addresses', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('customer_id');
            $table->uuid('company_id');
            $table->string('label', 100);
            $table->enum('type', ['billing', 'shipping', 'statement', 'other']);
            $table->string('line1', 255);
            $table->string('line2', 255)->nullable();
            $table->string('city', 100)->nullable();
            $table->string('state', 100)->nullable();
            $table->string('postal_code', 30)->nullable();
            $table->char('country', 2);
            $table->boolean('is_default')->default(false);
            $table->text('notes')->nullable();
            $table->timestamps();
            $table->timestamp('deleted_at')->nullable();

            // Foreign keys
            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('cascade');

            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            // Indexes
            $table->index(['customer_id', 'company_id']);
            $table->index(['company_id', 'type']);
            $table->index(['company_id', 'country']);
            $table->index(['customer_id', 'type', 'is_default']);
        });

        // Enable RLS (Row Level Security)
        DB::statement('ALTER TABLE acct.customer_addresses ENABLE ROW LEVEL SECURITY');

        // Create RLS policy to enforce tenancy
        DB::statement('
            CREATE POLICY customer_addresses_company_policy 
            ON acct.customer_addresses 
            FOR ALL 
            TO authenticated_user 
            USING (company_id = current_setting(\'app.current_company_id\')::uuid)
        ');

        // Create partial unique index for single default address per type per customer
        DB::statement('
            CREATE UNIQUE INDEX customer_addresses_default_unique 
            ON acct.customer_addresses (customer_id, type) 
            WHERE is_default = true AND deleted_at IS NULL
        ');

        // Create audit trigger for address changes
        DB::statement('
            CREATE OR REPLACE FUNCTION acct.customer_addresses_audit_trigger()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = \'INSERT\' THEN
                    PERFORM audit_log(
                        \'customer_address_created\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'customer_id\', NEW.customer_id,
                            \'company_id\', NEW.company_id,
                            \'type\', NEW.type,
                            \'country\', NEW.country,
                            \'is_default\', NEW.is_default
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'UPDATE\' THEN
                    PERFORM audit_log(
                        \'customer_address_updated\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'customer_id\', NEW.customer_id,
                            \'company_id\', NEW.company_id,
                            \'type\', NEW.type,
                            \'old_is_default\', OLD.is_default,
                            \'new_is_default\', NEW.is_default,
                            \'old_country\', OLD.country,
                            \'new_country\', NEW.country
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'DELETE\' THEN
                    PERFORM audit_log(
                        \'customer_address_deleted\',
                        json_build_object(
                            \'id\', OLD.id,
                            \'customer_id\', OLD.customer_id,
                            \'company_id\', OLD.company_id,
                            \'type\', OLD.type,
                            \'country\', OLD.country
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN OLD;
                END IF;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        ');

        // Attach the trigger
        DB::statement('
            CREATE TRIGGER customer_addresses_audit_trigger
            AFTER INSERT OR UPDATE OR DELETE
            ON acct.customer_addresses
            FOR EACH ROW EXECUTE FUNCTION acct.customer_addresses_audit_trigger()
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger and function
        DB::statement('DROP TRIGGER IF EXISTS customer_addresses_audit_trigger ON acct.customer_addresses');
        DB::statement('DROP FUNCTION IF EXISTS acct.customer_addresses_audit_trigger()');

        // Drop RLS policy
        DB::statement('DROP POLICY IF EXISTS customer_addresses_company_policy ON acct.customer_addresses');

        // Drop indexes
        DB::statement('DROP INDEX IF EXISTS customer_addresses_default_unique');

        Schema::dropIfExists('acct.customer_addresses');
    }
};

---- File Content End ----


=== File: 2025_10_13_165756_create_command_templates_table.php ===
Path: 2025_10_13_165756_create_command_templates_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('command_templates', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('command_id');
            $table->uuid('user_id');
            $table->uuid('company_id');
            $table->string('name');
            $table->json('parameter_values');
            $table->boolean('is_shared')->default(false);
            $table->timestamps();

            $table->foreign('command_id')->references('id')->on('commands')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('auth.users')->onDelete('cascade');
            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->index(['command_id', 'is_shared']);
            $table->index(['user_id', 'is_shared']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('command_templates');
    }
};

---- File Content End ----


=== File: 2025_10_05_100007_create_audit_entries_table.php ===
Path: 2025_10_05_100007_create_audit_entries_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('auth.audit_entries', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('action', 50)->comment('created, updated, deleted, etc.');
            $table->string('entity_type', 100)->comment('Model or table name');
            $table->uuid('entity_id')->nullable()->comment('ID of the entity being audited');
            $table->uuid('user_id')->nullable();
            $table->uuid('company_id')->nullable();
            $table->json('old_values')->nullable();
            $table->json('new_values')->nullable();
            $table->string('ip_address', 45)->nullable();
            $table->text('user_agent')->nullable();
            $table->string('device_type', 20)->nullable();
            $table->json('location')->nullable()->comment('Geolocation data');
            $table->json('metadata')->nullable()->comment('Additional audit data');
            $table->boolean('is_system_action')->default(false);
            $table->timestamps();

            // Indexes for efficient querying
            $table->index(['entity_type', 'entity_id']);
            $table->index('user_id');
            $table->index('company_id');
            $table->index('action');
            $table->index('is_system_action');
            $table->index('created_at');
            $table->index(['created_at', 'action']);
            $table->index(['user_id', 'created_at']);
            $table->index(['company_id', 'created_at']);
            $table->index(['entity_type', 'created_at']);

            // Foreign key constraints
            $table->foreign('user_id')
                ->references('id')->on('auth.users')
                ->onDelete('set null');

            $table->foreign('company_id')
                ->references('id')->on('auth.companies')
                ->onDelete('set null');
        });

        // Add RLS policy for audit_entries table
        DB::statement('
            ALTER TABLE auth.audit_entries ENABLE ROW LEVEL SECURITY;
        ');

        // Policy: Users can see audit entries for their own actions or entries related to their companies
        DB::statement("
            CREATE POLICY audit_entries_select_policy ON auth.audit_entries
            FOR SELECT
            USING (
                user_id = current_setting('app.current_user_id', true)::uuid
                OR
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Create trigger for updated_at
        DB::statement('
            CREATE TRIGGER audit_entries_updated_at
                BEFORE UPDATE ON auth.audit_entries
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');

        // Create function to automatically log changes
        DB::statement("
            CREATE OR REPLACE FUNCTION auth.audit_trigger()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = 'INSERT' THEN
                    INSERT INTO auth.audit_entries (
                        action,
                        entity_type,
                        entity_id,
                        user_id,
                        company_id,
                        new_values,
                        ip_address,
                        user_agent,
                        is_system_action
                    ) VALUES (
                        'created',
                        TG_TABLE_NAME,
                        NEW.id,
                        current_setting('app.current_user_id', true)::uuid,
                        current_setting('app.current_company_id', true)::uuid,
                        row_to_json(NEW),
                        current_setting('app.ip_address', true),
                        current_setting('app.user_agent', true),
                        false
                    );
                    RETURN NEW;
                ELSIF TG_OP = 'UPDATE' THEN
                    -- Only log if there are actual changes to important fields
                    IF NEW IS DISTINCT FROM OLD THEN
                        INSERT INTO auth.audit_entries (
                            action,
                            entity_type,
                            entity_id,
                            user_id,
                            company_id,
                            old_values,
                            new_values,
                            ip_address,
                            user_agent,
                            is_system_action
                        ) VALUES (
                            'updated',
                            TG_TABLE_NAME,
                            NEW.id,
                            current_setting('app.current_user_id', true)::uuid,
                            current_setting('app.current_company_id', true)::uuid,
                            row_to_json(OLD),
                            row_to_json(NEW),
                            current_setting('app.ip_address', true),
                            current_setting('app.user_agent', true),
                            false
                        );
                    END IF;
                    RETURN NEW;
                ELSIF TG_OP = 'DELETE' THEN
                    INSERT INTO auth.audit_entries (
                        action,
                        entity_type,
                        entity_id,
                        user_id,
                        company_id,
                        old_values,
                        ip_address,
                        user_agent,
                        is_system_action
                    ) VALUES (
                        'deleted',
                        TG_TABLE_NAME,
                        OLD.id,
                        current_setting('app.current_user_id', true)::uuid,
                        current_setting('app.current_company_id', true)::uuid,
                        row_to_json(OLD),
                        current_setting('app.ip_address', true),
                        current_setting('app.user_agent', true),
                        false
                    );
                    RETURN OLD;
                END IF;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        ");

        DB::statement("
            CREATE OR REPLACE FUNCTION audit_log(
                p_action TEXT,
                p_payload JSONB,
                p_user_id UUID DEFAULT NULL,
                p_entity_type TEXT DEFAULT NULL,
                p_entity_id UUID DEFAULT NULL,
                p_company_id UUID DEFAULT NULL
            ) RETURNS VOID AS $$
            DECLARE
                v_user_id UUID := p_user_id;
                v_company_id UUID := p_company_id;
                v_ip_address TEXT := NULL;
                v_user_agent TEXT := NULL;
            BEGIN
                BEGIN
                    IF v_user_id IS NULL THEN
                        v_user_id := current_setting('app.current_user_id', true)::uuid;
                    END IF;
                EXCEPTION WHEN others THEN
                    -- leave NULL if context not set
                    v_user_id := p_user_id;
                END;

                BEGIN
                    IF v_company_id IS NULL THEN
                        v_company_id := current_setting('app.current_company_id', true)::uuid;
                    END IF;
                EXCEPTION WHEN others THEN
                    v_company_id := p_company_id;
                END;

                BEGIN
                    v_ip_address := current_setting('app.ip_address', true);
                EXCEPTION WHEN others THEN
                    v_ip_address := NULL;
                END;

                BEGIN
                    v_user_agent := current_setting('app.user_agent', true);
                EXCEPTION WHEN others THEN
                    v_user_agent := NULL;
                END;

                INSERT INTO auth.audit_entries (
                    action,
                    entity_type,
                    entity_id,
                    user_id,
                    company_id,
                    new_values,
                    metadata,
                    ip_address,
                    user_agent,
                    is_system_action,
                    created_at,
                    updated_at
                ) VALUES (
                    p_action,
                    COALESCE(p_entity_type, 'system.event'),
                    p_entity_id,
                    v_user_id,
                    v_company_id,
                    p_payload,
                    NULL,
                    v_ip_address,
                    v_user_agent,
                    false,
                    NOW(),
                    NOW()
                );
            END;
            $$ LANGUAGE plpgsql SECURITY DEFINER;
        ");
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger and function first
        DB::statement('DROP TRIGGER IF EXISTS audit_entries_updated_at ON auth.audit_entries');
        DB::statement('DROP FUNCTION IF EXISTS auth.audit_trigger()');
        DB::statement('DROP FUNCTION IF EXISTS audit_log(text, jsonb, uuid, text, uuid, uuid)');

        // Drop table
        Schema::dropIfExists('auth.audit_entries');
    }
};

---- File Content End ----


=== File: 2025_10_13_061231_create_invoices_table.php ===
Path: 2025_10_13_061231_create_invoices_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades.DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.invoices', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->uuid('customer_id');
            $table->string('invoice_number', 50);
            $table->string('order_number', 50)->nullable();
            $table->date('issue_date');
            $table->date('due_date');
            $table->string('status', 20)->default('draft'); // draft, sent, posted, paid, cancelled
            $table->string('payment_status', 20)->default('unpaid'); // unpaid, partially_paid, paid, overdue
            $table->string('currency', 3);
            $table->decimal('subtotal', 15, 2)->default(0);
            $table->decimal('tax_amount', 15, 2)->default(0);
            $table->decimal('discount_amount', 15, 2)->default(0);
            $table->decimal('total_amount', 15, 2)->default(0);
            $table->decimal('balance_due', 15, 2)->default(0);
            $table->text('notes')->nullable();
            $table->text('terms')->nullable();
            $table->timestamp('sent_at')->nullable();
            $table->timestamp('paid_at')->nullable();
            $table->timestamp('overdue_at')->nullable();
            $table->uuid('created_by_user_id');
            $table->timestamps();

            // Foreign keys
            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->foreign('customer_id')->references('id')->on('acct.customers')->onDelete('cascade');
            $table->foreign('created_by_user_id')->references('id')->on('auth.users')->onDelete('restrict');

            // Indexes
            $table->unique(['company_id', 'invoice_number']);
            $table->index(['company_id']);
            $table->index(['customer_id']);
            $table->index(['company_id', 'customer_id']);
            $table->index(['company_id', 'status']);
            $table->index(['company_id', 'payment_status']);
            $table->index(['company_id', 'due_date']);
            $table->index(['company_id', 'created_at']);
        });

        // Add soft deletes
        Schema::table('acct.invoices', function (Blueprint $table) {
            $table->softDeletes();
        });

        DB::statement('
            ALTER TABLE acct.invoices
            ADD CONSTRAINT invoices_amounts_positive
            CHECK (
                subtotal >= 0
                AND tax_amount >= 0
                AND discount_amount >= 0
                AND total_amount >= 0
                AND balance_due >= 0
            )
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('acct.invoices');
    }
};

---- File Content End ----


=== File: 2025_10_11_071143_add_currency_and_timezone_to_companies_table.php ===
Path: 2025_10_11_071143_add_currency_and_timezone_to_companies_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::table('auth.companies', function (Blueprint $table) {
            $table->string('currency', 3)->default('USD')->after('slug');
            $table->string('timezone')->default('UTC')->after('currency');
            
            // Add indexes for performance
            $table->index('currency');
            $table->index('timezone');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::table('auth.companies', function (Blueprint $table) {
            $table->dropIndex(['currency']);
            $table->dropIndex(['timezone']);
            $table->dropColumn(['currency', 'timezone']);
        });
    }
};

---- File Content End ----


=== File: 2025_10_10_060928_create_cache_table.php ===
Path: 2025_10_10_060928_create_cache_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('cache', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->mediumText('value');
            $table->integer('expiration');
        });

        Schema::create('cache_locks', function (Blueprint $table) {
            $table->string('key')->primary();
            $table->string('owner');
            $table->integer('expiration');
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('cache');
        Schema::dropIfExists('cache_locks');
    }
};

---- File Content End ----


=== File: 2025_10_05_100008_create_uuid_helper_function.php ===
Path: 2025_10_05_100008_create_uuid_helper_function.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Enable pgcrypto extension if not already enabled
        DB::statement('CREATE EXTENSION IF NOT EXISTS pgcrypto');

        // Create a helper function for UUID generation
        DB::statement('
            CREATE OR REPLACE FUNCTION generate_uuid()
            RETURNS UUID AS $$
            BEGIN
                RETURN gen_random_uuid();
            END;
            $$ LANGUAGE plpgsql;
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        DB::statement('DROP FUNCTION IF EXISTS generate_uuid()');
    }
};

---- File Content End ----


=== File: 2025_10_13_165756_create_command_history_table.php ===
Path: 2025_10_13_165756_create_command_history_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('command_history', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('user_id');
            $table->uuid('command_id');
            $table->uuid('company_id');
            $table->timestamp('executed_at');
            $table->text('input_text');
            $table->json('parameters_used');
            $table->enum('execution_status', ['success', 'failed', 'partial']);
            $table->text('result_summary')->nullable();
            $table->uuid('audit_reference')->nullable();
            $table->timestamps();

            $table->foreign('command_id')->references('id')->on('commands')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('auth.users')->onDelete('cascade');
            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->index(['user_id', 'executed_at']);
            $table->index(['command_id', 'executed_at']);
            $table->index(['company_id', 'executed_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('command_history');
    }
};

---- File Content End ----


=== File: 2025_10_20_000000_create_journal_foundation_tables.php ===
Path: 2025_10_20_000000_create_journal_foundation_tables.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Create journal batches table
        Schema::create('acct.journal_batches', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('batch_number', 20);
            $table->enum('status', ['draft', 'ready', 'scheduled', 'posted', 'void'])->default('draft');
            $table->timestamp('scheduled_post_at')->nullable();
            $table->integer('total_entries')->default(0);
            $table->decimal('total_debits', 20, 2)->default(0);
            $table->decimal('total_credits', 20, 2)->default(0);
            $table->uuid('created_by');
            $table->uuid('approved_by')->nullable();
            $table->timestamp('approved_at')->nullable();
            $table->uuid('posted_by')->nullable();
            $table->timestamp('posted_at')->nullable();
            $table->uuid('voided_by')->nullable();
            $table->timestamp('voided_at')->nullable();
            $table->text('void_reason')->nullable();
            $table->jsonb('attachments')->nullable();
            $table->jsonb('metadata')->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('company_id')->references('id')->on('auth.companies');
            $table->foreign('created_by')->references('id')->on('auth.users');
            $table->foreign('approved_by')->references('id')->on('auth.users');
            $table->foreign('posted_by')->references('id')->on('auth.users');
            $table->foreign('voided_by')->references('id')->on('auth.users');

            // Indexes
            $table->unique(['company_id', 'batch_number']);
            $table->index(['company_id', 'status', 'scheduled_post_at']);
            $table->index(['company_id'])->where('status', '=', 'ready');
        });

        DB::statement("
            ALTER TABLE acct.journal_batches
            ADD CONSTRAINT journal_batches_balanced
            CHECK (
                status != 'posted' OR total_debits = total_credits
            )
        ");

        // Create recurring journal templates table
        Schema::create('acct.recurring_journal_templates', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('name', 150);
            $table->text('description')->nullable();
            $table->enum('frequency', ['daily', 'weekly', 'monthly', 'quarterly', 'annually', 'custom']);
            $table->string('custom_cron', 100)->nullable();
            $table->timestamp('next_run_at');
            $table->timestamp('last_run_at')->nullable();
            $table->boolean('auto_post')->default(false);
            $table->boolean('active')->default(true);
            $table->uuid('created_by');
            $table->jsonb('metadata')->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('company_id')->references('id')->on('auth.companies');
            $table->foreign('created_by')->references('id')->on('auth.users');

            // Indexes
            $table->unique(['company_id', 'name']);
            $table->index(['active', 'next_run_at']);
        });

        // Create recurring journal template lines table
        Schema::create('acct.recurring_journal_template_lines', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('template_id');
            $table->integer('line_number');
            $table->uuid('account_id');
            $table->enum('debit_credit', ['debit', 'credit']);
            $table->string('amount_formula', 255);
            $table->text('description')->nullable();
            $table->jsonb('metadata')->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('template_id')->references('id')->on('acct.recurring_journal_templates')->onDelete('cascade');
            $table->foreign('account_id')->references('id')->on('acct.accounts');

            // Indexes
            $table->unique(['template_id', 'line_number']);
        });

        // Create journal entry sources table
        Schema::create('acct.journal_entry_sources', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('journal_entry_id');
            $table->uuid('journal_transaction_id')->nullable();
            $table->string('source_type', 100);
            $table->uuid('source_id');
            $table->string('source_reference', 150)->nullable();
            $table->enum('link_type', ['origin', 'supporting', 'reversal']);
            $table->timestamp('created_at');

            // Foreign keys
            $table->foreign('journal_entry_id')->references('id')->on('acct.journal_entries')->onDelete('cascade');
            $table->foreign('journal_transaction_id')->references('id')->on('acct.journal_transactions')->onDelete('cascade');

            // Indexes
            $table->unique(['journal_entry_id', 'source_type', 'source_id']);
            $table->index(['source_type', 'source_id']);
        });

        // Create journal audit log table
        Schema::create('acct.journal_audit_log', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('journal_entry_id');
            $table->enum('event_type', ['created', 'updated', 'posted', 'voided', 'approved', 'reversed', 'attachment_added']);
            $table->uuid('actor_id')->nullable();
            $table->jsonb('payload');
            $table->timestamp('created_at');

            // Foreign keys
            $table->foreign('journal_entry_id')->references('id')->on('acct.journal_entries')->onDelete('cascade');
            $table->foreign('actor_id')->references('id')->on('auth.users');

            // Indexes
            $table->index(['journal_entry_id', 'created_at']);
        });

        // Create triggers for updated_at fields
        DB::statement('
            CREATE TRIGGER journal_batches_updated_at
                BEFORE UPDATE ON acct.journal_batches
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');

        DB::statement('
            CREATE TRIGGER recurring_journal_templates_updated_at
                BEFORE UPDATE ON acct.recurring_journal_templates
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');

        DB::statement('
            CREATE TRIGGER recurring_journal_template_lines_updated_at
                BEFORE UPDATE ON acct.recurring_journal_template_lines
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop triggers first
        DB::statement('DROP TRIGGER IF EXISTS journal_batches_updated_at ON acct.journal_batches');
        DB::statement('DROP TRIGGER IF EXISTS recurring_journal_templates_updated_at ON acct.recurring_journal_templates');
        DB::statement('DROP TRIGGER IF EXISTS recurring_journal_template_lines_updated_at ON acct.recurring_journal_template_lines');

        // Drop tables
        Schema::dropIfExists('acct.journal_audit_log');
        Schema::dropIfExists('acct.journal_entry_sources');
        Schema::dropIfExists('acct.recurring_journal_template_lines');
        Schema::dropIfExists('acct.recurring_journal_templates');
        Schema::dropIfExists('acct.journal_batches');
    }
};

---- File Content End ----


=== File: 2025_10_13_165755_create_command_executions_table.php ===
Path: 2025_10_13_165755_create_command_executions_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('command_executions', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('command_id');
            $table->uuid('user_id');
            $table->uuid('company_id');
            $table->string('idempotency_key');
            $table->enum('status', ['pending', 'running', 'completed', 'failed']);
            $table->timestamp('started_at')->nullable();
            $table->timestamp('completed_at')->nullable();
            $table->json('parameters');
            $table->json('result')->nullable();
            $table->text('error_message')->nullable();
            $table->uuid('audit_reference')->nullable();
            $table->timestamps();

            $table->foreign('command_id')->references('id')->on('commands')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('auth.users')->onDelete('cascade');
            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->index(['command_id', 'status']);
            $table->index(['user_id', 'status']);
            $table->index('idempotency_key');
            $table->unique(['company_id', 'idempotency_key']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('command_executions');
    }
};

---- File Content End ----


=== File: 2025_10_15_120100_create_customer_contacts_table.php ===
Path: 2025_10_15_120100_create_customer_contacts_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.customer_contacts', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('customer_id');
            $table->uuid('company_id');
            $table->string('first_name', 100);
            $table->string('last_name', 100);
            $table->string('email', 255);
            $table->string('phone', 50)->nullable();
            $table->string('role', 100);
            $table->boolean('is_primary')->default(false);
            $table->enum('preferred_channel', ['email', 'phone', 'sms', 'portal'])->default('email');
            $table->uuid('created_by_user_id')->nullable();
            $table->timestamps();
            $table->timestamp('deleted_at')->nullable();

            // Foreign keys
            $table->foreign('customer_id')
                ->references('id')
                ->on('acct.customers')
                ->onDelete('cascade');

            $table->foreign('company_id')
                ->references('id')
                ->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('created_by_user_id')
                ->references('id')
                ->on('auth.users')
                ->onDelete('set null');

            // Indexes
            $table->index(['customer_id', 'company_id']);
            $table->index(['company_id', 'role']);
            $table->index(['company_id', 'email']);
            $table->unique(['customer_id', 'email']); // Unique email per customer
        });

        // Enable RLS (Row Level Security)
        DB::statement('ALTER TABLE acct.customer_contacts ENABLE ROW LEVEL SECURITY');

        // Create RLS policy to enforce tenancy
        DB::statement('
            CREATE POLICY customer_contacts_company_policy 
            ON acct.customer_contacts 
            FOR ALL 
            TO authenticated_user 
            USING (company_id = current_setting(\'app.current_company_id\')::uuid)
        ');

        // Create partial unique index for single primary contact per role per customer
        DB::statement('
            CREATE UNIQUE INDEX customer_contacts_primary_unique 
            ON acct.customer_contacts (customer_id, role) 
            WHERE is_primary = true AND deleted_at IS NULL
        ');

        // Create audit trigger for contact changes
        DB::statement('
            CREATE OR REPLACE FUNCTION acct.customer_contacts_audit_trigger()
            RETURNS TRIGGER AS $$
            BEGIN
                IF TG_OP = \'INSERT\' THEN
                    PERFORM audit_log(
                        \'customer_contact_created\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'customer_id\', NEW.customer_id,
                            \'company_id\', NEW.company_id,
                            \'email\', NEW.email,
                            \'role\', NEW.role,
                            \'is_primary\', NEW.is_primary
                        ),
                        NEW.created_by_user_id
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'UPDATE\' THEN
                    PERFORM audit_log(
                        \'customer_contact_updated\',
                        json_build_object(
                            \'id\', NEW.id,
                            \'customer_id\', NEW.customer_id,
                            \'company_id\', NEW.company_id,
                            \'old_email\', OLD.email,
                            \'new_email\', NEW.email,
                            \'old_role\', OLD.role,
                            \'new_role\', NEW.role,
                            \'old_is_primary\', OLD.is_primary,
                            \'new_is_primary\', NEW.is_primary
                        ),
                        COALESCE(current_setting(\'app.current_user_id\', true)::uuid, NEW.created_by_user_id)
                    );
                    RETURN NEW;
                ELSIF TG_OP = \'DELETE\' THEN
                    PERFORM audit_log(
                        \'customer_contact_deleted\',
                        json_build_object(
                            \'id\', OLD.id,
                            \'customer_id\', OLD.customer_id,
                            \'company_id\', OLD.company_id,
                            \'email\', OLD.email,
                            \'role\', OLD.role
                        ),
                        current_setting(\'app.current_user_id\', true)::uuid
                    );
                    RETURN OLD;
                END IF;
                RETURN NULL;
            END;
            $$ LANGUAGE plpgsql;
        ');

        // Attach the trigger
        DB::statement('
            CREATE TRIGGER customer_contacts_audit_trigger
            AFTER INSERT OR UPDATE OR DELETE
            ON acct.customer_contacts
            FOR EACH ROW EXECUTE FUNCTION acct.customer_contacts_audit_trigger()
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger and function
        DB::statement('DROP TRIGGER IF EXISTS customer_contacts_audit_trigger ON acct.customer_contacts');
        DB::statement('DROP FUNCTION IF EXISTS acct.customer_contacts_audit_trigger()');

        // Drop RLS policy
        DB::statement('DROP POLICY IF EXISTS customer_contacts_company_policy ON acct.customer_contacts');

        // Drop indexes
        DB::statement('DROP INDEX IF EXISTS customer_contacts_primary_unique');

        Schema::dropIfExists('acct.customer_contacts');
    }
};

---- File Content End ----


=== File: 2025_10_10_110726_create_telescope_entries_table.php ===
Path: 2025_10_10_110726_create_telescope_entries_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Get the migration connection name.
     */
    public function getConnection(): ?string
    {
        return config('telescope.storage.database.connection');
    }

    /**
     * Run the migrations.
     */
    public function up(): void
    {
        $schema = Schema::connection($this->getConnection());

        $schema->create('telescope_entries', function (Blueprint $table) {
            $table->bigIncrements('sequence');
            $table->uuid('uuid');
            $table->uuid('batch_id');
            $table->string('family_hash')->nullable();
            $table->boolean('should_display_on_index')->default(true);
            $table->string('type', 20);
            $table->longText('content');
            $table->dateTime('created_at')->nullable();

            $table->unique('uuid');
            $table->index('batch_id');
            $table->index('family_hash');
            $table->index('created_at');
            $table->index(['type', 'should_display_on_index']);
        });

        $schema->create('telescope_entries_tags', function (Blueprint $table) {
            $table->uuid('entry_uuid');
            $table->string('tag');

            $table->primary(['entry_uuid', 'tag']);
            $table->index('tag');

            $table->foreign('entry_uuid')
                ->references('uuid')
                ->on('telescope_entries')
                ->onDelete('cascade');
        });

        $schema->create('telescope_monitoring', function (Blueprint $table) {
            $table->string('tag')->primary();
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        $schema = Schema::connection($this->getConnection());

        $schema->dropIfExists('telescope_entries_tags');
        $schema->dropIfExists('telescope_entries');
        $schema->dropIfExists('telescope_monitoring');
    }
};

---- File Content End ----


=== File: 2025_10_14_120100_create_command_analytics_table.php ===
Path: 2025_10_14_120100_create_command_analytics_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('command_analytics', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->uuid('command_id');
            $table->uuid('user_id')->nullable();
            $table->string('environment');
            $table->timestamp('executed_at');
            $table->string('execution_status'); // success, failure, timeout
            $table->integer('execution_time_ms')->nullable();
            $table->json('parameters_used')->nullable();
            $table->text('error_message')->nullable();
            $table->string('ip_address', 45)->nullable();
            $table->string('user_agent')->nullable();
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->foreign('command_id')->references('id')->on('commands')->onDelete('cascade');
            $table->foreign('user_id')->references('id')->on('auth.users')->onDelete('set null');

            $table->index(['company_id', 'command_id', 'executed_at']);
            $table->index(['company_id', 'user_id', 'executed_at']);
            $table->index(['environment', 'executed_at']);
            $table->index(['execution_status', 'executed_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('command_analytics');
    }
};

---- File Content End ----


=== File: 2025_10_05_100003_create_companies_table.php ===
Path: 2025_10_05_100003_create_companies_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('auth.companies', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->string('name');
            $table->string('industry')->nullable();
            $table->string('slug')->unique();
            $table->string('country')->nullable();
            $table->uuid('country_id')->nullable();
            $table->string('base_currency', 3)->default('USD');
            $table->uuid('currency_id')->nullable();
            $table->unsignedBigInteger('exchange_rate_id')->nullable();
            $table->string('language', 10)->default('en');
            $table->string('locale', 10)->default('en_US');
            $table->json('settings')->nullable();
            $table->uuid('created_by_user_id')->nullable();
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            // Indexes
            $table->index('slug');
            $table->index('country');
            $table->index('industry');
            $table->index('base_currency');
            $table->index('currency_id');
            $table->index('exchange_rate_id');
            $table->index('is_active');
            $table->index(['is_active', 'country']);
            $table->unique(['name', 'country']);

            // Foreign key constraints added after table creation
        });

        // Add foreign key constraint after table creation
        Schema::table('auth.companies', function (Blueprint $table) {
            $table->foreign('created_by_user_id')
                ->references('id')->on('auth.users')
                ->onDelete('set null');
        });

        // Add RLS policy for companies table
        DB::statement('
            ALTER TABLE auth.companies ENABLE ROW LEVEL SECURITY;
        ');

        // Policy: Only superadmins can see companies initially (will be updated after company_user table exists)
        DB::statement("
            CREATE POLICY companies_select_policy ON auth.companies
            FOR SELECT
            USING (
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Only superadmins can update companies initially (will be updated after company_user table exists)
        DB::statement("
            CREATE POLICY companies_update_policy ON auth.companies
            FOR UPDATE
            USING (
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Users can insert companies (will be filtered at application level)
        DB::statement('
            CREATE POLICY companies_insert_policy ON auth.companies
            FOR INSERT
            WITH CHECK (true);
        ');

        // Create trigger for updated_at
        DB::statement('
            CREATE TRIGGER companies_updated_at
                BEFORE UPDATE ON auth.companies
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger first
        DB::statement('DROP TRIGGER IF EXISTS companies_updated_at ON auth.companies');

        // Drop table
        Schema::dropIfExists('auth.companies');
    }
};

---- File Content End ----


=== File: 2025_10_05_100006_create_company_modules_table.php ===
Path: 2025_10_05_100006_create_company_modules_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        DB::statement('CREATE EXTENSION IF NOT EXISTS pgcrypto');

        Schema::create('auth.company_modules', function (Blueprint $table) {
            $table->uuid('id')->primary()->default(DB::raw('gen_random_uuid()'));
            $table->uuid('company_id');
            $table->uuid('module_id');
            $table->boolean('is_active')->default(true);
            $table->json('settings')->nullable();
            $table->uuid('enabled_by_user_id')->nullable();
            $table->timestamp('enabled_at')->nullable();
            $table->uuid('disabled_by_user_id')->nullable();
            $table->timestamp('disabled_at')->nullable();
            $table->timestamps();

            // Indexes
            $table->index(['company_id', 'module_id']);
            $table->index(['company_id', 'is_active']);
            $table->index(['module_id', 'is_active']);
            $table->index('enabled_by_user_id');
            $table->index('disabled_by_user_id');
            $table->unique(['company_id', 'module_id'], 'uniq_company_module');

            // Foreign key constraints
            $table->foreign('company_id')
                ->references('id')->on('auth.companies')
                ->onDelete('cascade');

            $table->foreign('module_id')
                ->references('id')->on('auth.modules')
                ->onDelete('cascade');

            $table->foreign('enabled_by_user_id')
                ->references('id')->on('auth.users')
                ->onDelete('set null');

            $table->foreign('disabled_by_user_id')
                ->references('id')->on('auth.users')
                ->onDelete('set null');
        });

        // Add RLS policy for company_modules table
        DB::statement('
            ALTER TABLE auth.company_modules ENABLE ROW LEVEL SECURITY;
        ');

        // Policy: Users can see modules for companies they belong to
        DB::statement("
            CREATE POLICY company_modules_select_policy ON auth.company_modules
            FOR SELECT
            USING (
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND is_active = true
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Drop existing policies to avoid duplicates
        DB::statement('DROP POLICY IF EXISTS company_modules_insert_policy ON auth.company_modules');
        DB::statement('DROP POLICY IF EXISTS company_modules_update_policy ON auth.company_modules');
        DB::statement('DROP POLICY IF EXISTS company_modules_delete_policy ON auth.company_modules');

        // Policy: Company owners/admins can insert modules
        DB::statement("
            CREATE POLICY company_modules_insert_policy ON auth.company_modules
            FOR INSERT
            WITH CHECK (
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company owners/admins can update modules
        DB::statement("
            CREATE POLICY company_modules_update_policy ON auth.company_modules
            FOR UPDATE
            USING (
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Policy: Company owners/admins can delete modules
        DB::statement("
            CREATE POLICY company_modules_delete_policy ON auth.company_modules
            FOR DELETE
            USING (
                company_id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Create trigger for updated_at
        DB::statement('
            CREATE TRIGGER company_modules_updated_at
                BEFORE UPDATE ON auth.company_modules
                FOR EACH ROW
                EXECUTE FUNCTION auth.set_updated_by();
        ');
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop trigger first
        DB::statement('DROP TRIGGER IF EXISTS company_modules_updated_at ON auth.company_modules');

        // Drop table
        Schema::dropIfExists('auth.company_modules');
    }
};

---- File Content End ----


=== File: 2025_10_11_110306_enhance_company_rls_policies.php ===
Path: 2025_10_11_110306_enhance_company_rls_policies.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        // Ensure all company-related tables have proper RLS policies
        
        // 1. Companies table - Enhance existing policies
        // Drop existing policies to recreate them
        DB::statement('DROP POLICY IF EXISTS companies_select_policy ON auth.companies');
        DB::statement('DROP POLICY IF EXISTS companies_update_policy ON auth.companies');
        DB::statement('DROP POLICY IF EXISTS companies_insert_policy ON auth.companies');
        
        // Enhanced SELECT policy - users can see companies they belong to
        DB::statement("
            CREATE POLICY companies_select_policy ON auth.companies
            FOR SELECT
            USING (
                id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND is_active = true
                )
                OR
                id IN (
                    SELECT company_id
                    FROM auth.company_invitations
                    WHERE email = (
                        SELECT email FROM auth.users 
                        WHERE id = current_setting('app.current_user_id', true)::uuid
                    )
                    AND status = 'pending'
                    AND expires_at > NOW()
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // Enhanced UPDATE policy - company owners and admins can update
        DB::statement("
            CREATE POLICY companies_update_policy ON auth.companies
            FOR UPDATE
            USING (
                id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role IN ('owner', 'admin')
                    AND is_active = true
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // INSERT policy - users can create companies (filtered at application level)
        DB::statement("
            CREATE POLICY companies_insert_policy ON auth.companies
            FOR INSERT
            WITH CHECK (
                current_setting('app.current_user_id', true)::uuid IS NOT NULL
            );
        ");

        // DELETE policy - company owners can delete
        DB::statement("
            CREATE POLICY companies_delete_policy ON auth.companies
            FOR DELETE
            USING (
                id IN (
                    SELECT company_id
                    FROM auth.company_user
                    WHERE user_id = current_setting('app.current_user_id', true)::uuid
                    AND role = 'owner'
                    AND is_active = true
                )
                OR
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        // 2. Company user table - Add RLS if not exists
        if (Schema::hasTable('auth.company_user')) {
            DB::statement('ALTER TABLE auth.company_user ENABLE ROW LEVEL SECURITY');
            
            // Drop existing policies if they exist
            DB::statement('DROP POLICY IF EXISTS company_user_select_policy ON auth.company_user');
            DB::statement('DROP POLICY IF EXISTS company_user_update_policy ON auth.company_user');
            
            DB::statement("
                CREATE POLICY company_user_select_policy ON auth.company_user
                FOR SELECT
                USING (
                    user_id = current_setting('app.current_user_id', true)::uuid
                    OR
                    company_id IN (
                        SELECT company_id
                        FROM auth.company_user
                        WHERE user_id = current_setting('app.current_user_id', true)::uuid
                        AND is_active = true
                    )
                    OR
                    current_setting('app.is_super_admin', true)::boolean = true
                );
            ");

            DB::statement("
                CREATE POLICY company_user_update_policy ON auth.company_user
                FOR UPDATE
                USING (
                    company_id IN (
                        SELECT company_id
                        FROM auth.company_user
                        WHERE user_id = current_setting('app.current_user_id', true)::uuid
                        AND role IN ('owner', 'admin')
                        AND is_active = true
                    )
                    OR
                    current_setting('app.is_super_admin', true)::boolean = true
                );
            ");
        }

        // 3. Ensure accounting tables have company-scoped RLS
        // These will be created when accounting module tables exist
        $this->ensureAccountingRlsPolicies();
    }

    /**
     * Ensure accounting tables have proper RLS policies
     */
    private function ensureAccountingRlsPolicies(): void
    {
        // Check if fiscal_years table exists and add RLS if needed
        if (Schema::hasTable('acct.fiscal_years')) {
            DB::statement('ALTER TABLE acct.fiscal_years ENABLE ROW LEVEL SECURITY');
            
            // Drop existing policies if they exist
            DB::statement('DROP POLICY IF EXISTS fiscal_years_select_policy ON acct.fiscal_years');
            DB::statement('DROP POLICY IF EXISTS fiscal_years_update_policy ON acct.fiscal_years');
            
            DB::statement("
                CREATE POLICY fiscal_years_select_policy ON acct.fiscal_years
                FOR SELECT
                USING (
                    company_id IN (
                        SELECT company_id
                        FROM auth.company_user
                        WHERE user_id = current_setting('app.current_user_id', true)::uuid
                        AND is_active = true
                    )
                    OR
                    current_setting('app.is_super_admin', true)::boolean = true
                );
            ");

            DB::statement("
                CREATE POLICY fiscal_years_update_policy ON acct.fiscal_years
                FOR UPDATE
                USING (
                    company_id IN (
                        SELECT company_id
                        FROM auth.company_user
                        WHERE user_id = current_setting('app.current_user_id', true)::uuid
                        AND role IN ('owner', 'admin', 'accountant')
                        AND is_active = true
                    )
                    OR
                    current_setting('app.is_super_admin', true)::boolean = true
                );
            ");
        }

        // Check if accounting_periods table exists and add RLS if needed
        if (Schema::hasTable('acct.accounting_periods')) {
            DB::statement('ALTER TABLE acct.accounting_periods ENABLE ROW LEVEL SECURITY');
            
            // Drop existing policy if it exists
            DB::statement('DROP POLICY IF EXISTS accounting_periods_select_policy ON acct.accounting_periods');
            
            DB::statement("
                CREATE POLICY accounting_periods_select_policy ON acct.accounting_periods
                FOR SELECT
                USING (
                    fiscal_year_id IN (
                        SELECT id FROM acct.fiscal_years
                        WHERE company_id IN (
                            SELECT company_id
                            FROM auth.company_user
                            WHERE user_id = current_setting('app.current_user_id', true)::uuid
                            AND is_active = true
                        )
                    )
                    OR
                    current_setting('app.is_super_admin', true)::boolean = true
                );
            ");
        }

        // Chart_of_accounts table doesn't exist yet - will be handled when created
        // Accounts table doesn't exist yet - will be handled when created
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        // Drop enhanced company policies
        DB::statement('DROP POLICY IF EXISTS companies_select_policy ON auth.companies');
        DB::statement('DROP POLICY IF EXISTS companies_update_policy ON auth.companies');
        DB::statement('DROP POLICY IF EXISTS companies_insert_policy ON auth.companies');
        DB::statement('DROP POLICY IF EXISTS companies_delete_policy ON auth.companies');

        // Drop company user policies
        DB::statement('DROP POLICY IF EXISTS company_user_select_policy ON auth.company_user');
        DB::statement('DROP POLICY IF EXISTS company_user_update_policy ON auth.company_user');

        // Drop accounting policies
        DB::statement('DROP POLICY IF EXISTS fiscal_years_select_policy ON acct.fiscal_years');
        DB::statement('DROP POLICY IF EXISTS fiscal_years_update_policy ON acct.fiscal_years');
        DB::statement('DROP POLICY IF EXISTS accounting_periods_select_policy ON acct.accounting_periods');

        // Restore basic policies
        DB::statement("
            CREATE POLICY companies_select_policy ON auth.companies
            FOR SELECT
            USING (
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");

        DB::statement("
            CREATE POLICY companies_update_policy ON auth.companies
            FOR UPDATE
            USING (
                current_setting('app.is_super_admin', true)::boolean = true
            );
        ");
    }
};

---- File Content End ----


=== File: 2025_10_14_120000_create_command_configurations_table.php ===
Path: 2025_10_14_120000_create_command_configurations_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('command_configurations', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('company_id');
            $table->string('environment'); // local, staging, production
            $table->json('configuration'); // Environment-specific command settings
            $table->boolean('is_active')->default(true);
            $table->timestamps();

            $table->foreign('company_id')->references('id')->on('auth.companies')->onDelete('cascade');
            $table->index(['company_id', 'environment']);
            $table->unique(['company_id', 'environment']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('command_configurations');
    }
};

---- File Content End ----


=== File: 2025_10_13_061059_create_credit_note_applications_table.php ===
Path: 2025_10_13_061059_create_credit_note_applications_table.php
---- File Content Start ----
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    /**
     * Run the migrations.
     */
    public function up(): void
    {
        Schema::create('acct.credit_note_applications', function (Blueprint $table) {
            $table->uuid('id')->primary();
            $table->uuid('credit_note_id');
            $table->uuid('invoice_id');
            $table->decimal('amount_applied', 15, 2);
            $table->timestamp('applied_at');
            $table->uuid('applied_by_user_id')->nullable();
            $table->text('notes')->nullable();
            $table->timestamps();

            // Foreign keys
            $table->foreign('credit_note_id')->references('id')->on('acct.credit_notes')->onDelete('cascade');
            $table->foreign('invoice_id')->references('id')->on('acct.invoices')->onDelete('cascade');
            $table->foreign('applied_by_user_id')->references('id')->on('auth.users')->onDelete('set null');

            // Indexes
            $table->index(['credit_note_id']);
            $table->index(['invoice_id']);
            $table->index(['applied_at']);
        });
    }

    /**
     * Reverse the migrations.
     */
    public function down(): void
    {
        Schema::dropIfExists('acct.credit_note_applications');
    }
};

---- File Content End ----

